//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//
//        wopfner@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartLaserLMS100Server component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------
#include "LaserTask.hh"
#include "ComponentLaserLMS1xx.hh"
#include <EulerTransformationMatrices.hh>
#include <iostream>

LaserTask::LaserTask(SmartACE::SmartComponent *comp) 
:	LaserTaskCore(comp)
{
	std::cout << "constructor LaserTask\n";
	_default_base_position.set_x(COMP->getGlobalState().getBase_manipulator().getX());
	_default_base_position.set_y(COMP->getGlobalState().getBase_manipulator().getY());
	_default_base_position.set_z(COMP->getGlobalState().getBase_manipulator().getZ());
	_default_base_position.set_base_azimuth(COMP->getGlobalState().getBase_manipulator().getBase_a());
	//_default_base_position.set_steer_alpha(COMP->getGlobalState().getBase_manipulator().getSteer_a());
	//_default_base_position.set_turret_alpha(COMP->getGlobalState().getBase_manipulator().getTurret_a());

	// set scan id counter to 0
	scan_id = 0;

}
LaserTask::~LaserTask() 
{
	std::cout << "destructor LaserTask\n";
}

bool LaserTask::accquireNewScan(CommBasicObjects::CommMobileLaserScan& scan) {
	scanData data;

	//std::cout << "read new laser data ...\n";
	//laser.scanSingle();
	laser.getScanData(&data);

	// set scan header
	scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp::now());
	scan.set_scan_update_count(scan_id);

	//////////////////////////
	// set scan parameters
	//////////////////////////
	if (COMP->getGlobalState().getScanner().getVerbose())
		std::cout << "set scan parameters\n";

	scan.set_scan_length_unit(lenght_unit);
	scan.set_scan_integer_field_of_view(-0.5 * opening_angle, scan_resolution);
	scan.set_min_distance(min_dist);
	scan.set_max_distance(max_dist);

	//////////////////////////
	// set scan points
	//////////////////////////

	const int desiredScans = 1 + opening_angle / scan_resolution;
	const int rangerScans = 1 + ranger_opening_angle / scan_resolution;

	// alex: set the new attribute (used by GMapping)
	scan.set_max_scan_size(desiredScans);

	const int firstScanIndex = (rangerScans - desiredScans) * 0.5;
	int lastScanIndex = rangerScans - firstScanIndex;

	if (lastScanIndex > data.dist_len1)
		lastScanIndex = data.dist_len1;

	if (COMP->getGlobalState().getScanner().getVerbose()) {
		std::cout << "Read scans: " << data.dist_len1 << "\n";
	}

	uint32_t num_valid_points = 0;
	for (int i = firstScanIndex; i < lastScanIndex; ++i) {
		const unsigned int dist = data.dist1[i];
		if (dist >= min_dist && dist <= max_dist) {
			++num_valid_points;
		}
	}

	scan.set_scan_size(num_valid_points);

	uint32_t valid_point_index = 0;
	for (int i = firstScanIndex; i < lastScanIndex; ++i) {
		const unsigned int dist = data.dist1[i];
		if (dist >= min_dist && dist <= max_dist) {
//			std::cout<<"Point [i]: "<<i<<" dist1|rssi1: "<<data.dist1[i]<<" | "<<data.rssi1[i]<<" dist2|rssi2: "<<data.dist2[i]<<" | "<<data.rssi2[i]<<std::endl;

			//this line will cut of the starting beam if the component is configures to provide smaller scans (less opening angle)
			scan.set_scan_index(valid_point_index, i - firstScanIndex);
			scan.set_scan_integer_distance(valid_point_index, dist);
			//Lutz: WARNING This is very dangerous! The commObject takes only 8 Bit but the laser can detect in 8 or 16 Bit, ensure the correct laser configuration!
			scan.set_scan_intensity(valid_point_index, data.rssi1[i]);
			unsigned char res = scan.get_scan_intensity(valid_point_index);
//			std::cout<<"Point [i]: "<<i<<" dist1|rssi1: "<<data.dist1[i]<<" | "<<data.rssi1[i]<<" read: "<<(int)res<<std::endl;
			++valid_point_index;
		}
	}

	scan.set_scan_valid(true);
	scan_id++;

	return true;
}

void LaserTask::initLaser() {
	min_dist = COMP->getGlobalState().getScanner().getMin_range();
	max_dist = COMP->getGlobalState().getScanner().getMax_range();
	lenght_unit = COMP->getGlobalState().getScanner().getLength_unit();
	opening_angle = (COMP->getGlobalState().getScanner().getOpening_angle())*100;

	// open device
	laser.connect(COMP->getGlobalState().getScanner().getIp_address(), COMP->getGlobalState().getScanner().getPort());
	if (!laser.isConnected()) {
		std::cout << "[LaserTask] Connection failed!" << std::endl;
	}

	std::cout << "[LaserTask] Connected to laser ..." << std::endl;

	std::cout << "[LaserTask] Loging in ..." << std::endl;
	laser.login();
	laser.stopMeas();

	std::cout << "[LaserTask] Getting scan configuration ..." << ::std::endl;

	scanDataCfg cc;
	//cc.outputChannel = 0x03;
	cc.outputChannel = 0x0F; // all 4 channels DIST1 + RSSI 1 + DIST2 + RSSI 2
	cc.remission = true;
	cc.resolution = 0; //8 Bit! 0-255
	//Einheit?
	cc.encoder = 0;
	cc.position = false;
	cc.deviceName = false;
	cc.timestamp = false;
	cc.outputInterval = 1;
	laser.setScanDataCfg(cc);


	scanCfg c = laser.getScanCfg();
	std::cout<<"[LaserTask] Init config of scanner: "<<c<<std::endl;

	c.angleResolution = round(COMP->getGlobalState().getScanner().getResolution() * 100000);
	c.scaningFrequency = COMP->getGlobalState().getScanner().getFrequency() * 100;

	// set laser parameters
	laser.setScanCfg(c);

	// read set parameters
	c = laser.getScanCfg();
	scan_resolution = c.angleResolution / 100.0;
	ranger_opening_angle = (c.stopAngle - c.startAngle) / 100.0;

	std::cout << "[LaserTask] Scanning Frequency: " << c.scaningFrequency / 100.0 << "Hz | AngleResolution: "
			<< c.angleResolution / 10000.0 << "deg | StartAngle: " << c.startAngle / 10000.0 << "deg | StopAngle: "
			<< c.stopAngle / 10000.0 << "deg \n";

}


int LaserTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	zero_velocity.set_vX(0);
	zero_velocity.set_WX_base(0);
	//zero_velocity.set_w_steer(0);
	//zero_velocity.set_w_turret(0);

	// init laser
	initLaser();

	std::cout << "[LaserTask] Start measurements ..." << std::endl;
	laser.startMeas();

	std::cout << "[LaserTask] Wait for ready status ..." << std::endl;
	status_t ret = undefined;
	while (ret != ready_for_measurement) {
		ret = laser.queryStatus();
		std::cout << "[LaserTask] Status : " << LMS1xx::statusToString(ret) << std::endl;
		sleep(1);
	}
	std::cout << "[LaserTask] Laser ready!" << std::endl;

	//start continuous data send!
	laser.scanContinous(1);



	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;

	return 0;
}
int LaserTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;

	std::cout << "Hello from LaserTask " << std::endl;

	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

	if (accquireNewScan(scan)) {
				bool scan_is_valid = false;

				//////////////////////////
				// set base state
				//////////////////////////
				if (COMP->getGlobalState().getScanner().getVerbose())
					std::cout << "[LaserTask] set base state\n";

				// read base state from base server
				if (COMP->getGlobalState().getBase_manipulator().getOn_base()) {
					//Smart::StatusCode status = COMP->baseStateServiceIn->getUpdate(base_state);
					Smart::StatusCode status = this->baseStateServiceInGetUpdate(base_state);
					if (status == Smart::SMART_OK) {
						scan_is_valid = true;

						if (COMP->getGlobalState().getScanner().getVerbose()) {
							std::cout << base_state << "\n";
						}
					} else {
						std::cerr << "[LaserTask] WARNING: failed to get current base state ("
								<< Smart::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
						scan.set_scan_valid(false);
					}
				}
				// default base state
				else {
					base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
					base_state.set_base_position(_default_base_position);
					base_state.set_base_velocity(zero_velocity);
					scan_is_valid = true;
				}
				scan.set_base_state(base_state);

				//////////////////////////
				// set robot scanner position
				//////////////////////////
				double x = COMP->getGlobalState().getScanner().getX();
				double y = COMP->getGlobalState().getScanner().getY();
				double z = COMP->getGlobalState().getScanner().getZ();
				double azimuth = COMP->getGlobalState().getScanner().getAzimuth();
				double elevation = COMP->getGlobalState().getScanner().getElevation();
				double roll = COMP->getGlobalState().getScanner().getRoll();
				arma::mat mat_sensor;

				EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_sensor);

				CommBasicObjects::CommPose3d sensor_pose(mat_sensor);
				scan.set_sensor_pose(sensor_pose);

				//////////////////////////
				// set world scanner position
				//////////////////////////
				double base_x = 0;
				double base_y = 0;
				double base_z = 0;
				double base_a = 0;
				arma::mat mat_base(4, 4);

				if (scan_is_valid) {
					base_x = base_state.get_base_position().get_x();
					base_y = base_state.get_base_position().get_y();
					base_z = base_state.get_base_position().get_z();
					if (COMP->getGlobalState().getScanner().getOn_turret()) {
						//base_a = base_state.get_base_position().get_turret_alpha();
					} else {
						base_a = base_state.get_base_position().get_base_azimuth();
					}
				}

				EulerTransformationMatrices::create_zyx_matrix(base_x, base_y, base_z, base_a, 0, 0, mat_base);
				arma::mat mat_world = mat_base * mat_sensor;
				CommBasicObjects::CommPose3d world_pose(mat_world);

				scan.set_scanner_x(world_pose.get_x());
				scan.set_scanner_y(world_pose.get_y());
				scan.set_scanner_z(world_pose.get_z());

				scan.set_scanner_azimuth(world_pose.get_azimuth());
				scan.set_scanner_elevation(world_pose.get_elevation());
				scan.set_scanner_roll(world_pose.get_roll());

				//////////////////////////
				// send scan to clients
				//////////////////////////
				if (COMP->getGlobalState().getScanner().getVerbose())
					std::cout << "[LaserTask] send scan to clients\n";

				if (COMP->getGlobalState().getServices().getActivate_push_newest()) {
					Smart::StatusCode push_status = COMP->laserServiceOut->put(scan);
					if (push_status != Smart::SMART_OK) {
						std::cerr << "[LaserTask] WARNING: error on push (" << Smart::StatusCodeConversion(push_status)
								<< ")" << std::endl;
					}
				}

				// copy local scan to global scan
				SmartACE::SmartGuard scan_guard(COMP->ScanLock);
				COMP->global_scan = scan;
				scan_guard.release();

				if (COMP->getGlobalState().getScanner().getVerbose()) {
					const unsigned int index = scan.get_scan_size() / 2;
					std::cout << "[LaserTask] Scan " << scan_id << " sent." << " Scan Position " << index << "/"
							<< scan.get_scan_size() << " = " << scan.get_scan_distance(index - 1) << " mm" << std::endl;
				}
			} else {
				std::cerr << "[LaserTask] WARNING: received unexpected packet type" << std::endl;
			}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int LaserTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	laser.stopMeas();

	std::cout << "[LaserTask] Disconnect from laser" << std::endl;
	laser.disconnect();
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;

	return 0;
}
