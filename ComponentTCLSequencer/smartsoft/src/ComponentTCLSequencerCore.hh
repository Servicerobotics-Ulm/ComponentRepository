//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#ifndef _COMPONENTTCLSEQUENCERCORE_HH
#define _COMPONENTTCLSEQUENCERCORE_HH
	
#include "lispSeparator.h"
#include "eventInterface.hh"
#include "HandlerTimerService.hh"
#include "aceSmartSoft.hh"
#include <iostream>
#include <map>

#include "LispTokenizer.hh"


typedef struct
{
	std::string ciTypeName;
	std::string componentInstanceName;
	std::map< std::string,std::string >serviceNameMap;

}CiConnection;

struct ciLessLibC : public std::binary_function<std::string, std::string, bool> {
	bool operator()(const std::string &lhs, const std::string &rhs) const {
		return strcasecmp(lhs.c_str(), rhs.c_str()) < 0 ;
	}
};

static void printCiConnection(std::map<std::string, CiConnection >::iterator c){
	std::cout<<"\n\n==========================================\n";
	std::cout<<"------------------------------------------\n";
	std::cout<<"CI Inst name: "<<c->first<<std::endl;
	std::cout<<"------------------------------------------\n";
//
//	std::map<std::string, ComponentConnection >::iterator iter = c->second.begin();
//	for(;iter!=c->second.end();iter++){
//
//		std::cout<<"------------------------------------------\n";
//		std::cout<<"Component:"<<iter->first<<std::endl;
//		std::cout<<"------------------------------------------\n";
//		std::cout<<"componentTypeName: "<<iter->second.componentTypeName<<std::endl;
//		std::cout<<"componentInstanceName: "<<iter->second.componentInstanceName<<std::endl;
//		std::cout<<"------------------------------------------\n";
//		std::map< std::string,std::string >::const_iterator innerIter = iter->second.serviceNameMap.begin();
//		for(;innerIter!=iter->second.serviceNameMap.end();innerIter++){
//			std::cout<<innerIter->first<<" "<<innerIter->second<<std::endl;
//		}
//	}
	std::cout<<"==========================================\n\n";
}


class ComponentTCLSequencerCore
{
private:
	Smart::LispTokenizer lispTokenizer;

public:
	ComponentTCLSequencerCore();

	typedef std::string (*switchCiFunction_t)(const std::string&, const std::string&, const std::string&, const std::string&, const std::string&);
	typedef int (*initCiFunction_t)(SmartACE::SmartComponent *, const std::string&, const std::map< std::string , CiConnection, ciLessLibC> &);
	typedef int (*finiCiFunction_t)(const std::string&);

	typedef struct
	{
		switchCiFunction_t switchCiFunction;
		initCiFunction_t initCiFunction;
		finiCiFunction_t finiCiFunction;
	}CiFunctions;

	EventInterface *eventInterface;

	HandlerTimerService handlerTimerService;

	// < COORDINATION-INTERFACE-NAME, {ModuleFunctions} >
	std::map<std::string, CiFunctions> ciMap;

	// < CI-INST-NAME , { CiConnection } >
	std::map<std::string, CiConnection, ciLessLibC> ciConnectionsMap;


	bool lispParamToParameterRequest(std::string lispString, SmartACE::CommParameterRequest& request);
	std::string queryParam(SmartACE::ParameterMaster *parameterMaster, const std::string& server, const std::string& param);
	std::string setState(SmartACE::StateMaster *stateMaster, const std::string& server, const std::string& state);

	std::string getState(SmartACE::StateMaster *stateMaster, const std::string& server);
	std::string waitForLifeCycleState(SmartACE::StateMaster *stateMaster, const std::string& server, const std::string& lifeCycleState);

};
	
#endif
