//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "ComponentTCLSequencerCore.hh"

// constructor
ComponentTCLSequencerCore::ComponentTCLSequencerCore()
{
	std::cout << "constructor ComponentTCLSequencerCore\n";

	eventInterface = new EventInterface();
}


std::string ComponentTCLSequencerCore::queryParam(SmartACE::ParameterMaster *parameterMaster, const std::string& server, const std::string& param){


		std::ostringstream outString;
		Smart::StatusCode status;

		SmartACE::CommParameterRequest parameterRequest;
		SmartACE::CommParameterResponse parameterResponse;


//		std::cout<<"QueryParam: "<<param<<std::endl;
//		std::cout<<"Server: "<<server<<std::endl;


//		if (lispParamToParameterRequest(param,parameterRequest) == true)//param.set(input) == 0 )
//		{
			lispTokenizer.parse(param);
//			lispTokenizer.printTree();
			parameterRequest = lispTokenizer.getCommParamRequest();

			// everything is ok
//			status = COMP->amclParamClient->send(param);
			status = parameterMaster->sendParameterWait(parameterRequest, parameterResponse, server);
			switch (status)
			{
				case Smart::SMART_OK:
					switch(parameterResponse.getResponse().get_value()){
						case SmartACE::ParamResponseType::BUSY:
							outString << "(error (busy))";
							break;
						case SmartACE::ParamResponseType::INVALID:
							outString << "(error (wrong parameter))";
							break;
						case SmartACE::ParamResponseType::OK:
							outString << "(ok ())";
							break;
						default:
							std::cout<<"ComponentTCLSequencerCore.cc::THIS SHOULD NEVEN HAPPEN!"<<std::endl;
							break;
					}
					break;
				case Smart::SMART_CANCELLED:
					outString << "(error (smart cancelled))";
					break;
				case Smart::SMART_UNKNOWNCOMPONENT:
					outString << "(error (smart unknown component))";
					break;
				case Smart::SMART_UNKNOWNPORT:
					outString << "(error (smart unknown port))";
					break;
				case Smart::SMART_SERVICEUNAVAILABLE:
					outString << "(error (smart service unavailable))";
					break;
				case Smart::SMART_INCOMPATIBLESERVICE:
					outString << "(error (smart incompatible service))";
					break;
				case Smart::SMART_ERROR:
					outString << "(error (smart error))";
					break;
				default:
					outString << "(error (unknown error))";
					break;
			}
//		}
//		else
//		{
//			// error occured
//			sprintf(outString,"(error (wrong parameter))");
//		}

		return outString.str();
}


std::string ComponentTCLSequencerCore::setState(SmartACE::StateMaster *stateMaster, const std::string& server, const std::string& state){
		std::ostringstream outString;

		Smart::StatusCode status;
		char *input  = (char *)NULL;
		char *pointer = (char *)NULL;
		char *param1  = (char *)NULL;

		pointer = input = strdup(state.c_str());
		do
		{
			param1 = strsep(&input,LISP_SEPARATOR);
		} while ((param1 != NULL) && (strlen(param1)==0));

		std::string str(param1);

		status = stateMaster->setWaitState(str,server);
		switch (status)
		{
			case Smart::SMART_OK:
				outString << "(ok ())";
				break;
			case Smart::SMART_UNKNOWNSTATE:
				outString << "(error (smart unknown state))";
				break;
			case Smart::SMART_NOTACTIVATED:
				outString << "(error (smart state not activated))";
				break;
			case Smart::SMART_CANCELLED:
				outString << "(error (smart cancelled))";
				break;
			case Smart::SMART_ERROR_COMMUNICATION:
				outString << "(error (smart communication error))";
				break;
			case Smart::SMART_ERROR:
				outString << "(error (smart error))";
				break;
			case Smart::SMART_SERVICEUNAVAILABLE:
				outString << "(error (smart service unavailable))";
				break;
			default:
				std::cout<<"error : "<<Smart::StatusCodeConversion(status)<<std::endl;
				outString << "(error (unknown error))";
				break;
		}

		return outString.str();
}

std::string ComponentTCLSequencerCore::getState(SmartACE::StateMaster *stateMaster, const std::string& server){

	std::ostringstream outString;
	Smart::StatusCode status;

	std::string mainState;
	status = stateMaster->getCurrentMainState(mainState, server);
	switch (status)
	{
	case Smart::SMART_OK:
		outString<<"(ok ("<<mainState.c_str()<<"))";
		break;
	case Smart::SMART_UNKNOWNSTATE:
		outString<<"(error (smart unknown state))";
		break;
	case Smart::SMART_NOTACTIVATED:
		outString<<"(error (smart state not activated))";
		break;
	case Smart::SMART_CANCELLED:
		outString<<"(error (smart cancelled))";
		break;
	case Smart::SMART_ERROR_COMMUNICATION:
		outString<<"(error (smart communication error))";
		break;
	case Smart::SMART_ERROR:
		outString<<"(error (smart error))";
		break;
	case Smart::SMART_SERVICEUNAVAILABLE:
		outString<<"(error (smart service unavailable))";
		break;
	default:
		std::cout<<"error : "<<Smart::StatusCodeConversion(status)<<std::endl;
		outString<<"(error (unknown error))";
		break;
	}

	return outString.str();
}


std::string ComponentTCLSequencerCore::waitForLifeCycleState(SmartACE::StateMaster *stateMaster, const std::string& server, const std::string& lifeCycleState){

	std::ostringstream outString;
	Smart::StatusCode status;

	std::string str(lifeCycleState);
	str.erase(std::remove(str.begin(), str.end(), '"'), str.end());

	std::cout<<"Check if component: "<<server<<" is in state: "<<str<<std::endl;
	bool done = false;

	do{
		std::string mainState;
		status = stateMaster->getCurrentMainState(mainState, server);
		switch (status)
		{
		case Smart::SMART_OK:
			if(mainState.compare(str) == 0){
				done = true;
				outString<<"(ok ())";
				std::cout<<"[waitForLifeCycleState] Component "<< server <<" is in state to wait for: "<<str<<std::endl;
				return outString.str();
			} else {
				std::cout<<"[waitForLifeCycleState] Component "<< server <<"  is in state: "<<mainState<<std::endl;
			}
			break;
		case Smart::SMART_NOTACTIVATED:
			outString<<"(error (smart state not activated))";
			break;
		case Smart::SMART_CANCELLED:
			outString<<"(error (smart cancelled))";
			break;
		case Smart::SMART_ERROR_COMMUNICATION:
			outString<<"(error (smart communication error))";
			break;
		case Smart::SMART_ERROR:
			outString<<"(error (smart error))";
			done = true;
			break;
		case Smart::SMART_SERVICEUNAVAILABLE:
			outString<<"(error (smart service unavailable))";
			break;
		default:
			std::cout<<"[waitForLifeCycleState]  error : "<<Smart::StatusCodeConversion(status)<<std::endl;
			outString<<"(error (unknown error))";
			done = true;
			break;
		}

		std::cout<<"[waitForLifeCycleState] Status: "<<Smart::StatusCodeConversion(status)<<std::endl;
		ACE_OS::sleep(ACE_Time_Value(0,500000));


	}while(done == false);


	return outString.str();
}
