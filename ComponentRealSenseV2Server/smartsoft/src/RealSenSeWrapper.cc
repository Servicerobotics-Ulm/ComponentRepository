//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 2.2
// The SmartSoft Toolchain has been developed by:
//
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2011, 2017 Matthias Lutz, Dennis Stampfer, Matthias Rollenhagen, Nayabrasul Shaik
//
//      lutz@hs-ulm.de
//      stampfer@hs-ulm.de
//      rollenhagen@hs-ulm.de
//      shaik@hs-ulm.de
//
//      ZAFH Servicerobotic Ulm
//      Christian Schlegel
//      University of Applied Sciences
//      Prittwitzstr. 10
//      89075 Ulm
//      Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "RealSenSeWrapper.hh"
#include <librealsense2/h/rs_pipeline.h>
#include <librealsense2/rsutil.h>
#define TEXT_COLOR_RESET   "\033[0m"
#define TEXT_COLOR_GREEN   "\033[32m"      /* Green */

RealSenSeWrapper::RealSenSeWrapper(int color_width, int color_height, int color_framerate,
        int depth_width, int depth_height, int depth_framerate, std::string device_serial_num, float in_baseline){

	std::cout << "Initializing RealSense device"<<std::endl;

	color_width_     = color_width;
	color_height_    = color_height;
	color_framerate_ = color_framerate;

	depth_width_     = depth_width;
	depth_height_    = depth_height;
	depth_framerate_ = depth_framerate;

	device_serial_number_ = device_serial_num;

	baseline         = in_baseline;

	while (init_Camera()==false) {
		std::cout<<"Error init camera --> retry"<<std::endl;
		sleep(1);
	}

	std::cout<<TEXT_COLOR_RESET<< TEXT_COLOR_GREEN; // make the screen output Green
	std::cout << "-----------------------------------------------------------------------------------------" <<std::endl;
	std::cout << std::setw(25)<<"Device Name"<<": "<< rs2_device_.get_info(RS2_CAMERA_INFO_NAME)<<std::endl;
	std::cout << std::setw(25)<<"Firmware Version"<<": "<<rs2_device_.get_info(RS2_CAMERA_INFO_FIRMWARE_VERSION)<<std::endl;
	std::cout << std::setw(25)<<"Serial Number"<<": "<<rs2_device_.get_info(RS2_CAMERA_INFO_SERIAL_NUMBER)<<std::endl;
	std::cout << std::setw(25)<<"Product Id"<<": "<<rs2_device_.get_info(RS2_CAMERA_INFO_PRODUCT_ID)<<std::endl;
	std::cout << std::setw(25)<<"Realsense SDK version"<<": "<<RS2_API_MAJOR_VERSION <<"."<<RS2_API_MINOR_VERSION <<"."<<RS2_API_PATCH_VERSION<<std::endl;
	std::cout << std::setw(25)<<"Baseline( in mm)"<<": "<<baseline <<std::endl;
	std::cout << "-----------------------------------------------------------------------------------------" <<std::endl;
	std::cout<<TEXT_COLOR_RESET;


	sensor_list = rs2_device_.query_sensors();
	int is_depth_sensor_found = 0;
	int is_rgb_sensor_found = 0;

	std::string depth_sensor_name = "Stereo Module";
	std::string rgb_sensor_name = "RGB Camera";

	for (rs2::sensor sensor : sensor_list)
	{
		// Check if the given sensor can be extended to depth sensor interface
		rs2_error* e = nullptr;
		std::string current_sensor_name = sensor.get_info(RS2_CAMERA_INFO_NAME);
		//std::cout << " current_sensor_name.c_str() =" <<  current_sensor_name.c_str()<<std::endl;

		if(!std::strcmp(depth_sensor_name.c_str(), current_sensor_name.c_str()))
		{
			rs2_sensor_depth = sensor;
			is_depth_sensor_found =1;
		}

		if(!std::strcmp(rgb_sensor_name.c_str(), current_sensor_name.c_str()))
		{
			rs2_sensor_rgb = sensor;
			is_rgb_sensor_found =1;

		}

	}

//	std::cout << "is_depth_sensor_found =" << is_depth_sensor_found<<std::endl;
//	std::cout << "is_rgb_sensor_found =" << is_rgb_sensor_found<<std::endl;

	if(!is_depth_sensor_found || !is_rgb_sensor_found )
	{
		std::cout<<__FUNCTION__<<" ERROR: no depth and rgb sensor found, something is wrong with the device?!"<<std::endl;
		std::abort();
	}

	std::vector<rs2::stream_profile> rgb_stream_profiles   = rs2_sensor_rgb.get_stream_profiles();
	std::vector<rs2::stream_profile> depth_stream_profiles   = rs2_sensor_depth.get_stream_profiles();

	//////////////////////////////
	// search for the correct camera configuration as is given in the ini file
	uint32_t selected_rgb_profile_index=-1;

	for(unsigned int i = 0; i< rgb_stream_profiles.size(); ++i)
	{

		rs2::stream_profile current_profile = rgb_stream_profiles.at(i);
		//search for RGB8 stream only
		if(current_profile.format() == RS2_FORMAT_RGB8){

			// As noted, a stream is an abstraction.
			// In order to get additional data for the specific type of a
			//  stream, a mechanism of "Is" and "As" is provided:
			if (current_profile.is<rs2::video_stream_profile>()) //"Is" will test if the type tested is of the type given
			{
				// "As" will try to convert the instance to the given type
				rs2::video_stream_profile video_stream_profile = current_profile.as<rs2::video_stream_profile>();

				if(current_profile.fps() == color_framerate_ &&
						video_stream_profile.width() == color_width_ &&
						video_stream_profile.height() == color_height_){
					std::cout<<"Found matching color stream: "<< i<<std::endl;
					selected_rgb_profile_index = i;

					std::cout << "FPS: "<<current_profile.fps()<<"(Video Stream: " << video_stream_profile.format() << " " <<
											video_stream_profile.width() << "x" << video_stream_profile.height() << "@ " << video_stream_profile.fps() << "Hz)"<<std::endl;

					break;
				}

			}
		}
	}
	// search for the correct camera configuration as is given in the ini file
		uint32_t selected_depth_profile_index=-1;

		for(unsigned int i = 0; i< depth_stream_profiles.size(); ++i)
		{

			rs2::stream_profile current_profile = depth_stream_profiles.at(i);
			//search for depth stream only
			if(current_profile.format() == RS2_FORMAT_Z16){

				// As noted, a stream is an abstraction.
				// In order to get additional data for the specific type of a
				//  stream, a mechanism of "Is" and "As" is provided:
				if (current_profile.is<rs2::video_stream_profile>()) //"Is" will test if the type tested is of the type given
				{
					// "As" will try to convert the instance to the given type
					rs2::video_stream_profile video_stream_profile = current_profile.as<rs2::video_stream_profile>();

					// After using the "as" method we can use the new data type
					//  for additinal operations:


					if(current_profile.fps() == depth_framerate_ &&
							video_stream_profile.width() == depth_width_ &&
							video_stream_profile.height() == depth_height_){
						std::cout<<"Found matching depth stream: "<< i<<std::endl;
						selected_depth_profile_index = i;
						std::cout << "FPS: "<<current_profile.fps()<<"(Video Stream: " << video_stream_profile.format() << " " <<
											 video_stream_profile.width() << "x" << video_stream_profile.height() << "@ " << video_stream_profile.fps() << "Hz)"<<std::endl;

						break;
					}

				}
			}
		}

		if(selected_rgb_profile_index == -1 || selected_depth_profile_index == -1)
		{
			std::cout << "streams with given configuration is not available, closing the device" <<std::endl;
			std::cout << "Exiting the Component" <<std::endl;
			std::exit(-1);
		}


	const rs2::stream_profile* rgb_stream_profile   = &rgb_stream_profiles[selected_rgb_profile_index];
	const rs2::stream_profile* depth_stream_profile = &depth_stream_profiles[selected_depth_profile_index];


	//Out of 9 only 5 are native streams (including fish-eye), but we are using currently color and depth only
	rs2_error* e = nullptr;

	config.enable_stream(RS2_STREAM_COLOR, color_width_, color_height_, RS2_FORMAT_RGB8,color_framerate_);
	config.enable_stream(RS2_STREAM_DEPTH, depth_width_, depth_height_, RS2_FORMAT_Z16, depth_framerate_);

	//RealSense intrinsics and extrinsics
	rs2_get_video_stream_intrinsics(rgb_stream_profile->get(),   &color_intrinsics, &e);
	rs2_get_video_stream_intrinsics(depth_stream_profile->get(), &depth_intrinsics, &e);
	rs2_get_extrinsics(depth_stream_profile->get(), rgb_stream_profile->get(), &d2c_extrinsics, &e);

	display_intrinsics_extrinsics();
}

RealSenSeWrapper::~RealSenSeWrapper() {
	   stopVideo();

}

void RealSenSeWrapper::startVideo() {

	try {
		pipeline_profile = pipeline.start(config);
		std::cout << "Camera Started here"<<std::endl;

	} catch (std::exception &e) {
		std::cerr << __FILE__<<__LINE__<<"Error while Opening RealSense device : "
				<< e.what() << "\n";
	}
}

void RealSenSeWrapper::stopVideo() {
	try {
		pipeline.stop();
		std::cout << "Realsense device is Closed" <<std::endl;
	} catch (std::exception &e) {
		std::cerr << __FILE__<<__LINE__<<"Error while closing RealSense device : "
				<< e.what() << "\n";
	}

}


void RealSenSeWrapper::getrgbimage(DomainVision::CommVideoImage& comm_rgb_frame)
{
		rs2::video_frame current_rgb_frame   = current_frameset.get_color_frame();
	    //std:: cout <<  "color_frame_number = " << current_rgb_frame.get_frame_number() <<std::endl;

		const unsigned char *color_frame = (const unsigned char*) current_rgb_frame.get_data();

		auto color_frame_timestamp = current_rgb_frame.get_timestamp();
		auto color_frame_number    = current_rgb_frame.get_frame_number();

		//std:: cout << "w = " << color_intrinsics.width <<  "   H = " << color_intrinsics.height <<std::endl;
		//std:: cout << "frame w = " << current_rgb_frame.get_width() <<  " frame   H = " << current_rgb_frame.get_height() <<std::endl;
		//std:: cout << "color_frame_timestamp = " << color_frame_timestamp <<  "   color_frame_number = " << color_frame_number <<std::endl;

		comm_rgb_frame.set_parameters(current_rgb_frame.get_width(), current_rgb_frame.get_height(), DomainVision::FormatType::RGB24);
		comm_rgb_frame.set_data(color_frame);
		comm_rgb_frame.setIs_valid(true);
	    comm_rgb_frame.setSeq_count(color_frame_number);

	    arma::mat comm_color_intrinsic = arma::zeros(4,4);

	    comm_color_intrinsic(0,0) = color_intrinsics.fx;
	    comm_color_intrinsic(1,1) = color_intrinsics.fy;

	    comm_color_intrinsic(0,2) = color_intrinsics.ppx;
	    comm_color_intrinsic(1,2) = color_intrinsics.ppy;

	    comm_color_intrinsic(2,2) = 1;

	    comm_rgb_frame.set_intrinsic(comm_color_intrinsic);


	    if(color_intrinsics.model==RS2_DISTORTION_BROWN_CONRADY)
	    {
	    	comm_rgb_frame.setDistortion_model(DomainVision::ImageDistortionModel::BROWN_CONRADY);

	    }else if(color_intrinsics.model==RS2_DISTORTION_MODIFIED_BROWN_CONRADY)
	    {
	    	comm_rgb_frame.setDistortion_model(DomainVision::ImageDistortionModel::MODIFIED_BROWN_CONRADY);

	    }else if(color_intrinsics.model==RS2_DISTORTION_INVERSE_BROWN_CONRADY)
	    {
	    	comm_rgb_frame.setDistortion_model(DomainVision::ImageDistortionModel::INVERSE_BROWN_CONRADY);

	    }
	    else{
	    	comm_rgb_frame.setDistortion_model(DomainVision::ImageDistortionModel::NONE);

	    }


	    arma::mat comm_color_distortion = arma::zeros(1,5);

	    comm_color_distortion(0,0) = color_intrinsics.coeffs[0];
	    comm_color_distortion(0,1) = color_intrinsics.coeffs[1];
	    comm_color_distortion(0,2) = color_intrinsics.coeffs[2];
	    comm_color_distortion(0,3) = color_intrinsics.coeffs[3];
	    comm_color_distortion(0,4) = color_intrinsics.coeffs[4];

	    comm_rgb_frame.set_distortion(comm_color_distortion);

}

void RealSenSeWrapper::getdepthimage(DomainVision::CommDepthImage& comm_depth_frame)
{

	rs2::depth_frame current_depth_frame = current_frameset.get_depth_frame();


	/*Post processing*/
	if(is_postprocess_enabled)
	post_processing(current_depth_frame);


	/*Read Current Frames*/
	const uint16_t* depth_frame = (const uint16_t*) current_depth_frame.get_data();
	//assert(rs_error_ != nullptr  && "error while reading depth stream");


	// BaseLine
	rs2::disparity_transform disparity_transform( true );
	rs2::disparity_frame disparity_frame = disparity_transform.process( current_depth_frame );
	float baseline = disparity_frame.get_baseline(); // mm
//	std:: cout << "baseline = " << baseline <<std::endl;



	auto depth_frame_timestamp= current_depth_frame.get_timestamp();
	auto depth_frame_number= current_depth_frame.get_frame_number();

	int frame_height = current_depth_frame.get_height();
	int frame_width  = current_depth_frame.get_width();



	//std:: cout << "dw = " << depth_intrinsics.width <<  "   dH = " << depth_intrinsics.height <<std::endl;
	//std:: cout << "dframe w = " << current_depth_frame.get_width() <<  " dframe   H = " << current_depth_frame.get_height() <<std::endl;
	//std:: cout << "d_frame_timestamp = " << depth_frame_timestamp <<  "   d_frame_number = " << depth_frame_number <<std::endl;
	//std::cout << "IDB =" <<calulate_invalid_depth_band()<<std::endl;

	comm_depth_frame.setWidth(depth_intrinsics.width);
	comm_depth_frame.setHeight(depth_intrinsics.height);

	//std::cout << "depth height =" << comm_depth_frame.getHeight()<<"depth width  =" << comm_depth_frame.getWidth()<<std::endl;

	comm_depth_frame.setFormat(DomainVision::DepthFormatType::UINT16);
	comm_depth_frame.setPixel_size(16);
	comm_depth_frame.setSeq_count(depth_frame_number);

	if(depth_intrinsics.model==RS2_DISTORTION_BROWN_CONRADY)
	{
		comm_depth_frame.setDistortion_model(DomainVision::ImageDistortionModel::BROWN_CONRADY);

	}else if(depth_intrinsics.model==RS2_DISTORTION_MODIFIED_BROWN_CONRADY)
	{
		comm_depth_frame.setDistortion_model(DomainVision::ImageDistortionModel::MODIFIED_BROWN_CONRADY);

	}else if(depth_intrinsics.model==RS2_DISTORTION_INVERSE_BROWN_CONRADY)
	{
		comm_depth_frame.setDistortion_model(DomainVision::ImageDistortionModel::INVERSE_BROWN_CONRADY);

	}
	else{
		comm_depth_frame.setDistortion_model(DomainVision::ImageDistortionModel::NONE);

	}


	// find min and max distances from depth image
	int dw  = 0;
	int dh  = 0;
	int dwh = 0;
	float dp_min=20000;
	float dp_max=0.0;

	dw = frame_width;//depth_intrinsics.width;
	dh = frame_height;//depth_intrinsics.height;

	dwh = dw * dh;
	// Iterate the data space
	// First, iterate across columns
	for( int dy = 0; dy < dh; dy++ )
	{

		// Second, iterate across rows
		for( int dx = 0; dx < dw; dx++ )
		{
			uint i = dy * dw + dx;
			uint16_t depth_value = static_cast<uint16_t>(depth_frame[ i ]);
			uint16_t depth_in_meters = depth_value;//*scale;
			if(depth_in_meters>dp_max)
				dp_max=depth_in_meters;
			if(depth_in_meters<dp_min)
				dp_min=depth_in_meters;

		}
	}

	comm_depth_frame.set_distances(depth_frame, frame_width, frame_height);


	comm_depth_frame.setMax_distcance(dp_max);
	comm_depth_frame.setMin_distcance(dp_min);

	arma::mat comm_depth_distortion = arma::zeros(1,5);

	comm_depth_distortion(0,0) = depth_intrinsics.coeffs[0];
	comm_depth_distortion(0,1) = depth_intrinsics.coeffs[1];
	comm_depth_distortion(0,2) = depth_intrinsics.coeffs[2];
	comm_depth_distortion(0,3) = depth_intrinsics.coeffs[3];
	comm_depth_distortion(0,4) = depth_intrinsics.coeffs[4];

	comm_depth_frame.set_distortion(comm_depth_distortion);

	arma::mat comm_depth_intrinsic = arma::zeros(4,4);

	comm_depth_intrinsic(0,0) = depth_intrinsics.fx;
	comm_depth_intrinsic(1,1) = depth_intrinsics.fy;

	comm_depth_intrinsic(0,2) = depth_intrinsics.ppx;
	comm_depth_intrinsic(1,2) = depth_intrinsics.ppy;

	comm_depth_intrinsic(2,2) = 1;

	comm_depth_frame.set_intrinsic(comm_depth_intrinsic);



	arma::mat comm_depth_extrinsics = arma::zeros(1,12);

	comm_depth_extrinsics(0,0) = d2c_extrinsics.rotation[0];
	comm_depth_extrinsics(0,1) = d2c_extrinsics.rotation[1];
	comm_depth_extrinsics(0,2) = d2c_extrinsics.rotation[2];
	comm_depth_extrinsics(0,3) = d2c_extrinsics.rotation[3];
	comm_depth_extrinsics(0,4) = d2c_extrinsics.rotation[4];
	comm_depth_extrinsics(0,5) = d2c_extrinsics.rotation[5];
	comm_depth_extrinsics(0,6) = d2c_extrinsics.rotation[6];
	comm_depth_extrinsics(0,7) = d2c_extrinsics.rotation[7];
	comm_depth_extrinsics(0,8) = d2c_extrinsics.rotation[8];

	comm_depth_extrinsics(0,9) = d2c_extrinsics.translation[0];
	comm_depth_extrinsics(0,10) = d2c_extrinsics.translation[1];
	comm_depth_extrinsics(0,11) = d2c_extrinsics.translation[2];


	comm_depth_frame.set_extrinsic(comm_depth_extrinsics);
	comm_depth_frame.setIs_valid(true);

}



void RealSenSeWrapper::getImage(DomainVision::CommRGBDImage& image)
{
	DomainVision::CommDepthImage comm_depth_frame;
	DomainVision::CommVideoImage comm_rgb_frame;

	/*Read Current Frames*/
	try
	{
		current_frameset = pipeline.wait_for_frames();
		//fill rgb image information
		getrgbimage(comm_rgb_frame);
		//fill depth image information
		getdepthimage(comm_depth_frame);
		//fill rgbd image with rgb, depth
		image.setColor_image(comm_rgb_frame);
		image.setDepth_image(comm_depth_frame);
		image.setSeq_count(comm_rgb_frame.getSeq_count());
		image.setIs_valid(true);
	}catch (std::exception &e) {
		std::cerr << "[RealSenSeWrapper] Error in wait_for_frames :" << e.what() << "\n";
		image.setIs_valid(false);
	}
}
bool RealSenSeWrapper::init_Camera()
{
		rs2_device_ = nullptr;

		device_list = rs2_context_.query_devices();

		if (0 == device_list.size())
		{

			std::cout <<"No device detected. Is it plugged in?"<<std::endl;
			return false;
		}
		else{

			int found_device = -1;

			std::cout<<" ---------------------------------------- "<<std::endl;
			std::cout<<__FUNCTION__<<" found devices: "<<std::endl;
			for(unsigned int i=0;i<device_list.size();i++){
				std::cout<<" -------------------"<<std::endl;
				std::cout<<" Name : "<<device_list[i].get_info(RS2_CAMERA_INFO_NAME)<<std::endl;
				std::cout<<" Device Serial : "<<device_list[i].get_info(RS2_CAMERA_INFO_SERIAL_NUMBER)<<std::endl;
				std::cout<<" Given Serial : "<<device_serial_number_<<std::endl;
				std::stringstream ss_serial;
				ss_serial<< device_list[i].get_info(RS2_CAMERA_INFO_SERIAL_NUMBER);
				if(!device_serial_number_.compare(ss_serial.str())){
					std::cout<<" Found matching serial number."<<std::endl;
					found_device = i;
				}
			}
			std::cout<<" ---------------------------------------- "<<std::endl;


			if(found_device != -1){
				rs2_device_ = device_list[found_device];
				assert(rs2_device_ && "Not able to connect to device");
				return true;
			} else {
				if(device_list.size() == 1){
					std::cout<<"Not able to find the correct device (serial number)."<<std::endl;
					std::cout<<"Only one device found connect to this!"<<std::endl;
					rs2_device_ = device_list[0];
					assert(rs2_device_ && "Not able to connect to device");
					return true;
				} else {
					std::cout<<"Not able to find the correct device (serial number)"<<std::endl;
					return false;
				}
			}

		}

}

void RealSenSeWrapper::display_intrinsics_extrinsics()
{

	std::cout<<TEXT_COLOR_RESET<< TEXT_COLOR_GREEN; // make the screen output Green
	std::cout <<std::setw(40)<<"Colour Intrinsics"<<std::setw(20)<<"Depth Intrinsics"<<std::endl;
	std::cout << "-----------------------------------------------------------------------------------------" <<std::endl;
	std::cout <<std::setw(20)<<  "Cx"<<std::setw(20)<< color_intrinsics.ppx<<std::setw(20)<<  depth_intrinsics.ppx<<std::endl;
	std::cout <<std::setw(20)<<  "Cy"<<std::setw(20)<< color_intrinsics.ppy<<std::setw(20)<<  depth_intrinsics.ppy<<std::endl;
	std::cout <<std::setw(20)<<  "Fx"<<std::setw(20)<< color_intrinsics.fx<<std::setw(20)<<  depth_intrinsics.fx<<std::endl;
	std::cout <<std::setw(20)<<  "Fy"<<std::setw(20)<< color_intrinsics.fy<<std::setw(20)<<  depth_intrinsics.fy<<std::endl;


	std::stringstream rgb_size, depth_size;
	rgb_size << color_intrinsics.width<<" x "<<  color_intrinsics.height;
	depth_size << depth_intrinsics.width<<" x "<<  depth_intrinsics.height;

	std::cout <<std::setw(20)<<"Size"<<std::setw(20)<< rgb_size.str()<<std::setw(20)<<depth_size.str()<<std::endl;

	std::cout <<std::setw(20)<<  "Distortion model"<<std::setw(20) <<rs2_distortion_to_string(color_intrinsics.model)
		        		                           << std::setw(20)<<rs2_distortion_to_string(depth_intrinsics.model)<<std::endl;
	std::cout <<std::setw(20)<<  "Distortion coeffs"<<std::setw(20)<<color_intrinsics.coeffs[0] <<std::setw(20)<<depth_intrinsics.coeffs[0]<<std::endl;
	std::cout <<std::setw(40)<<color_intrinsics.coeffs[1] <<std::setw(20)<<depth_intrinsics.coeffs[1]<<std::endl;
	std::cout <<std::setw(40)<<color_intrinsics.coeffs[2] <<std::setw(20)<<depth_intrinsics.coeffs[2]<<std::endl;
	std::cout <<std::setw(40)<<color_intrinsics.coeffs[3] <<std::setw(20)<<depth_intrinsics.coeffs[3]<<std::endl;
	std::cout <<std::setw(40)<<color_intrinsics.coeffs[4] <<std::setw(20)<<depth_intrinsics.coeffs[4]<<std::endl;
	std::cout << "-----------------------------------------------------------------------------------------" <<std::endl;
	std::cout <<"Depth to Colour Extrinsics"<<std::endl;
	std::cout << "-----------------------------------------------------------------------------------------" <<std::endl;

	std::cout <<std::setw(20)<<  "Rotation"<<" = "
			<<std::setw( 2)<< "[ "<<std::setw(13)<<d2c_extrinsics.rotation[0] <<std::setw(15)<< d2c_extrinsics.rotation[3]<<std::setw(15)<< d2c_extrinsics.rotation[6]<<" ]"<<std::endl
			<<std::setw(25)<< "[ "<<std::setw(13)<<d2c_extrinsics.rotation[1] <<std::setw(15)<< d2c_extrinsics.rotation[4]<<std::setw(15)<< d2c_extrinsics.rotation[7]<<" ]"<<std::endl
			<<std::setw(25)<< "[ "<<std::setw(13)<<d2c_extrinsics.rotation[2] <<std::setw(15)<< d2c_extrinsics.rotation[5]<<std::setw(15)<< d2c_extrinsics.rotation[8]<<" ]"<<std::endl;

	std::cout <<std::endl;
	std::cout <<std::setw(20)<< "Translation"<<" = "<<"[ "<<std::setw(13) << d2c_extrinsics.translation[0] <<std::setw(15) << d2c_extrinsics.translation[1]<<std::setw(15) << d2c_extrinsics.translation[2]<<" ]"<<std::endl;
	std::cout <<std::endl;
	std::cout << "-----------------------------------------------------------------------------------------" <<std::endl;
	std::cout<< TEXT_COLOR_RESET; // make the screen output normal


}

void RealSenSeWrapper::set_baseline(float in_baseline)
{
	baseline = in_baseline;
}

float RealSenSeWrapper::get_baseline()
{
	return baseline;
}

float RealSenSeWrapper::get_hfov_rad()
{
	return (std::atan2(depth_intrinsics.ppx + 0.5f, depth_intrinsics.fx) + std::atan2(depth_intrinsics.width - (depth_intrinsics.ppx + 0.5f), depth_intrinsics.fx));
}
float RealSenSeWrapper::get_vfov_rad()
{
	return (std::atan2(depth_intrinsics.ppy + 0.5f, depth_intrinsics.fy) + std::atan2(depth_intrinsics.height - (depth_intrinsics.ppy + 0.5f), depth_intrinsics.fy));
}

/*
 * Returns the number of columns in invalid depth band. Don't use these columns
 * Realsense uses left imager as reference, non overlapping region on left side of depth image must be ignored.
 */
float RealSenSeWrapper::calulate_invalid_depth_band()
{
	//pages 55-56 from Intel-RealSense-D400-Series-Datasheet.pdf
	//DBR (ratio of Invalid depth band to total horizontal image) = B/[2*Z*tan(HFOV/2)];
	//Invalid Depth Band (in pixels) = HRes*DBR
	//B= baseline
	//Z= distance
	//HFOV= horizontal depth FOV

	float Z = 1000; //mm
	float HFOV = get_hfov_rad();// rad
	float DBR = baseline/(2.0*Z*tan(HFOV/2.0));
	float invalid_depth_band = DBR* depth_intrinsics.width;
	return std::ceil(invalid_depth_band);
}
/*
 * Apply post processing on depthframe
 * based on realsense example:  https://github.com/IntelRealSense/librealsense/blob/master/examples/post-processing/rs-post-processing.cpp
 *
 * */
void RealSenSeWrapper::post_processing(rs2::depth_frame& input_depth_frame)
{
	//Declare filters
	rs2::decimation_filter dec_filter;  // Decimation - reduces depth frame density
	rs2::spatial_filter spat_filter;    // Spatial    - edge-preserving spatial smoothing
	rs2::temporal_filter temp_filter;   // Temporal   - reduces temporal noise


	//Declare disparity transform from depth to disparity and vice versa
	const std::string disparity_filter_name = "Disparity";
	rs2::disparity_transform disparity_to_depth(false);

    dec_filter.process(input_depth_frame);
    spat_filter.process(input_depth_frame);
    temp_filter.process(input_depth_frame);
    disparity_to_depth.process(input_depth_frame);

}

void RealSenSeWrapper::set_is_postprocess_enabled(bool value)
{
	is_postprocess_enabled = value;
}


