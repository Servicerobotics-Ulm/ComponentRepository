//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2011, 2017 Matthias Lutz, Dennis Stampfer, Matthias Rollenhagen, Nayabrasul Shaik
//
//      lutz@hs-ulm.de
//      stampfer@hs-ulm.de
//      rollenhagen@hs-ulm.de
//      shaik@hs-ulm.de
//
//      ZAFH Servicerobotic Ulm
//      Christian Schlegel
//      University of Applied Sciences
//      Prittwitzstr. 10
//      89075 Ulm
//      Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "ImageTask.hh"
#include "ComponentRealSenseV2Server.hh"
#include "EulerTransformationMatrices.hh"

#include <sstream>
#include <iostream>
#include <iomanip>
#include <thread>
#include <algorithm>
#include <map>
#include <memory>
#include <vector>
#include <iostream>

ImageTask::ImageTask(SmartACE::SmartComponent *comp) 
:	ImageTaskCore(comp)
{
	std::cout << "constructor ImageTask\n";
	_ring_buffer_index = 0;
}
ImageTask::~ImageTask() 
{
	std::cout << "destructor ImageTask\n";
	COMP->imageTask->close();

	for (unsigned int i = 0; i < _ring_buffer.size() - 2; i++) {
		delete _ring_buffer[i];
	}
	_ring_buffer.clear();
}

void ImageTask::startCapturing() {
	SmartACE::SmartGuard(COMP->RealSenseMutex);
	if (COMP->smart_rs_device != NULL) {
		COMP->smart_rs_device->startVideo();

	} else {
		std::cout << "[Image Task] ERROR: startCapturing() but smart_rs_device is NULL)" << std::endl;
	}
	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Start capturing\n";
	}
}

void ImageTask::stopCapturing() {
	SmartACE::SmartGuard guard(COMP->RealSenseMutex);
	if (COMP->smart_rs_device != NULL) {
			COMP->smart_rs_device->stopVideo();
	}

	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Stop capturing\n";
	}
}



int ImageTask::on_entry()
{

	ParameterStateStruct global_state = COMP->getGlobalState();

	// Calculate size of the ring_buffer
	int size = (int) (global_state.getSettings().getValid_image_time() + 1);

	_ring_buffer.resize(size);

	if (global_state.getSettings().getDebug_info()) {
		std::cout << "[Image Task] Newest: Size of Ring Buffer " << size << std::endl;
	}

	// Fill ring_buffer with empty images
	for (unsigned int i = 0; i < _ring_buffer.size(); i++) {
		_ring_buffer[i] = new DomainVision::CommRGBDImage;
	}

	//only supply these services based on parameters
	push_newest_rgbd  = global_state.getSettings().getPushnewest_rgbd_image();
	push_newest_rgb   = global_state.getSettings().getPushnewest_color_image();
	push_newest_depth = global_state.getSettings().getPushnewest_depth_image();


	//read user specified image parameters for RGB, Depth
	int color_width     = global_state.getRGB_config().getWidth();
	int color_height    = global_state.getRGB_config().getHeight();
	int color_framerate = global_state.getRGB_config().getFramerate();

	int depth_width     = global_state.getDepth_config().getWidth();
	int depth_height    = global_state.getDepth_config().getHeight();
	int depth_framerate = global_state.getDepth_config().getFramerate();

	float base_line = global_state.getStereo().getBaseline();
	std::string device_serial_number = global_state.getSettings().getDevice_serial_number();


//	COMP->smart_rs_device = new RealSenSeWrapper(color_width, color_height, color_framerate,
//	                                             depth_width, depth_height, depth_framerate);
	SmartACE::SmartGuard guard(COMP->RealSenseMutex);
	COMP->smart_rs_device = new RealSenSeWrapper(color_width, color_height, color_framerate,
				                                 depth_width, depth_height, depth_framerate,
				                                 device_serial_number, base_line);

	COMP->smart_rs_device->set_is_postprocess_enabled(global_state.getSettings().getPost_processing());

	return 0;
}
int ImageTask::on_execute()
{
	CommBasicObjects::CommBasePose default_base_position;
		default_base_position.set_x(COMP->getGlobalState().getBase().getX());
		default_base_position.set_y(COMP->getGlobalState().getBase().getY());
		default_base_position.set_z(COMP->getGlobalState().getBase().getZ());

		// TODO: Check
		//default_base_position.set_base_alpha(COMP->ini.base.base_a);
		default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());

		//default_base_position.set_steer_alpha(COMP->getGlobalState().getBase().getSteer_a());
		//default_base_position.set_turret_alpha(COMP->ini.base.turret_a);

		CommBasicObjects::CommBaseVelocity zero_velocity;
		zero_velocity.set_vX(0);
		zero_velocity.set_vY(0);
		zero_velocity.set_vZ(0);

	//	zero_velocity.set_omega_base(0);
	//	zero_velocity.set_omega_steer(0);
	//	zero_velocity.set_omega_turret(0);

		zero_velocity.set_WX_base(0);
		zero_velocity.set_WY_base(0);
		zero_velocity.set_WZ_base(0);

		DomainVision::CommRGBDImage* image = NULL;

		try{
			Smart::StatusCode statusCode;
			statusCode = COMP->stateSlave->acquire("pushimage");
			if(statusCode == Smart::SMART_OK)
			{

				image = _ring_buffer[_ring_buffer_index];

				// get newest image from RealSense
				SmartACE::SmartGuard guard(COMP->RealSenseMutex);
				COMP->smart_rs_device->getImage(*image);
				guard.release();

				arma::mat sensorMat;
				EulerTransformationMatrices::create_zyx_matrix(COMP->getGlobalState().getSensor_pose().getX(), COMP->getGlobalState().getSensor_pose().getY(),
						COMP->getGlobalState().getSensor_pose().getZ(), COMP->getGlobalState().getSensor_pose().getAzimuth(), COMP->getGlobalState().getSensor_pose().getElevation(),
						COMP->getGlobalState().getSensor_pose().getRoll(), sensorMat);

				// set base state
				CommBasicObjects::CommBaseState base_state;

				if (COMP->getGlobalState().getBase().getOn_ptu()) {
					CommBasicObjects::CommDevicePoseState devicePoseState;
					Smart::StatusCode status = COMP->ptuPosePushNewestClient->getUpdate(devicePoseState);

					base_state = devicePoseState.get_base_state();
					CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
					arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

					sensorMat = ptuMat * sensorMat;

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current ptu device state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
						image->setIs_valid(false);
					}
				}else if (COMP->getGlobalState().getBase().getOn_ur()) {

					CommBasicObjects::CommVoid v;
					CommManipulatorObjects::CommMobileManipulatorState mobileManipulatorState;

					Smart::StatusCode status = COMP->urPosePushTimedClient->getUpdate(mobileManipulatorState);

					CommManipulatorObjects::CommManipulatorState manipulatorState = mobileManipulatorState.getManipulator_state();
					double x,y,z,azimuth, elevation, roll;
					manipulatorState.get_pose_TCP_robot(x, y, z, azimuth, elevation, roll, 0.001);
					CommBasicObjects::CommPose3d tcpPose(x, y, z, azimuth, elevation, roll, 0.001);
					arma::mat tcpMat = tcpPose.getHomogeneousMatrix();
					sensorMat = tcpMat * sensorMat;

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current UR device state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
						image->setIs_valid(false);
					}
				}

				// read base state from base server
				if (COMP->getGlobalState().getBase().getOn_base()) {
					Smart::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current base state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
						image->setIs_valid(false);
					}
				}
				// default base state
				else {
					base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
					base_state.set_base_position(default_base_position);
					base_state.set_base_velocity(zero_velocity);
				}

				CommBasicObjects::CommPose3d sensorPose(sensorMat);
				image->setSensor_pose(sensorPose);
				image->setBase_state(base_state);

				// Save the newest image into the global pointer
				COMP->NewestImageMutex.acquire();
				COMP->newestImage = image;
				COMP->NewestImageMutex.release();

				// push newest RGBD image
				if (push_newest_rgbd) {
					COMP->rGBDImagePushServiceOut->put(*image);
				}
				// push newest color image
				if (push_newest_rgb) {
					DomainVision::CommVideoImage colorImage = image->getColor_image();
					colorImage.set_sensor_pose(sensorPose);
					colorImage.set_base_state(base_state);
					COMP->rGBImagePushServiceOut->put(colorImage);
				}
				// push newest depth image
				if (push_newest_depth) {
					DomainVision::CommDepthImage depthImage = image->getDepth_image();
					COMP->depthPushNewestServer->put(depthImage);
				}


				if (COMP->getGlobalState().getSettings().getDebug_info()) {
					std::cout << "[Image Task] Current RGBD frame number ="<< image->getSeq_count() << " is " << (image->getIs_valid() ? "valid" : "invalid") << "\n";
				}

				// calculate new index in the ring_buffer
				_ring_buffer_index++;
				if (_ring_buffer_index == _ring_buffer.size())
					_ring_buffer_index = 0;

				guard.release();
				COMP->stateSlave->release("pushimage");

			}//			if(COMP->stateServer->acquire("active") == CHS::SMART_OK)

		}

		catch (std::exception e) {
			std::cerr << "[Image Task] Error in ImageTask::svc() " << e.what() << "\n";
		} catch (...) {
			std::cerr << "[Image Task] Unknown error in ImageTask::svc()\n";
		}

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int ImageTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
