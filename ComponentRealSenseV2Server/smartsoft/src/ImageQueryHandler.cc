//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2011, 2017 Matthias Lutz, Dennis Stampfer, Matthias Rollenhagen, Nayabrasul Shaik
//
//      lutz@hs-ulm.de
//      stampfer@hs-ulm.de
//      rollenhagen@hs-ulm.de
//      shaik@hs-ulm.de
//
//      ZAFH Servicerobotic Ulm
//      Christian Schlegel
//      University of Applied Sciences
//      Prittwitzstr. 10
//      89075 Ulm
//      Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "ImageQueryHandler.hh"
#include "ComponentRealSenseV2Server.hh"
#include "EulerTransformationMatrices.hh"
ImageQueryHandler::ImageQueryHandler(Smart::IQueryServerPattern<CommBasicObjects::CommVoid, DomainVision::CommRGBDImage>* server)
:	ImageQueryHandlerCore(server)
{
	
}

ImageQueryHandler::~ImageQueryHandler()
{
	
}


void ImageQueryHandler::handleQuery(const Smart::QueryIdPtr &id, const CommBasicObjects::CommVoid& request)
{
	std::cout<<"Query Request received.."<<std::endl;

	Smart::StatusCode status;
		DomainVision::CommRGBDImage answer;
		//(COMP->ini.hardware_properties.width,COMP->ini.hardware_properties.height);
		answer.setIs_valid(false);

		///////////////////
		// Component Active then get new image
			status = COMP->stateSlave->tryAcquire("nonneutral");
			if(status == Smart::SMART_OK)
			{

				// If Newest and Timed active get image from global Reference otherwise get it directly from Unicap
				if (COMP->stateSlave->tryAcquire("pushimage")==Smart::SMART_OK)
				{
					if (COMP->getGlobalState().getSettings().getDebug_info()) {
									std::cout << "Push image mode"<<std::endl;
					}

						COMP->NewestImageMutex.acquire();
						if(COMP->newestImage != NULL){
							answer = *(COMP->newestImage);
						}
						COMP->NewestImageMutex.release();

					COMP->stateSlave->release("pushimage");
				}
				else
				{

					if (COMP->getGlobalState().getSettings().getDebug_info()) {
							std::cout << "Query only mode"<<std::endl;
					}

					//////////////////////

					//////////////////////
					CommBasicObjects::CommBasePose default_base_position;
					default_base_position.set_x(COMP->getGlobalState().getBase().getX());
					default_base_position.set_y(COMP->getGlobalState().getBase().getY());
					default_base_position.set_z(COMP->getGlobalState().getBase().getZ());

					// TODO: Check
					//default_base_position.set_base_alpha(COMP->ini.base.base_a);
					default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());

					//default_base_position.set_steer_alpha(COMP->getGlobalState().getBase().getSteer_a());
					//default_base_position.set_turret_alpha(COMP->ini.base.turret_a);

					CommBasicObjects::CommBaseVelocity zero_velocity;
					zero_velocity.set_vX(0);
					zero_velocity.set_vY(0);
					zero_velocity.set_vZ(0);

		//			zero_velocity.set_omega_base(0);
		//			zero_velocity.set_omega_steer(0);
		//			zero_velocity.set_omega_turret(0);

					zero_velocity.set_WX_base(0);
					zero_velocity.set_WY_base(0);
					zero_velocity.set_WZ_base(0);

					{
					// get newest image from RealSense
					SmartACE::SmartGuard guard(COMP->RealSenseMutex);
					COMP->smart_rs_device->getImage(answer);
					guard.release();
					}
	//TODO
					//answer.set_min_distance(COMP->getGlobalState().getHardware_properties().getMin_distance());
					//answer.set_max_distance(COMP->getGlobalState().getHardware_properties().getMax_distance());

					arma::mat sensorMat;
					EulerTransformationMatrices::create_zyx_matrix(COMP->getGlobalState().getSensor_pose().getX(), COMP->getGlobalState().getSensor_pose().getY(),
							COMP->getGlobalState().getSensor_pose().getZ(), COMP->getGlobalState().getSensor_pose().getAzimuth(), COMP->getGlobalState().getSensor_pose().getElevation(),
							COMP->getGlobalState().getSensor_pose().getRoll(), sensorMat);

					// set base state
					CommBasicObjects::CommBaseState base_state;
					//std::cout<<__FILE__<<__LINE__<<std::endl;

					//////////////
					if (COMP->getGlobalState().getBase().getOn_ptu()) {
						CommBasicObjects::CommDevicePoseState devicePoseState;
						Smart::StatusCode status = COMP->ptuPosePushNewestClient->getUpdate(devicePoseState);

						std::cout << "Base : " << devicePoseState.get_base_state() << std::endl;
						std::cout << "PTU (robot): " << devicePoseState.get_device_pose3d_robot() << std::endl;
						std::cout << "PTU (world): " << devicePoseState.get_device_pose3d_world() << std::endl;

						std::cout << "Sensor Mat (before): " << sensorMat << std::endl;

						base_state = devicePoseState.get_base_state();
						CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
						arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

						sensorMat = ptuMat * sensorMat;

						std::cout << "Sensor Mat (after): " << sensorMat << std::endl;

						if (status != Smart::SMART_OK) {
							std::cerr << "[Image Task] WARNING: failed to get current ptu device state ("
							<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
							answer.setIs_valid(false);
						}
					}
					std::cout << "[Image Query Handler] 1" << std::endl;

					if (COMP->getGlobalState().getBase().getOn_ur()) {
						std::cout << "[Image Query Handler] 2" << std::endl;

						CommBasicObjects::CommVoid v;
						CommManipulatorObjects::CommMobileManipulatorState mobileManipulatorState;
						std::cout << "[Image Query Handler] 3" << std::endl;

						Smart::StatusCode status = COMP->urPosePushTimedClient->getUpdate(mobileManipulatorState);
						if(status != Smart::SMART_OK){
						//TODO

						}
						std::cout << "[Image Query Handler] 4 status: "<< Smart::StatusCodeConversion(status) << std::endl;

						CommManipulatorObjects::CommManipulatorState manipulatorState = mobileManipulatorState.getManipulator_state();
						double x,y,z,azimuth, elevation, roll;
						manipulatorState.get_pose_TCP_robot(x, y, z, azimuth, elevation, roll, 0.001);
						CommBasicObjects::CommPose3d tcpPose(x, y, z, azimuth, elevation, roll, 0.001);
						arma::mat tcpMat = tcpPose.getHomogeneousMatrix();
	//					std::cout << "[Image Query Handler] Sensor on Manipulator. TCP Pose: \n"<< tcpPose << std::endl;
	//					std::cout << "[Image Query Handler] Sensor on Manipulator. TCP Mat: \n"<< tcpMat << std::endl;
						std::cout << "[Image Query Handler] Sensor on Manipulator. sensor Mat before: \n"<< sensorMat << std::endl;
						sensorMat = tcpMat * sensorMat;
						std::cout << "[Image Query Handler] Sensor on Manipulator. sensor Mat after: \n"<< sensorMat << std::endl;

						if (status != Smart::SMART_OK) {
							std::cerr << "[Image Task] WARNING: failed to get current manipulator device state ("
							<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
							answer.setIs_valid(false);
						}
					}
					//////////////


					//std::cout<<__FILE__<<__LINE__<<std::endl;
					// read base state from base server
					if (COMP->getGlobalState().getBase().getOn_base()) {
						Smart::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

						if (status != Smart::SMART_OK) {
							std::cerr << "[Image Task] WARNING: failed to get current base state ("
							<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
							answer.setIs_valid(false);
						}
					}
					// default base state
					else {
						base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
						base_state.set_base_position(default_base_position);
						base_state.set_base_velocity(zero_velocity);
					}
					CommBasicObjects::CommPose3d sensorPose(sensorMat);
					answer.setSensor_pose(sensorPose);
					answer.setBase_state(base_state);


					///////////////////////
				}
				COMP->stateSlave->release("nonneutral");
			}
			else
			{
				answer.setIs_valid(false);
				if (COMP->getGlobalState().getSettings().getDebug_info()) {
						std::cout << "Query: StatusCode: "<<Smart::StatusCodeConversion(status)<<std::endl;
						std::cout << "Query: Set Data invalid!"<< std::endl;

				}

			}

			server->answer(id, answer);
			if (COMP->getGlobalState().getSettings().getDebug_info()) {
				std::cout << "Query: Answer sent: "<<answer.getIs_valid()<<" with ID: " << id << std::endl;
			}



		//////////////////
}
