//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2021 Timo Blender
//
//        timo.blender@thu.de
//        christian.schlegel@thu.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  Contributors:
//		Vineet Nagrath
//		Nayabrasul Shaik
//		Timo Blender
//		Christian Schlegel
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "CommandActivity.hh"
#include "ComponentAASBridge.hh"

#include "CommBasicObjects/CommTaskEventState.hh"
#include "CommBasicObjects/CommTaskMessage.hh"

#include <iostream>
#include <vector>
#include <stdlib.h>

CommandActivity::CommandActivity(SmartACE::SmartComponent *comp) 
:	CommandActivityCore(comp)
{
	std::cout << "constructor CommandActivity\n";
}
CommandActivity::~CommandActivity() 
{
	std::cout << "destructor CommandActivity\n";
}

int CommandActivity::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	this->sc.connect();
	return 0;
}

int CommandActivity::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;

	std::string message;

	this->sc.receive(message);

	if (!message.empty()) {

		std::cout << "Message received: " << message << std::endl;

		std::string delimiter1 = "-|-";

		long id;

		std::cout << "ID(LONG): " << std::strtol(message.substr(0, message.find(delimiter1)).c_str(), NULL, 0) << std::endl;

		id = std::strtol(message.substr(0, message.find(delimiter1)).c_str(), NULL, 0);
		message.erase(0, message.find(delimiter1) + delimiter1.length());

		std::string operationType = message.substr(0, message.find(delimiter1));
		message.erase(0, message.find(delimiter1) + delimiter1.length());

		if (operationType == "PushCapability") {

			std::string delimiter2 = "_||_";

			std::string name = message.substr(0, message.find(delimiter2));
			message.erase(0, message.find(delimiter2) + delimiter2.length());

			std::vector<std::string> params;

			while (true) {
				if (message.find(delimiter2) != std::string::npos) {
					params.push_back(message.substr(0, message.find(delimiter2)));
					message.erase(0, message.find(delimiter2) + delimiter2.length());
				}
				else {
					// Last param
					params.push_back(message);
					break;
				}
			}

			std::string paramsString;

			for (int i = 0; i < params.size(); i++) {
				paramsString += params[i];
				if (i < params.size()-1) {
					paramsString += " ";
				}
			}

			std::string taskCommand = name+" "+paramsString;

			std::string begin = "(tcl-push-back-plan :plan `((";
			std::string end = ")))";
			std::string tclCommand = begin+taskCommand+end;

			std::cout << "tclCommand: " << tclCommand << std::endl;

			SmartACE::SmartGuard guard(COMP->mutex);

			COMP->TASK_QUEUE.push_back(id);
			COMP->TASK_COMMAND.insert(std::make_pair(id, tclCommand));

			if (COMP->TASK_QUEUE.size() == 1) {

				COMP->CURRENT_TASK_ID = id;
				COMP->TASK_STATE.insert(std::make_pair(id, COMP->EXECUTING));

				CommBasicObjects::CommTaskMessage msg;
				msg.setMsg(tclCommand);
				CommBasicObjects::CommTaskEventState state;
				state.setJob(msg);
				COMP->taskEventOut->put(state);
			}
			else {
				COMP->TASK_STATE.insert(std::make_pair(id, COMP->PENDING));
			}

			guard.release();
		}

		else if (operationType == "DeleteCapability") {

			std::string taskId = message.substr(0, message.find(delimiter1));
			long taskIdL = std::strtol(taskId.c_str(), NULL, 0);
			std::cout << "taskIdL: " << taskIdL << std::endl;

			SmartACE::SmartGuard guard(COMP->mutex);

			if (COMP->TASK_STATE[taskIdL] == COMP->PENDING) {

				int pos = -1;
				for (int i = 0; i < COMP->TASK_QUEUE.size(); i++) {
					if (COMP->TASK_QUEUE[i] == taskIdL) {
						pos = i;
						break;
					}
				}

				COMP->TASK_QUEUE.erase(COMP->TASK_QUEUE.begin()+pos);
				COMP->TASK_STATE[taskIdL] = COMP->DELETED;
			}
			else if (COMP->TASK_STATE[taskIdL] == COMP->EXECUTING) {
				// TODO: Aborting running task? ... this is not so easy ...
			}

			guard.release();
		}

		else if (operationType == "GetStatusCapability") {

			std::string statusMsg = "";

			SmartACE::SmartGuard guard(COMP->mutex);

			std::string taskId = message.substr(0, message.find(delimiter1));
			long taskIdL = std::strtol(taskId.c_str(), NULL, 0);

			std::cout << "ID is: " << id << std::endl;
			std::cout << "taskId is: " << taskId << std::endl;
			std::cout << "taskIdL is:" << taskIdL << std::endl;
			std::cout << "COMP->TASK_STATE.count("+std::to_string(taskIdL)+"): " << COMP->TASK_STATE.count(taskIdL) << std::endl;

			for (auto const& x : COMP->TASK_STATE)
			{
				std::cout << x.first
						  << ':'
						  << x.second
						  << std::endl;
			}

			std::string status = "";

			if (COMP->TASK_STATE.find(taskIdL) != COMP->TASK_STATE.end()) {

				if (COMP->TASK_STATE[taskIdL] == COMP->PENDING) {
					status = "PENDING";
				}
				else if (COMP->TASK_STATE[taskIdL] == COMP->EXECUTING) {
					status = "EXECUTING";
				}
				else if (COMP->TASK_STATE[taskIdL] == COMP->SUCCESS) {
					status = "SUCCESS";
				}
				else if (COMP->TASK_STATE[taskIdL] == COMP->ERROR) {
					status = "ERROR";
				}
				else if (COMP->TASK_STATE[taskIdL] == COMP->DELETED) {
					status = "DELETED";
				}
			}
			else {
				status = "UNKNOWN_ID";
			}

			std::cout << "Status is: " << status << std::endl;
			statusMsg = delimiter1+std::to_string(taskIdL)+delimiter1+status;

			guard.release();

			this->sc.send(statusMsg + "\n");

			// TODO: Remove elements from the data structure if SUCCESS or ERROR was sent to AAS?
		}

		else if (operationType == "GetOutputCapability") {

			SmartACE::SmartGuard guard(COMP->mutex);

			std::string taskId = message.substr(0, message.find(delimiter1));
			long taskIdL = std::strtol(taskId.c_str(), NULL, 0);

			std::string outMsg = delimiter1+std::to_string(taskIdL)+delimiter1+COMP->TASK_OUT[id];

			guard.release();

			this->sc.send(outMsg + "\n");

			// TODO: Remove elements from the data structure if output was sent to AAS?
		}

		else {
			std::cout << "Error: Invalid operation type!" << std::endl;
		}
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int CommandActivity::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
