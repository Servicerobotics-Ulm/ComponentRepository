//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2021 Timo Blender
//
//        timo.blender@thu.de
//        christian.schlegel@thu.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  Contributors:
//		Vineet Nagrath
//		Nayabrasul Shaik
//		Timo Blender
//		Christian Schlegel
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "TaskSendInHandler.hh"

#include <iostream>

#include "ComponentAASBridge.hh"

TaskSendInHandler::TaskSendInHandler(Smart::InputSubject<CommBasicObjects::CommTaskMessage> *subject, const int &prescaleFactor)
:	TaskSendInHandlerCore(subject, prescaleFactor)
{
	std::cout << "constructor TaskSendInHandler\n";
}
TaskSendInHandler::~TaskSendInHandler() 
{
	std::cout << "destructor TaskSendInHandler\n";
}

void TaskSendInHandler::on_TaskSendIn(const CommBasicObjects::CommTaskMessage &input)
{
	// implement business logic here
	// (do not use blocking calls here, otherwise this might block the InputPort TaskSendIn)

	std::cout << "TaskResult: " << input.getMsg() << std::endl;

	// If we receive something here from the sequencer of a system, then this is either a result (SUCCESS or ERROR) or an output
	// TODO: Separate ports for result and output?

	std::string msg = input.getMsg();

	std::string delimiter = ":";

	std::string type = msg.substr(0, msg.find(delimiter));
	msg.erase(0, msg.find(delimiter) + delimiter.length());

	// SUCESS:SucessMsg
	if (type == "SUCCESS") {

		SmartACE::SmartGuard guard(COMP->mutex);

		COMP->TASK_QUEUE.pop_front();
		COMP->TASK_STATE[COMP->CURRENT_TASK_ID] = COMP->SUCCESS;

		if (COMP->TASK_QUEUE.size() > 0) {

			COMP->CURRENT_TASK_ID = COMP->TASK_QUEUE.front();
			COMP->TASK_STATE[COMP->CURRENT_TASK_ID] = COMP->EXECUTING;
			std::string tclCommand = COMP->TASK_COMMAND[COMP->TASK_QUEUE.front()];

			guard.release();

			std::cout << "Next tclCommand: " << tclCommand << std::endl;

			CommBasicObjects::CommTaskMessage msg;
			msg.setMsg(tclCommand);
			CommBasicObjects::CommTaskEventState state;
			state.setJob(msg);
			COMP->taskEventOut->put(state);
		}
	}

	// ERROR:ErrorMessage
	else if (type == "ERROR") {
		SmartACE::SmartGuard guard(COMP->mutex);
		COMP->TASK_STATE[COMP->CURRENT_TASK_ID] = COMP->ERROR;
		COMP->TASK_ERROR_VALUE.insert(std::make_pair(COMP->CURRENT_TASK_ID, msg));
		guard.release();
	}

	// OUT:Value
	else if (type == "OUT") {
		SmartACE::SmartGuard guard(COMP->mutex);
		COMP->TASK_OUT[COMP->CURRENT_TASK_ID] = msg;
		guard.release();
	}
}
