//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//  Copyright (C) 2020 Nayabrasul Shaik
//
//        nayabrasul.shaik@thu.de
//
//        Christian Schlegel (christian.schlegel@thu.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//-------------------------------------------------------------------------

#include <AprilTagWrapper.hh>
#include <cstring>
#include <iomanip>
#include <algorithm>
#include <iterator>
#include "3rdParty/apriltag/tag_families/tag16h5.h"
#include "3rdParty/apriltag/tag_families/tag36h11.h"
#include "3rdParty/apriltag/tag_families/tag25h9.h"
#include "3rdParty/apriltag/tag_families/tagCircle21h7.h"
#include "3rdParty/apriltag/tag_families/tagCircle49h12.h"
#include "3rdParty/apriltag/tag_families/tagCustom48h12.h"
#include "3rdParty/apriltag/tag_families/tagStandard41h12.h"
#include "3rdParty/apriltag/tag_families/tagStandard52h13.h"
#include "EulerTransformationMatrices.hh"
#include "math.h"
#include "opencv2/opencv.hpp"

#ifdef WITH_MRPT_2_0_VERSION
#else
	#include <mrpt/math.h>
	#include <mrpt/poses/CPose3D.h>
#endif

AprilTagWrapper::AprilTagWrapper() {

	tag_detector = apriltag_detector_create();
	tag_family = nullptr;

}

AprilTagWrapper::~AprilTagWrapper() {
	apriltag_detector_destroy(tag_detector);
	destroy_tag_family(tag_family);
}

void AprilTagWrapper::create_and_add_tag_family(std::string family)
{
	if (!family.compare("tag36h11")) {
		tag_family = tag36h11_create();
	} else if (!family.compare("tag25h9")) {
		tag_family = tag25h9_create();
	} else if (!family.compare("tag16h5")) {
		tag_family = tag16h5_create();
	} else if (!family.compare("tagCircle21h7")) {
		tag_family = tagCircle21h7_create();
	} else if (!family.compare("tagCircle49h12")) {
		tag_family = tagCircle49h12_create();
	} else if (!family.compare("tagStandard41h12")) {
		tag_family = tagStandard41h12_create();
	} else if (!family.compare("tagStandard52h13")) {
		tag_family = tagStandard52h13_create();
	} else if (!family.compare("tagCustom48h12")) {
		tag_family = tagCustom48h12_create();
	} else {
		std::cout << "Error: Given tag family is not supported\n" <<"\t\t" <<family<<std::endl;
		exit(EXIT_FAILURE);
	}

	apriltag_detector_add_family(tag_detector, tag_family);
	std::cout << "tagfamily "<<family << " added to the detector\n";
}

void AprilTagWrapper::destroy_tag_family(apriltag_family_t *tag_family)
{
	   std::string current_family_name = std::string(tag_family->name);
	if (!current_family_name.compare("tag36h11")) {
			tag36h11_destroy(tag_family);
		} else if (!current_family_name.compare("tag25h9")) {
			tag25h9_destroy(tag_family);
		} else if (!current_family_name.compare("tag16h5")) {
			tag16h5_destroy(tag_family);
		} else if (!current_family_name.compare("tagCircle21h7")) {
			tagCircle21h7_destroy(tag_family);
		} else if (!current_family_name.compare("tagCircle49h12")) {
			tagCircle49h12_destroy(tag_family);
		} else if (!current_family_name.compare("tagStandard41h12")) {
			tagStandard41h12_destroy(tag_family);
		} else if (!current_family_name.compare("tagStandard52h13")) {
			tagStandard52h13_destroy(tag_family);
		} else if (!current_family_name.compare("tagCustom48h12")) {
			tagCustom48h12_destroy(tag_family);
		} else {
			std::cout << "Error: Given tag family is not supported\n" <<"\t\t" <<current_family_name<<std::endl;
			exit(EXIT_FAILURE);
		}
}

void AprilTagWrapper::set_detector_decimate(double decimate)
{
	tag_detector->quad_decimate = decimate;

}

void AprilTagWrapper::set_detector_sigma(double sigma)
{
	tag_detector->quad_sigma = sigma;
}
void AprilTagWrapper::set_detector_num_threads(uint8_t nthreads)
{
	tag_detector->nthreads = nthreads;
}
void AprilTagWrapper::set_detector_debug(bool debug)
{
	tag_detector->debug = debug;
}
void AprilTagWrapper::set_detector_refine_edges(bool refine_edges)
{
	tag_detector->refine_edges = refine_edges;
}

void AprilTagWrapper::set_marker_size(double size)
{
	detection_info.tagsize = size;
}

void AprilTagWrapper::set_decision_threshold(double threshold)
{
	decision_threshold = threshold;
}

bool AprilTagWrapper::set_intrinsic_parameters(DomainVision::CommVideoImage &input_image)
{
	arma::mat intrinsics = arma::zeros(4,4);
	intrinsics = input_image.get_intrinsic();

	detection_info.fx = intrinsics(0,0);
	detection_info.fy = intrinsics(1,1);
	detection_info.cx = intrinsics(0,2);
	detection_info.cy = intrinsics(1,2);

	return true;
}

void AprilTagWrapper::process_image(DomainVision::CommVideoImage &input_image, CommTrackingObjects::CommDetectedMarkerList& markers_list)
{
	//IplImage *ipl_image = convertDataArrayToIplImage(input_image, cvSize(input_image.get_width(), input_image.get_height()));
	//cv::Mat input_rgb_mat = cv::cvarrToMat(ipl_image);

	cv::Mat input_rgb_mat(input_image.get_height(), input_image.get_width(), CV_8UC3, (void *)input_image.get_data());
	cv::Mat input_gray_mat;
	cv::cvtColor(input_rgb_mat, input_gray_mat, cv::COLOR_RGB2GRAY);

	image_u8 im = { .width = input_gray_mat.cols,
			.height = input_gray_mat.rows,
			.stride = input_gray_mat.cols,
			.buf = input_gray_mat.data
	};

	zarray_t *detections = apriltag_detector_detect(tag_detector, &im);

	//cvReleaseImage(&ipl_image);
	int num_tags = 0;
	num_tags = (detections== nullptr)? 0: zarray_size(detections);

	markers_list.clearMarkers();
	markers_list.setSensor_pose(input_image.getSensor_pose());
	markers_list.setBase_state(input_image.getBase_state());

	gui_data.clear();

	for (int i = 0; i < num_tags; i++) {
		apriltag_detection_t *current_detected_marker;
		zarray_get(detections, i, &current_detected_marker);

		if((current_detected_marker->hamming != 0) || (current_detected_marker->decision_margin <decision_threshold))
		{
			//			std::cout << "\n Marker detected with Id : " << std::setw(2)<<current_detected_marker->id
			//					  << ", but ignored because of decision margin :" << std::setw(8)<< current_detected_marker->decision_margin
			//					  << " is < " << std::setw(8)<< decision_threshold
			//					  << ", Hamming " << std::setw(8)<< current_detected_marker->hamming
			//					  <<std::endl;
			continue;
		}

		detection_info.det = current_detected_marker;
		apriltag_pose_t current_marker_pose;

		estimate_tag_pose(&detection_info, &current_marker_pose);
        std::setprecision(5);
        std::cout << std::fixed;

		CommBasicObjects::CommPose3d marker_pose_in_camera_frame;
		april_tag_pose_to_commpose3d(current_marker_pose, marker_pose_in_camera_frame);

		CommTrackingObjects::CommDetectedMarker cm;
		cm.setId(current_detected_marker->id);
		cm.setPose(marker_pose_in_camera_frame);
		markers_list.add_CommDetectedMarker(cm);

		MarkerGUIData current_gui_data;
		current_gui_data.corners.push_back(cv::Point(current_detected_marker->p[0][0], current_detected_marker->p[0][1]));
		current_gui_data.corners.push_back(cv::Point(current_detected_marker->p[1][0], current_detected_marker->p[1][1]));
		current_gui_data.corners.push_back(cv::Point(current_detected_marker->p[2][0], current_detected_marker->p[2][1]));
		current_gui_data.corners.push_back(cv::Point(current_detected_marker->p[3][0], current_detected_marker->p[3][1]));
		current_gui_data.pose    = marker_pose_in_camera_frame;
		current_gui_data.tag_id  = current_detected_marker->id;
		gui_data.push_back(current_gui_data);
	}

	apriltag_detections_destroy(detections);

}

void AprilTagWrapper::april_tag_pose_to_commpose3d(apriltag_pose_t& april_pose, CommBasicObjects::CommPose3d& comm_pose)
{

	//Tag    frame : X- right, Y - down, Z -into the tag
	//Camera Frame : X- right, Y - Up,   Z -from camera to scene

    std::cout << "\n april pose :" <<april_pose <<std::endl;
	double roll;
	double elevation;
	double azimuth;

	rotation_matrix_to_eurle_angles(april_pose.R->data, roll, elevation, azimuth);

	CommBasicObjects::CommOrientation3d comm_orientation;
	comm_orientation.set_azimuth(azimuth);
	comm_orientation.set_roll(roll);
	comm_orientation.set_elevation(elevation);

	CommBasicObjects::CommPosition3d tr;
	tr.set_x(april_pose.t->data[0]*1000.0);
	tr.set_y(april_pose.t->data[1]*1000.0);
	tr.set_z(april_pose.t->data[2]*1000.0);

	comm_pose.set_position(tr);
	comm_pose.set_orientation(comm_orientation);
	comm_pose.to_ostream(std::cout);
	std::cout << "\n apriltag in comm object1:\n" <<comm_pose.getHomogeneousMatrix(1.0) <<std::endl;


	arma::mat res_r(4,4);

	//Rotation part
	res_r(0,0) = april_pose.R->data[0];
	res_r(0,1) = april_pose.R->data[1];
	res_r(0,2) = april_pose.R->data[2];

	res_r(1,0) = april_pose.R->data[3];
	res_r(1,1) = april_pose.R->data[4];
	res_r(1,2) = april_pose.R->data[5];

	res_r(2,0) = april_pose.R->data[6];
	res_r(2,1) = april_pose.R->data[7];
	res_r(2,2) = april_pose.R->data[8];

	//Translation part
	res_r(0,3) = april_pose.t->data[0];
	res_r(1,3) = april_pose.t->data[1];
	res_r(2,3) = april_pose.t->data[2];

	//Homogeneous part
	res_r(3,0) = 0;
	res_r(3,1) = 0;
	res_r(3,2) = 0;
	res_r(3,3) = 1;

	CommBasicObjects::CommPose3d test_pose(res_r, 1.0);
	std::cout << "\n apriltag in comm object2:\n" <<test_pose.getHomogeneousMatrix(1.0) <<std::endl;
	test_pose.to_ostream(std::cout);

}

void AprilTagWrapper::rotation_matrix_to_eurle_angles(double rotation_mat[], double& roll, double& elevation, double& azimuth)
{
	arma::mat res_r(3,3);
	res_r(0,0) = rotation_mat[0];
	res_r(0,1) = rotation_mat[1];
	res_r(0,2) = rotation_mat[2];

	res_r(1,0) = rotation_mat[3];
	res_r(1,1) = rotation_mat[4];
	res_r(1,2) = rotation_mat[5];

	res_r(2,0) = rotation_mat[6];
	res_r(2,1) = rotation_mat[7];
	res_r(2,2) = rotation_mat[8];

	EulerTransformationMatrices::zyx_from_matrix(res_r, azimuth, elevation, roll);
}

void AprilTagWrapper::display_options()
{
   uint8_t num_tag_families = tag_detector->tag_families->size;
   std::stringstream added_tag_families("");

   for(size_t i =0; i< num_tag_families; ++i)
   {
   apriltag_family_t *current_tag_family;
   zarray_get(tag_detector->tag_families, i, &current_tag_family);
   added_tag_families << std::string(current_tag_family->name)<<", ";
   }
   std::cout << TEXT_COLOR_GREEN;
   std::cout << "°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\n";
   std::cout <<"                   AprilTag Detector\n";
   std::cout << "°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\n";
   std::cout <<std::setw(25)<< "tagfamilies"    	<<" : "<<added_tag_families.str() <<"\n";
   std::cout <<std::setw(25)<< "tagSize"        	<<" : "<<detection_info.tagsize <<"m\n";
   std::cout <<std::setw(25)<< "decision_threshold" <<" : "<<decision_threshold <<"\n";
   std::cout <<std::setw(25)<< "decimate"			<<" : "<<tag_detector->quad_decimate <<"\n";
   std::cout <<std::setw(25)<< "sigma"				<<" : "<<tag_detector->quad_sigma <<"\n";
   std::cout <<std::setw(25)<< "nthreads"			<<" : "<<tag_detector->nthreads <<"\n";
   std::cout <<std::setw(25)<< "debug"				<<" : "<<(tag_detector->debug?std::string("True"): std::string("False")) <<"\n";
   std::cout <<std::setw(25)<< "refine_edges"		<<" : "<<(tag_detector->refine_edges?std::string("True"): std::string("False")) <<"\n";
   std::cout << "°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°°\n";
   std::cout << TEXT_COLOR_RESET  <<std::endl;
}

void AprilTagWrapper::draw_markers(DomainVision::CommVideoImage& image)
{
	if(gui_data.size() == 0)
	{
		return;
	}

	// CommVideoImage to IplImage
    //IplImage *ipl_image = convertDataArrayToIplImage(image, cvSize(image.get_width(), image.get_height()));
	//cv::Mat bgr_mat = cv::cvarrToMat(ipl_image);

	cv::Mat input_rgb_mat(image.get_height(), image.get_width(), CV_8UC3, (void *)image.get_data());
	cv::Mat input_gray_mat;
	cv::cvtColor(input_rgb_mat, input_gray_mat, cv::COLOR_RGB2GRAY);

	//cv::Mat input_rgb_mat;
	//cv::cvtColor(bgr_mat, input_rgb_mat, cv::COLOR_BGR2RGB);

	for(MarkerGUIData current_gui_data: gui_data)
	{
		draw_marker_corners(input_rgb_mat, current_gui_data.corners);

		std::stringstream tag_id_string;
		tag_id_string << current_gui_data.tag_id;

		cv::Point topleft     = current_gui_data.corners[0];
		draw_marker_text(input_rgb_mat, topleft, tag_id_string.str());
	}


	// set cv::Mat to commvideoimage
	image.set_parameters(image.get_width(), image.get_height(), DomainVision::FormatType::RGB24);
	image.set_data(input_rgb_mat.data);
	//cvReleaseImage(&ipl_image);
}

void AprilTagWrapper::draw_marker_text(cv::Mat& image, const cv::Point& point, const std::string& text)
{
	int fontface = cv::FONT_HERSHEY_SCRIPT_SIMPLEX;
    double fontscale = 1.0;
    int thickness = 1;
	int baseline;

	cv::putText(image, text, point, fontface, fontscale, cv::Scalar(255, 255, 0), thickness);
}

void AprilTagWrapper::draw_marker_corners(cv::Mat& image, const std::vector<cv::Point>& corners)
{
	int thickness =1;
	cv::Point p0     = corners[0];
	cv::Point p1     = corners[1];
	cv::Point p2     = corners[2];
	cv::Point p3     = corners[3];


	cv::line(image, p0, p1, CV_RGB(0,   255,   0), thickness);
	cv::line(image, p0, p3, CV_RGB(0,   255,   0), thickness);
	cv::line(image, p1, p2, CV_RGB(0,     0, 255), thickness);
	cv::line(image, p2, p3, CV_RGB(0,     0, 255), thickness);
}
/*
IplImage* AprilTagWrapper::convertDataArrayToIplImage(DomainVision::CommVideoImage &query_image, CvSize size)
{
	IplImage* ipl_image = NULL;

	if (query_image.get_format() == DomainVision::FormatType::UYVY || query_image.get_format() == DomainVision::FormatType::RGB24)
	{
		unsigned char* arr_image = new unsigned char[query_image.get_size_as_rgb24()];
		query_image.get_as_rgb24(arr_image);

		ipl_image = OpenCVHelpers::copyRGBToIplImage(arr_image, query_image.get_height(), query_image.get_width());
		delete[] arr_image;

	} else if (query_image.get_format() == DomainVision::FormatType::GREY)
	{
		CvMat mat;
		cvInitMatHeader(&mat, size.height, size.width, CV_8UC1, const_cast<unsigned char *> (query_image.get_data()));
		ipl_image = cvCreateImage(size, IPL_DEPTH_8U, 1);

		// copy matrix data into image
		cvCopy(&mat, ipl_image);

	} else if (query_image.get_format() == DomainVision::FormatType::YUV422)
	{
		unsigned char* arr_image = new unsigned char[query_image.get_size_as_rgb24()];
		query_image.get_as_rgb24(arr_image);

		ipl_image = OpenCVHelpers::copyRGBToIplImage(arr_image, query_image.get_height(), query_image.get_width());
		delete[] arr_image;

	} else
	{
		std::cout << "Image Format: " << query_image.get_format() << " not supported!" << std::endl;
	}

	return ipl_image;

}
*/
double AprilTagWrapper::pi_to_pi(double angle)
{

	   angle+=M_PI;
	   double ret_angle = fmod(angle,2*M_PI);

	   if(angle<0)
	     ret_angle+=2*M_PI;

	   ret_angle-=M_PI;

	   return ret_angle;
}

std::ostream& operator<<(std::ostream& os, const apriltag_pose_t& ap)
{

	arma::mat res_r(3,3);
	res_r(0,0) = ap.R->data[0];
	res_r(0,1) = ap.R->data[1];
	res_r(0,2) = ap.R->data[2];

	res_r(1,0) = ap.R->data[3];
	res_r(1,1) = ap.R->data[4];
	res_r(1,2) = ap.R->data[5];

	res_r(2,0) = ap.R->data[6];
	res_r(2,1) = ap.R->data[7];
	res_r(2,2) = ap.R->data[8];


	double eyaw, epitch, eroll;
	EulerTransformationMatrices::zyx_from_matrix(res_r, eyaw, epitch, eroll);



	os << std::setw(40)<<"\nTranslation: "
	   << std::setw(40)<<"[" << ap.t->data[0] << " "<< ap.t->data[1] << " "<< ap.t->data[2]<< "]"
	   << std::setw(40)<<"\nRotation Matrix :"
	   <<"[" << ap.R->data[0] << " "<< ap.R->data[1] << " "<< ap.R->data[2] << ";"
	         << ap.R->data[3] << " "<< ap.R->data[4] << " "<< ap.R->data[5] << ";"
	         << ap.R->data[6] << " "<< ap.R->data[7] << " "<< ap.R->data[8] << "]"
	   << "\nOrientation (in deg): [" <<" azimuth =" << eyaw*180.0/M_PI<<" pitch =" << epitch*180.0/M_PI<<" roll =" << eroll*180.0/M_PI<<"]" <<std::endl;
	return os;
}
