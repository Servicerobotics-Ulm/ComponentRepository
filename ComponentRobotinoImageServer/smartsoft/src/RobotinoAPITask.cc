//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//  Copyright (C) 2010 Matthias Lutz
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//-------------------------------------------------------------------------

#include "RobotinoAPITask.hh"
#include "ComponentRobotinoImageServer.hh"

#include <iostream>
#include <opencv2/opencv.hpp>

RobotinoAPITask::RobotinoAPITask(SmartACE::SmartComponent *comp) 
:	RobotinoAPITaskCore(comp), cv(lock), com(), rec::robotino::api2::Camera()
{
	std::cout << "constructor RobotinoAPITask\n";
	_seq_counter = 0;
	aborted_get_image = false;
	debug_enabled = false;
}
RobotinoAPITask::~RobotinoAPITask() 
{
	std::cout << "destructor RobotinoAPITask\n";
}

void RobotinoAPITask::imageReceivedEvent( const unsigned char* data,
							 unsigned int dataSize,
							 unsigned int width,
							 unsigned int height,
							 unsigned int step )
{

	_seq_counter++;

	if(debug_enabled){
		std::cout<<"imageReceivedEvent: seq: "<< _seq_counter << "size"<<height<<":"<<width<<"dataSite: "<<dataSize<<std::endl;
	}


	lock.acquire();

		cv::Mat mat(height,width,CV_8UC3,(void*)data,step);
		image.set_data(mat.data);
		image.set_sequence_counter(_seq_counter);
		if(debug_enabled){
			std::cout << "image_size = " << image.get_size() << ", " << width << ", " << height<< std::endl;
		}

	cv.broadcast();
	lock.release();
}


DomainVision::CommVideoImage RobotinoAPITask::getImage(){

	SmartACE::SmartGuard g(lock);
	ACE_Time_Value timeout(0,500000);

	const ACE_Time_Value absolutetime = ACE_OS::gettimeofday() + timeout;
	if(cv.wait(&absolutetime) !=0){
		std::cout<<"getImage cv.wait timeout"<<std::endl;
		this->image.setIs_valid(false);
	}

	if(aborted_get_image == true)
	{
		std::cout<<"getImage aborted!"<<std::endl;
		this->image.setIs_valid(false);
		aborted_get_image=false;
	}
	return this->image;

}

bool RobotinoAPITask::startCaptureMode(){
	lock.acquire();
	aborted_get_image = true;
	cv.broadcast();
	lock.release();

	this->setComId(com.id());
	aborted_get_image=false;
	return true;
}


bool RobotinoAPITask::stopCaptureMode(){
	this->setComId(rec::robotino::api2::ComId::null());
	return true;
}



int RobotinoAPITask::on_entry()
{
	com.setAddress(COMP->getGlobalState().getHardware().getHost().c_str());
	com.connectToServer(true);
//	camera.setFormat(1920, 1080, "raw");

	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	DomainVision::FormatType format;
	if (!DomainVision::CommVideoImage::string2format(COMP->getGlobalState().getImage().getSmart_format(), format)) {
			std::cout<<"ERROR in converting format"<<std::endl;
			return -1;
	}

	image.set_parameters(COMP->getGlobalState().getHardware_properties().getWidth(),
			  COMP->getGlobalState().getHardware_properties().getHeight(),format);
	image.resizeIntrinsic_m(4*4);

	debug_enabled = COMP->getGlobalState().getSettings().getDebug_info();

	return 0;
}
int RobotinoAPITask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	if(COMP->stateSlave->acquire("nonneutral") == Smart::SMART_OK){

		com.processEvents();
	
		COMP->stateSlave->release("nonneutral");
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int RobotinoAPITask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
