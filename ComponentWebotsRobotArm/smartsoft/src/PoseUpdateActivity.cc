//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C)  2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------

#include "PoseUpdateActivity.hh"
#include "ComponentWebotsRobotArm.hh"

#include <iostream>

#include <webots/Motor.hpp>
#include <webots/PositionSensor.hpp>
#include <webots/DistanceSensor.hpp>
#include <webots/Connector.hpp>
#include <webots/Keyboard.hpp>
#include <webots/utils/AnsiCodes.hpp>
#include <webots/Receiver.hpp>

#include <iomanip>
#include <eigen3/Eigen/Geometry>

using namespace webots;

std::string robotArmModel;

// glossary:
// frame = frame of reference = coordinate system
// pose = position (translation) and orientation (rotation) of B relative to A (both A and B are points in 3D space, A is used as frame of reference)
// transformation = translation or rotation or scaling or shearing
// translation = change position
// rotation = change orientation
//
// we use 3D, rectangular, right handed coordinate systems, unit [m] or [mm]
// axes conventions:
// ENU: x=east, y=north, z=up (for world map)
// FLU: x=forward, y=left, z=up (for robots etc.)
// x=Red y=Green z=Blue
//
// angle is measured in radians
// e.g. heading/yaw/azimuth = rotation around z-axis, starting from x-axis in direction to y-axis
//                   0
//                Z  | X
//                |  |/
//             ***|**+***
//   pi/2  ****   | /    **  3/2*pi
//      \ *       |/       */
//    Y--+--------+--------+--
//        *      /        *
//         **   /    ****
//           **+*****
//            / \
//               pi
//
// rotate | start | to   |
// around | axis  | axis | names
// -------+-------+------+
//    Z       X      Y     yaw   = azimuth   = heading
//    Y       X     -Z     pitch = elevation = pitch
//    X       Y      Z     roll  = roll      = bank
// (see right hand rule)
//
// different representations for rotation:
// * pose matrix
//   a homogeneous matrix allows a combination of any number of translation, rotation, scaling or shearing.
//   (see https://www.javatpoint.com/computer-graphics-homogeneous-coordinates)
//   transform a point (x,y,z) by 9 matrices:
//                        (x)       (x)
//                        (y)       (y)
//   M1 * M2 * ... * M9 * (z) = M * (z)   with M = M1 * M2 * ... M9
//                        (1)       (1)
//   pose matrix is a special case of a homogeneous matrix: only translation and rotation possible, last line in matrix is always 0 0 0 1.
//   Pose Matrix            Rotation Matrix        Translation Matrix
//   P = r11 r12 r13  x     R = r11 r12 r13  0     T = 1   0   0  x
//       r21 r22 r23  y         r21 r22 r23  0         0   1   0  y
//       r32 r32 r33  z         r31 r32 r33  0         0   0   1  z
//         0   0   0  1           0   0   0  1         0   0   0  1
// * euler angles :
//   used for parameters in SmartSoft
//   intrinsic ZYX rotate around z/y/x axis by angle azimuth(yaw)/elevation(pitch)/roll [radians]
//     x, y, z, azimuth, elevation, roll
// * axis angle :
//   used in webots as
//     (nx, ny, nz, alpha)
//     rotate around AXIS (nx,ny,nz) by ANGLE alpha [radians].
//     (nx,ny,nz) must be a unit axis <=> normalized <=> length 1 <=> sqrt(nx*nx+ny*ny+nz*nz)=1
//   used in universal robotics controller as
//     (rx, ry, rz) = alpha * (nx, ny, nz) = (alpha*nx, alpha*ny, alpha*nz)
// * quaternion :
//   used for rotation interpolation (SLERP algorithm)
//     (qw, qx, qy, qz) = (cos(alpha/2), nx*sin(alpha), ny*sin(alpha), nz*sin(alpha))
//     unit quaterion <=> normalized <=> length 1 <=> sqrt(qw*q2+qx*qx+qy*qy+qz*qz)=1 <=> (nx,ny,nz) is unit vector

//////////////// helper functions /////////////////////

// replaces EulerTransformationMatrices::create_zyx_matrix(...)
// replaces CommBasicObjects::CommPose3d getHomogeneousMatrix()
Eigen::MatrixXd getPoseMatrixFromEulerAngles(double x, double y, double z, double azimuth, double elevation, double roll) {
    Eigen::Matrix3d R;
    R = Eigen::AngleAxisd(azimuth, Eigen::Vector3d::UnitZ()) *
        Eigen::AngleAxisd(elevation, Eigen::Vector3d::UnitY()) *
        Eigen::AngleAxisd(roll, Eigen::Vector3d::UnitX());
    Eigen::MatrixXd matrix(4,4);
    matrix.setIdentity();
    matrix.block<3,3>(0,0) = R;
    matrix(0,3) = x;
    matrix(1,3) = y;
    matrix(2,3) = z;
    return matrix;
}

// replaces EulerTransformationMatrices::zyx_from_matrix(...)
void getEulerAnglesFromPoseMatrix(Eigen::MatrixXd matrix, double& x, double &y, double &z, double &azimuth, double & elevation, double &roll) {
    Eigen::Matrix3d R;
    R = matrix.block<3,3>(0,0);
    Eigen::Vector3d ea = R.eulerAngles(2, 1, 0);
    x = matrix(0,3);
    y = matrix(1,3);
    z = matrix(2,3);
    azimuth = ea(0);
    elevation = ea(1);
    roll = ea(2);
}

// returns inverse of pose matrix; same as inv(arma::mat) but should be much faster
Eigen::MatrixXd getInversePoseMatrix(Eigen::MatrixXd matrix) {
    Eigen::Matrix3d R = matrix.block<3,3>(0,0).transpose();
    Eigen::Vector3d t = -R * matrix.block<3,1>(0,3);
    Eigen::MatrixXd m(4,4);
    m.setIdentity();
    m.block<3,3>(0,0) = R;
    m.block<3,1>(0,3) = t;
    return m;
}

Eigen::Quaterniond getQuaternionFromPoseMatrix(Eigen::MatrixXd matrix) {
    Eigen::Matrix3d mat = matrix.block<3,3>(0,0);
    Eigen::Quaterniond q(mat);
    return q.normalized();
}

bool isNUE; // is the webots world coordinate system NorthUpEast?

// webots coordinate system can be NUE=NorthUpEast or ENU=EastNorthUp
// smartsoft coordinate system is ENU
// if a webots function returns a position, convert it from webots coordinate system to smartsoft coordinate system
std::array<double, 3> webots2smartPosition(const double *d) {
    if (isNUE) {
        std::array<double, 3> position = { d[0], -d[2], d[1] };
        return position;
    } else {
        std::array<double, 3> position = { d[0], d[1], d[2] };
        return position;
    }
}

// converts the rotation matrix, see webots2smartPosition
std::array<double, 9> webots2smartOrientation(const double *d) {
    if (isNUE) {
        std::array<double, 9> orientation = { d[0], d[1], d[2], -d[6], -d[7], -d[8], d[3], d[4], d[5] };
        return orientation;
    } else {
        std::array<double, 9> orientation = { d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8] };
        return orientation;
    }
}

// get pose matrix from a webots node
// 4x4 pose matrix:
// r11 r12 r13  x
// r21 r22 r23  y
// r32 r32 r33  z
//   0   0   0  1
// translation = node->getPosition() = x/y/z [m]
// rotation = node->getOrientation() = r11, r12, ..., r33
Eigen::MatrixXd getPoseMatrixFromWebotsNode(webots::Node *node) {
    std::array<double, 3> position = webots2smartPosition(node->getPosition());
    std::array<double, 9> orientation = webots2smartOrientation(node->getOrientation());
    Eigen::MatrixXd matrix(4, 4);
    matrix.setIdentity();
    for(int i=3; i--;)
        for(int j=3; j--;)
            matrix(i,j) = orientation[i*3+j];
    matrix(0, 3) = position[0];
    matrix(1, 3) = position[1];
    matrix(2, 3) = position[2];
    return matrix;
}

// ComponentAmclWithTags AmclTask.cc:
// mrpt::poses::CPose3D robot_to_marker(markerPoseInRobotFrame.get_x(1), ... markerPoseInRobotFrame.get_roll());
// mrpt::poses::CPose3D world_to_marker(markerPoseInWorldFrame.get_x(1) ... markerPoseInWorldFrame.get_roll());
// arma::mat m_world_to_marker = markerPoseInWorldFrame.getHomogeneousMatrix(1.0);
// arma::mat m_robot_to_marker = markerPoseInRobotFrame.getHomogeneousMatrix(1.0);
// arma::mat m_world_to_robot  = m_world_to_marker * arma::inv(m_robot_to_marker);

// combine two transformations into one: matrix_a * matrix_b
// transform from node coordinate system to world coordinate system:
// matrix * vector {x, y, z, 1}
// transform from world's coordinate system to node coordinate system:
// inv(matrix) * vector {x, y, z, 1}

Eigen::Vector3d realP[7];
// negativeJointAngles4= true <=>  -M_PI < jointAngles[4] < 0
// negativeJointAngles4= false <=>     0 < jointAngles[4] < M_PI
// paletizing from above with vacuum gripper pointing down and p4p5 pointing forward => negativeJointAngles4 = true
bool negativeJointAngles4;

void printVectorError(std::string msg, Eigen::Vector3d vec1, Eigen::Vector3d vec2) {
    std::cout << msg << " " << vec1.transpose() << std::endl;
/*    if((vec1 - vec2).norm()> 0.0001) {
        std::cout << msg << " " << AnsiCodes::RED_FOREGROUND <<
        vec2.transpose() << AnsiCodes::RESET << std::endl;
    }
*/
}

// todo:
// * generischer arm:
//   + längen oben/links/oben/rechts/oben/links/oben/links (8 längen, anstatt nur d[6])
//   + radius für cylinder/capsule
//   + masse für bewegliche teile ?
//   -> .proto
// * self collision, collision
// * -2*pi <= winkel <= 2*pi   (bei p2/jointAngles[4])

// specific task 'palettizing':
// how to choose from two possible symmetric solutions:
// side view:                   p2
// triangle p1/p2/p3:       ****  ***p3     OR               *p3
//                        p1                        p1***   *
//                        p0                        p0   *p2
// => always choose left solution
//
// jointAngles[4] is -value OR +value (opposite direction for p4p5)
// => always choose negative sign (p4p5 points forward, TCP points down)
//
// rotate arm in same or opposite direction (jointAngles[0] +  M_PI)
// side view:    p3                 p3
//              *      OR          *
//             *                  *
//            p1->x          x<-p1
// => always choose left solution
// (todo: calculate both solutions, choose the solution with similar joint angles than actual robot arm)

// This function does the inverse kinematic for an webots UR5/UR5e/UR10e robot arm.
// input parameter 'matrix': 4x4 pose matrix with position and orientation of the webots toolSlot relative to the webots robot arm frame
// output parameter 'jointAngles': roboter arm joint angles.
// returns 0 if the calculation was successfull, or returns the line number if an error occurred.
int getJointAnglesFromToolSlotPoseMatrix(Eigen::MatrixXd matrix, std::array<double, 6> &jointAngles) {
    // length, coordinate systems etc. are from webots UR5e.proto UR10e.proto or UR5.proto
    // (.proto are made from ROS .urdf and .srdf files)
    // NOT equal to Universal Robotics coordinate systems
    // NOT equal to SmartSoft coordinate systems

    // (see https://cyberbotics.com/doc/guide/ure)
    // starting position: all jointAngles == 0 (coordinate system from p0)
    // top view:
    //   y                      p6
    //   ^                      |
    //   |                      p5
    //   +--> x                /
    //  /            p0        p4
    // z            /          |
    //             p1----p2----p3
    //
    // side view:                 p4 p6
    //   z                       /| /
    //   ^         p1----p2----p3 p5
    //   |         |
    //   +--> x    p0
    //  /
    // y

    // p0 = start point (robot arm is mounted here, is (0/0/0) of robots coordinate system)
    // p6 = toolSlot of robot arm in webots = flange = where tools are mounted at the end of the robot arm
    // motor 0 rotates around p0 by jointAngles[0] etc.
    // d[i] = distance between p[i] and p[i+1]

    // todo: move these numbers into parameters
    // how to find parameters from e.g. UR5.proto:
    // 1. endpoint translation 0 0 0.089159
    // 2. endpoint translation 0 0.135850 0
    // 3. endpoint translation 0 -0.119700 0.425000
    // 4. endpoint translation 0 0 0.392250
    // 5. endpoint translation 0 0.093000 0
    // 6. endpoint translation 0 0 0.094650
    //    toolslot translation 0 0.0823 0

    double d_UR5[6] = {0.089159, 0.425, 0.39225, 0.135850-0.119700+0.093000, 0.094650, 0.0823};
    double d_UR5e[6] = {0.163, 0.425, 0.392, 0.138-0.131+0.127, 0.1, 0.1};
    // todo: remove extra length of vacuum gripper from model
    double d_UR10e[6] = {0.181, 0.613, 0.571, 0.176-0.137+0.135, 0.12, 0.12+0.119};
    double d[6];
    for(int i=6; i--;)
      if(robotArmModel=="UR5")
        d[i] = d_UR5[i];
      else if(robotArmModel=="UR5e")
        d[i] = d_UR5e[i];
      else if(robotArmModel=="UR10e")
        d[i] = d_UR10e[i];
      else {
          std::cout << "ERROR: robotArmModel " << robotArmModel << " has not kinetic defined" << std::endl;
          return __LINE__;
      }
    Eigen::Vector3d p6 = matrix.block<3,1>(0,3);
    printVectorError("p6", p6, realP[6]);

    Eigen::Vector3d axisP5P6 = matrix.block<3,1>(0,1).transpose();
    Eigen::Vector3d p5;
    // p6        p5         y-axis
    // |   d[5]  |          <-----z
    p5 = p6 - d[5]*axisP5P6;
    printVectorError("p5", p5, realP[5]);

    // jointAngles[0] rotates in same direction than p1p3, not opposite

    // p0 p1 p2 p3 are always in an vertical plane. p4 and p5 are in a parallel plane
    //  => d[3] is constant distance between these planes, both planes depend only on motor 0 position

    // top view:
    // remove z-coord to project points into horizontal xy-plane
    //                 p[4]  p[5]=(x,y)
    //  ---------------+-__.-+---
    //       ___...----|-    |  d[3]
    //  ---+-----------+-----+---
    //   p[1]=(0,0)  p[3]
    //   p[0]=(0,0)

    // sin(angle) = opposite cathetus /  hypotenuse = d[3] / length(p1p5)
    double tmp = sqrt(p5[0]*p5[0]+p5[1]*p5[1]);
    if(tmp==0.0)
        return __LINE__;
    tmp = d[3] / tmp;
    if(fabs(tmp)>=1)
        return __LINE__;
    jointAngles[0] = atan2(p5[1], p5[0]) - asin(tmp);
    Eigen::Vector3d axisP3P4(3);
    axisP3P4[0] = cos(jointAngles[0]+M_PI/2);
    axisP3P4[1] = sin(jointAngles[0]+M_PI/2);
    axisP3P4[2] = 0.0;
    axisP3P4 = axisP3P4.transpose();
    // axisP4P5 is orthogonal to axisP3P4 and axisP5P6
    // => axisP4P5 = axisP3P4 x axisP5P6 (cross product)
    Eigen::Vector3d axisP4P5 = axisP3P4.cross(axisP5P6);
    // todo: infinite solutions possible, choose one with minimal distance to actual robot arm pose
    if(axisP4P5.norm()==0.0)
        return __LINE__;
    axisP4P5 /= axisP4P5.norm();
    // two possible solutions:
    // todo: choose automatic
    if(negativeJointAngles4)
        axisP4P5 = -axisP4P5;
    Eigen::Vector3d p4;
    p4 = p5 - (d[4]*axisP4P5);
    printVectorError("p4", p4, realP[4]);
    Eigen::Vector3d p3;
    p3 = p4 - d[3]*axisP3P4;
    printVectorError("p3", p3, realP[3]);
    // angle between p1p2 and p2p3: cosine law
    // two solutions: ^ or v
    // always choose ^
    Eigen::Vector3d p1(3);
    p1[0] = 0; p1[1] = 0; p1[2] = d[0];
    p1 = p1.transpose();
    printVectorError("p1", p1, realP[1]);
    Eigen::Vector3d p1p3 = p3 - p1;
    double c = p1p3.norm();
    if(c == 0.0)
        return __LINE__;
    tmp = (d[1]*d[1] + d[2]*d[2] - c*c) / (2 * d[1] * d[2]);
    if(tmp < -1 || tmp > 1) {
        std::cout << "ERROR: tmp= " << tmp << std::endl;
        return __LINE__;
    }
    jointAngles[2] = M_PI - acos(tmp);
    jointAngles[1] = -acos((c*c + d[1]*d[1] - d[2]*d[2]) / (2 * c * d[1]));

    // side view:
    //        p3
    //      *  |
    //    *    |
    //  p1-----+

    // add angle between p1p3 and heading of p1
    jointAngles[1] += -atan2(p1p3[2], p1p3[0]*cos(jointAngles[0])+p1p3[1]*sin(jointAngles[0]));

    // side view:
    //                        p[3&4]----+---->same horizontal direction as p1
    //                     *       *    |
    //                 *             *  |
    //     z      p[2]                  p5
    //     ^    *
    //     |  *
    //     p1---->rotated in this direction: (cos(jointAngles[0]))
    //     |                                 (sin(jointAngles[0]))
    //     p0                                (         0         )
    jointAngles[3] = atan2(-axisP4P5[2], axisP4P5[0]*cos(jointAngles[0])+axisP4P5[1]*sin(jointAngles[0])) - jointAngles[1] - jointAngles[2] - M_PI/2;

    //
    //                          p6       up direction = p3p4 x p4p5
    //                          |  *     ^
    //                          |     *  |
    //  left direction = p3p4 <-+------p[4&5]----p3
    //
    //                      forward direction = p4p5

    jointAngles[4] = -atan2(axisP5P6.dot(axisP3P4.cross(axisP4P5)), axisP5P6.dot(axisP3P4));

    Eigen::Vector4d p4Homogeneous = p4.homogeneous();
    std::cout << "p4:" << p4.transpose() << " p4p4homogeneous" << p4Homogeneous.transpose() << std::endl;


    //  coordinate system of flange (tool mounting point at end of robot arm):
    //  y-axis is same as p5p6, pointing away from p6
    //  jointAngles[5] == 0  => x-axis is parallel to p5p4 (coordinate system is from p6/toolSlot)
    //     z
    //     ^ y
    //     |/
    //     p6->x
    //    /
    //   p5
    //     ***
    //        ***
    //           p4

    // get p4 position relative to TCP coordinate system
    Eigen::Vector3d p4_in_tcp_coord = getInversePoseMatrix(matrix) * p4Homogeneous;
    std::cout << "p4_in_tcp_coord = " << p4_in_tcp_coord.transpose() << std::endl;
    jointAngles[5] = atan2(p4_in_tcp_coord[0], -p4_in_tcp_coord[2]);
    return 0;
}

PoseUpdateActivity::PoseUpdateActivity(SmartACE::SmartComponent *comp) :
    PoseUpdateActivityCore(comp) {
    std::cout << "constructor PoseUpdateActivity\n";
}
PoseUpdateActivity::~PoseUpdateActivity() {
    std::cout << "destructor PoseUpdateActivity\n";
}

void PoseUpdateActivity::setVacuumGripper(bool isVacuum) {
    isVacuumOn = isVacuum;
}

void PoseUpdateActivity::handleEnterState(const std::string &substate) {
    if (substate == "trajectory")
        newProgram = prTrajectory;
    else if (substate == "neutral")
        newProgram = prNeutral;
}

// called from TrajectorySendServerHandler.cc
void PoseUpdateActivity::on_trajectorySendServer(const CommManipulatorObjects::CommManipulationTrajectory &input) {
    ParameterStateStruct params = COMP->getParameters();
    std::unique_lock<std::mutex> lock(jointMutex);
    if (input.getType() == CommManipulatorObjects::ManipulatorTrajectoryFlag::POSE_TCP) {
        setGoalReached(false);
        double x,y,z,azimuth,elevation,roll;

        // similar code with comments in getMobileManipulatorState()
        input.get_first_pose_TCP_robot(x, y, z, azimuth, elevation, roll, 1);
        Eigen::MatrixXd base_to_TCP = getPoseMatrixFromEulerAngles(x, y, z, azimuth, elevation, roll);
        Eigen::MatrixXd base_to_manipulatorUR = getPoseMatrixFromEulerAngles(
            params.getManipulator().getX(), params.getManipulator().getY(), params.getManipulator().getZ(),
            params.getManipulator().getAzimuth(), params.getManipulator().getElevation(), params.getManipulator().getRoll());
        Eigen::MatrixXd manipulatorUR_to_manipulatorWebots = getPoseMatrixFromEulerAngles(0, 0, 0, 0, 0, M_PI);
        Eigen::MatrixXd toolSlotWebots_to_tool0 = getPoseMatrixFromEulerAngles(0, 0, 0, 0, 0, -M_PI);
        Eigen::MatrixXd tool0_to_TCP = getPoseMatrixFromEulerAngles(
            params.getTCP().getX(), params.getTCP().getY(), params.getTCP().getZ(),
            params.getTCP().getAzimuth(), params.getTCP().getElevation(), params.getTCP().getRoll());
        Eigen::MatrixXd manipulatorWebots_to_base =  getInversePoseMatrix(base_to_manipulatorUR * manipulatorUR_to_manipulatorWebots);
        Eigen::MatrixXd TCP_to_toolSlot = getInversePoseMatrix(toolSlotWebots_to_tool0 * tool0_to_TCP);
        Eigen::MatrixXd manipulatorWebots_to_toolSlot = manipulatorWebots_to_base * base_to_TCP * TCP_to_toolSlot;
        targetTcpPoseMatrix = manipulatorWebots_to_toolSlot;
        targetTcpPoseMatrix = base_to_TCP;
        isTcpMovement = true;
        return;
    }
    if (input.getType() != CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES) {
        std::cerr << __FILE__ << __LINE__ << " error: flag " << input.getType() << std::endl;
        return;
    }
    isTcpMovement = false;
    if (input.get_joint_count() != nrJoints) {
        std::cerr << "wrong number joints" << std::endl;
        return;
    }
    for (int i = 0; i < input.get_trajectory_size(); i++) {
        Trajectory t;
        auto x = input.getJoint_anglesElemAtPos(i);
        t.time = x.getReach_time();
        for (int j = 0; j < nrJoints; j++)
            t.jointTargetPosition[j] = x.getJoint_anglesElemAtPos(j);
        trajectory.push_back(t);
    }
}

void PoseUpdateActivity::on_baseStateServiceIn(const CommBasicObjects::CommBaseState &input) {
}

void PoseUpdateActivity::getMobileManipulatorState(CommManipulatorObjects::CommMobileManipulatorState &mobileState) {

    ParameterStateStruct params = COMP->getParameters();
    CommManipulatorObjects::CommManipulatorState state;
    {
        std::unique_lock<std::mutex> lock(jointMutex);
        state.set_id(stateIdCounter++);
        state.set_pose_manipulator(params.getManipulator().getX(), params.getManipulator().getY(),
            params.getManipulator().getZ(), params.getManipulator().getAzimuth(),
            params.getManipulator().getElevation(), params.getManipulator().getRoll());
        state.set_joint_count(nrJoints);

        if(jointValid) {
          for (int i = 0; i < nrJoints; ++i) {
              state.set_joint_angle(i, jointPosition[i]);
          }

          // different coordinate systems:
          //  toolSlot           tool0 UR5         TCP
          //  webots                 Y             smartsoft
          //                         |
          //    +--X                 +--X         Y--+
          //   /|                   /               /|
          //  Y Z                  Z               X Z

          // (base -> manipulator(UR)) nur in performTrajectoryPoseTCP

          // (A -> B) means pose of B in frame A
          // (manipulator(UR) -> manipulator (webots)) <=> roll=pi
          Eigen::MatrixXd manipulatorUR_to_manipulatorWebots = getPoseMatrixFromEulerAngles(0, 0, 0, 0, 0, M_PI);
          // manipulator(webots) -> toolSlot(webots)
          // tcpPoseArgs is position/orientation of webots toolSlot in webots robot arm frame, set in on_execute()
          Eigen::MatrixXd manipulatorWebots_to_toolSlotWebots = getPoseMatrixFromEulerAngles(tcpPoseArgs[0], tcpPoseArgs[1], tcpPoseArgs[2], tcpPoseArgs[3], tcpPoseArgs[4], tcpPoseArgs[5]);
          // (toolSlot(webots) -> tool0) <=> rotate around x-axis by -pi <=> roll=-pi
          Eigen::MatrixXd toolSlotWebots_to_tool0 = getPoseMatrixFromEulerAngles(0, 0, 0, 0, 0, -M_PI);
          // (tool0 -> tool param) <=> InternalParameter TCP <=> x=0 y=0 z=0.1192 azimuth=pi/2 elevation=-pi/2 roll=0
          Eigen::MatrixXd tool0_to_TCP = getPoseMatrixFromEulerAngles(
              params.getTCP().getX(), params.getTCP().getY(), params.getTCP().getZ(),
              params.getTCP().getAzimuth(), params.getTCP().getElevation(), params.getTCP().getRoll());
          Eigen::MatrixXd manipulatorUR_to_TCP =
              manipulatorUR_to_manipulatorWebots *
              manipulatorWebots_to_toolSlotWebots *
              toolSlotWebots_to_tool0 *
              tool0_to_TCP;
          double args[6];
          getEulerAnglesFromPoseMatrix(manipulatorUR_to_TCP , args[0], args[1], args[2], args[3], args[4], args[5]);
          state.set_pose_TCP_manipulator(args[0], args[1], args[2], args[3], args[4], args[5], 1.0);
        }
        state.set_valid(jointValid);
    }
    mobileState.set_manipulator_state(state);
    CommBasicObjects::CommBaseState baseState;
    if (params.getBase().getOn_base()) {
        if (baseStateServiceInGetUpdate(baseState) == Smart::SMART_OK) {
            mobileState.set_base_state(baseState);
        } else {
            mobileState.set_base_state(default_baseState);
            mobileState.set_valid(false);
        }
    } else {
        mobileState.set_base_state(default_baseState);
    }
}

int PoseUpdateActivity::on_entry() {
    return 0;
}

void PoseUpdateActivity::sendEvent(CommManipulatorObjects::ManipulatorEvent::ENUM_ManipulatorEvent event) {
    CommManipulatorObjects::CommManipulatorEventState state;
    state.setEvent(event);
    COMP->manipulatorEventServiceOut->put(state);
    std::cout << "sendEvent " << event << std::endl;
}

void PoseUpdateActivity::setGoalReached(bool reached) {
    if (goalReached == reached)
        return;
    goalReached = reached;
    sendEvent(reached ?
        CommManipulatorObjects::ManipulatorEvent::GOAL_REACHED :
        CommManipulatorObjects::ManipulatorEvent::GOAL_NOT_REACHED);
}

int PoseUpdateActivity::on_execute() {
    std::cout  << std::fixed << std::setprecision(5) << std::showpos;

    ParameterStateStruct params = COMP->getParameters();
    CommBasicObjects::CommBasePose default_base_position;
    default_base_position.set_x(0);
    default_base_position.set_y(0);
    default_base_position.set_z(0);
    CommBasicObjects::CommBaseVelocity zero_velocity;
    default_baseState.setBasePose(default_base_position);
    default_baseState.set_base_velocity(zero_velocity);

// ********** robot ***********
    std::string name = params.getWebots().getRobotName();
    char environment[256] = "WEBOTS_ROBOT_NAME=";
    putenv(strcat(environment, name.c_str()));
    std::cout << " \033[0;32mConnect to webots robot with name '" << name << "' ...\033[0m" << std::endl;
    Supervisor *robot = new Supervisor();
    if (!robot) {
        std::cerr << "Webots Robot '" << name << "' not found" << std::endl;
        return -1;
    }
    robotArmModel = robot->getModel();
    std::cout << "Robot '" << name << "' model=" << robotArmModel << std::endl;
    isNUE = robot->getRoot()->getField("children")->getMFNode(0)->getField("coordinateSystem")->getSFString() == "NUE";


// *********** VacuumGripper *********
    DistanceSensor *distanceSensor = robot->getDistanceSensor("VacuumGripperDistanceSensor");
    distanceSensor->enable(robot->getBasicTimeStep());

    Connector *connector = robot->getConnector("VacuumGripperConnectorName");
    connector->enablePresence(robot->getBasicTimeStep());
    Keyboard *keyboard = robot->getKeyboard();
    keyboard->enable(robot->getBasicTimeStep());
    bool isKeyboardControl = false;

// *********** joints *************
    std::string jointNames[nrJoints] = { "shoulder_pan_joint", "shoulder_lift_joint", "elbow_joint", "wrist_1_joint",
        "wrist_2_joint", "wrist_3_joint" };
    Motor *jointMotor[nrJoints];
    PositionSensor *jointSensor[nrJoints];

// ********** commObject *********
    webots::Node* commObject = robot->getFromDef("CommObject");
// ********** Depalettizing *******
    bool isDepalettizing = commObject != NULL;
    bool isPalettizing = robot->getName()=="UR10e2";
    if(isDepalettizing)
        isTcpMovement = true;

    // move  1) pos = palettCord + boxSize componentWiseProduct (boxNr + {0.5, 0.5, 1.0})
    //       2) pos += liftCoord
    //       3) pos[x,y] = horizontalCoord
    //       4) pos = endCoord, pos.z += boxSize.z
    // after reaching 1), turn on vacuum gripper
    // after reaching 4), turn off vacuum gripper, set boxNr to next box
    bool isMoveReached = false;
    int movePos = isPalettizing ? 4 : 2; // 1 - 4, see above
    int moveDirection = -1; // -1 = reverse movement, +1 = forward movement
    int boxNr[3] = {0, 0, 0};
    int boxCount[3] = {4, 4, 5};
    int boxTotalCount = 0;
    Eigen::Vector3d boxSize = {0.2, 0.3, 0.15};
    Eigen::Vector3d palettCoord = {0.35, -0.6, -0.5};
    Eigen::Vector3d startCoord = {0.45, -0.45, -0.35};
    Eigen::Vector3d liftCoord = {-0.02, -0.02, +0.04};
    Eigen::Vector2d horizontalCoord = {0.2, -0.5};
    Eigen::Vector3d endCoord = {0.15, -0.4, -0.5};
    if(isPalettizing) {
        boxNr[0] = -1; // first picked box will increase to 0
    }

    Trajectory firstPosition;
    firstPosition.time = 0.0;
    for (int i = 0; i < nrJoints; i++) {
        jointMotor[i] = robot->getMotor(jointNames[i]);
        jointSensor[i] = robot->getPositionSensor(jointNames[i] + "_sensor");
        if (!jointMotor[i] || !jointSensor[i]) {
            std::cerr << "Webots Motor or PositionSensor " << i << " not found";
            return -1;
        }
        jointSensor[i]->enable(robot->getBasicTimeStep());
    }
    // do one timeStep to get data from sensors
    // todo: use supervisor to read position without time delay
    robot->step(robot->getBasicTimeStep());
    // set trajectory to actual position (prevent special case of empty trajectory)
    std::cout << "initial joint positions:";
    for (int i = 0; i < nrJoints; i++) {
        firstPosition.jointTargetPosition[i] = jointSensor[i]->getValue();
        std::cout << " " << firstPosition.jointTargetPosition[i];
    }
    std::cout << std::endl;
    {
        std::unique_lock<std::mutex> lock(jointMutex);
        trajectory.insert(trajectory.begin(), firstPosition);
    }
    double jointTargetPosition[nrJoints];
    double timeSpend = 0.0; // the time already spend on actual trajectory point

    negativeJointAngles4 = true;
    bool debugMode = true;
    std::array<double,6> k = {0.45, -0.45, 0.60, 0.0, 0.0, -M_PI/2};

    char keyUp[6] =   {'Q', 'W', 'E', 'R', 'T', 'Z'};
    char keyDown[6] = {'A', 'S', 'D', 'F', 'G', 'H'};

    while (robot->step(robot->getBasicTimeStep()) != -1) {
        // TODO: remove (debug only)
        int key = keyboard->getKey();
        if (key == '0' || key == '1') {
            std::cout << "key=" << key << " presence=" << connector->getPresence() << "distance="
                << distanceSensor->getValue() << std::endl;
            if (key == '0') {
                connector->unlock();
                std::cout << "unlock" << std::endl;
            }
            else
                connector->lock();
            isVacuumOn = key == '1';
        }
        if (key == 'N' || key == 'P')
            negativeJointAngles4 = key == 'N';
        if (key == 'V' || key == 'B')
            isKeyboardControl = key == 'B';
        if (key == '+' || key == '-') {
            if(debugMode != (key == '+')) {
                debugMode = (key == '+');
                if(debugMode)
                    k = tcpPoseArgs;
                else
                    k = jointPosition;
            }
        }
        for(int i=6; i--;)
            if(key == keyUp[i])
                k[i] += 0.01;
            else if(key==keyDown[i])
                k[i] -= 0.01;
        Program program = newProgram;
        // read jointPosition, calculate new jointTargetPosition based on time
        { // start mutex
            std::unique_lock<std::mutex> lock(jointMutex);
            for (int i = 0; i < nrJoints; i++)
                jointPosition[i] = jointSensor[i]->getValue();
            jointValid = true;
            // (position relative to world) =  Matrix * (position relative to arm)
            webots::Node* tcpNode;
            // a receiver node is used to detect TCP positions
            // (add an invisible receiver node in webots robot arm, e.g. in the tool)
            webots::Receiver* receiver = robot->getReceiver("receiver");
            if(receiver)
                tcpNode = robot->getFromDevice(receiver);
            if(!tcpNode) {
                std::cerr << "no receiver found to detect TCP pose" << std::endl;
                return -1;
            }

            // pose of robot arm in world frame
            Eigen::MatrixXd world_to_arm = getPoseMatrixFromWebotsNode(robot->getSelf());
            // pose of world in robot arm frame
            Eigen::MatrixXd arm_to_world = getInversePoseMatrix(world_to_arm);
            // pose of tool slot in world frame
            Eigen::MatrixXd world_to_toolSlot = getPoseMatrixFromWebotsNode(tcpNode);
            // pose of toolSlot in robot arm frame
            Eigen::MatrixXd actualTcpPoseMatrix = arm_to_world * world_to_toolSlot;
            getEulerAnglesFromPoseMatrix(actualTcpPoseMatrix , tcpPoseArgs[0], tcpPoseArgs[1], tcpPoseArgs[2], tcpPoseArgs[3], tcpPoseArgs[4], tcpPoseArgs[5]);

            if (program == prNeutral)
                continue; // tcpPose is updated, but no movement done

            if(isDepalettizing) {
                if(isMoveReached) { // goal was reached
                    if(isPalettizing && movePos==4 && (connector->getPresence()==0 || !commObject->getField("isBoxPresent")->getSFBool()))
                        continue; // wait while no box present
                    if(!isPalettizing && movePos==2 && moveDirection==+1 && commObject->getField("isBoxPresentStart")->getSFBool())
                        continue; // wait while box is present
                    isMoveReached = false;
                    if(movePos == 1 || movePos == 4) {
                        if(movePos == 4) {
                            boxTotalCount += 1;
                            for(int i=0; i<3; i++) {
                                int j = boxNr[i] + 1;
                                if(j < boxCount[i]) {
                                    boxNr[i] = j;
                                    break;
                                }
                                boxNr[i] = 0;
                                if(i==2)
                                    isDepalettizing = false;
                            }
                        }
                        isVacuumOn =  (movePos == (isPalettizing ? 4 : 1));
                        moveDirection = movePos == 1 ? 1 : -1;
                    }
                    movePos += moveDirection;
                    std::cout << webots::AnsiCodes::GREEN_FOREGROUND << "movePos = " << movePos << " " << moveDirection << " boxNr " <<
                        lround(boxNr[0]) << " " << lround(boxNr[1]) << " " << lround(boxNr[2]) <<
                        " boxTotalCount " << boxTotalCount << webots::AnsiCodes::RESET << std::endl;
                }

                Eigen::Vector3d pos;
                // reverse direction in case of isPalettizing
                int _boxNr[3];
                for(int i=3; i--;)
                    _boxNr[i] = isPalettizing ? boxCount[i]-1-boxNr[i] : boxNr[i];
                Eigen::Vector3d boxNrVec = {0.5 + _boxNr[0], 0.5 + _boxNr[1], 0.0 + boxCount[2] - _boxNr[2]};
                pos = palettCoord + boxSize.cwiseProduct(boxNrVec);
                if(movePos >= 2)
                    pos += liftCoord;
                if(movePos >= 3)
                    pos.head<2>() =  horizontalCoord;
                if(movePos >= 4) {
                    pos = endCoord;
                    pos(2) += boxSize(2);
                }
//                pos(2) += 0.02; // lift/drop from 2cm above box
                targetTcpPoseMatrix = getPoseMatrixFromEulerAngles(pos(0), pos(1), pos(2), 0.0, 0.0, -M_PI/2);
            }

            if(isTcpMovement || isDepalettizing) {
                // Ansi HOME
                std::cout << /* "\x1b[H" << AnsiCodes::CLEAR_SCREEN << */ "isKeyboardControl: " << isKeyboardControl << " negativeJointAngles4: " << negativeJointAngles4 << " debugMode: " << debugMode << std::endl;
                // ManipulatorTrajectoryFlag = POSE_TCP
/*
                for(int i=0; i<=6; i++) {
                    webots::Node* node = robot->getFromDef("P"+std::to_string(i));
                    Eigen::MatrixXd matrix = invArmMatrix * getPoseMatrixFromWebotsNode(node);
                    realP[i] = matrix.block<3,1>(0,3).transpose();
                }
*/
                double actual2targetDistance = 0;
                for(int i=3; i--;) {
                    double tmp = targetTcpPoseMatrix(i,3) - actualTcpPoseMatrix(i,3);
                    actual2targetDistance += tmp*tmp;
                }
                actual2targetDistance = sqrt(actual2targetDistance);
                if(actual2targetDistance == 0)
                    actual2targetDistance = 0.0000000001;
                double distanceDivision = params.getManipulator().getTcp_velocity() * (robot->getBasicTimeStep() / 1000.0) / actual2targetDistance;
                if(distanceDivision >= 0.999) {
                    distanceDivision = 1.0;
                    if(isDepalettizing)
                        isMoveReached = true;
                    else
                        setGoalReached(true);
                    std::cout << webots::AnsiCodes::GREEN_FOREGROUND << "GOAL REACHED" << webots::AnsiCodes::RESET << std::endl;
                }
                if(isKeyboardControl)
                  distanceDivision = 1.0;

                // smoothly rotate from actual TCP pose to target TCP pose:
                // https://en.wikipedia.org/wiki/Slerp
                // interpolate between quaternion(start point) and quaternion(end point):
                // https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/index.htm

                Eigen::MatrixXd newTcpPoseMatrix = (actualTcpPoseMatrix * (1.0-distanceDivision)) + (targetTcpPoseMatrix * distanceDivision);
                Eigen::Quaterniond qa, qb;
                qa = getQuaternionFromPoseMatrix(actualTcpPoseMatrix);
                qb = getQuaternionFromPoseMatrix(targetTcpPoseMatrix);
                newTcpPoseMatrix.block<3,3>(0,0) = qa.slerp(distanceDivision, qb).toRotationMatrix();

                if(isKeyboardControl) {
                    // for testing only: set a fixed TCP Pose directly, keyboard control
                    newTcpPoseMatrix = actualTcpPoseMatrix;
                    if(debugMode) {
                        newTcpPoseMatrix = getPoseMatrixFromEulerAngles(k[0], k[1], k[2], k[3], k[4], k[5]);
                        std::cout << "newTcpPoseMatrix: " << std::endl << newTcpPoseMatrix;
                    }
                } else {
                    std::cout << "actualTcpPoseMatrix: " << std::endl << actualTcpPoseMatrix << std::endl <<
                        "targetTcpPoseMatrix: " << std::endl << targetTcpPoseMatrix << std::endl <<
                        "newTcpPoseMatrix: " << std::endl << newTcpPoseMatrix << std::endl <<
                        "actual2targetDistance: " << actual2targetDistance <<
                        " distanceDivision: " << distanceDivision << std::endl;
                }
                std::array<double, 6> jointAngles;
                int errorLine = getJointAnglesFromToolSlotPoseMatrix(newTcpPoseMatrix, jointAngles);
                // sometimes joint angles jump by 360° => if old angle - new angle = 360° then new_angle += 360° (if possible)
                for(int i=0; i<6; i++) {
                    double tmp = jointAngles[i] - jointPosition[i];
                    if(fabs(tmp) > M_PI) {
                        if(tmp > 0)
                            tmp = 2*M_PI;
                        else
                            tmp = -2*M_PI;
                        tmp = jointAngles[i] - tmp;
                        if(fabs(tmp)<(i==2 ? M_PI : 2*M_PI)) {
                            std::cout << webots::AnsiCodes::CYAN_FOREGROUND << "  jointAngles[" << i << "] from " << jointAngles[i] << " to " << tmp << webots::AnsiCodes::RESET << std::endl;
                            jointAngles[i] = tmp;
                        }
                    }
                }
                std::cout << "real angles:";
                for(int i=0; i<6; i++)
                    std::cout << " " << i << ":" << jointPosition[i];
                std::cout << std::endl << "calc angles:";
                for(int i=0; i<6; i++) {
                    double error = fabs(jointPosition[i] - jointAngles[i]);
                    std::string color = "";
                    if(error > M_PI) {
                        error = fabs(error - 2*M_PI);
                        color = AnsiCodes::YELLOW_FOREGROUND;
                    }
                    if(error > 0.001)
                        color = AnsiCodes::RED_FOREGROUND;
                    std::cout << " " << i << ":" << color << jointAngles[i] << AnsiCodes::RESET;
                }
                std::cout << std::endl << "keyboard   :";
                for(int i=0; i<6; i++) {
                    double error = k[i] - (debugMode ? tcpPoseArgs[i] : jointPosition[i]);
                    std::cout << " " << i << ":" <<
                        ( fabs(error)>0.001 ? AnsiCodes::RED_FOREGROUND : "") <<
                        k[i] << AnsiCodes::RESET;
                }
                std::cout << std::endl << "tcpPoseArgs:";
                for(int i=0; i<6; i++)
                    std::cout << " " << i << ":" << tcpPoseArgs[i];
                std::cout << std::endl;
                for(int i=0; i<6; i++)
                    if(!isKeyboardControl || debugMode)
                        jointTargetPosition[i] = jointAngles[i];
                    else
                        jointTargetPosition[i] = k[i];
                if(errorLine != 0) {
                    std::cout << AnsiCodes::RED_FOREGROUND << "getJointAnglesFromToolSlotPoseMatrix() failed: " << errorLine << AnsiCodes::RESET << std::endl;
                    continue; // don't move arm
                }

            } else {
                // ManipulatorTrajectoryFlag = JOINT_ANGLES
                timeSpend += robot->getBasicTimeStep() / 1000.0;
                if (trajectory.size() > 1)
                    setGoalReached(false);
                while (trajectory.size() > 1 && timeSpend > trajectory[1].time) {
                    std::cout << "trajectory done: time=" << trajectory[0].time;
                    for (int i = 0; i < nrJoints; i++) {
                        std::cout << " " << i << ":" << trajectory[0].jointTargetPosition[i];
                    }
                    std::cout << std::endl;
                    timeSpend -= trajectory[1].time;
                    trajectory.erase(trajectory.begin());
                }
                if (trajectory.size() == 1) {
                    for (int i = 0; i < nrJoints; i++)
                        jointTargetPosition[i] = trajectory[0].jointTargetPosition[i];
                    timeSpend = 0.0;
                    bool isReached = true;
                    for (int i = 0; i < nrJoints; i++)
                        if (std::abs(jointTargetPosition[i] - jointPosition[i]) > 0.002)
                            isReached = false;
                    if (isReached)
                        setGoalReached(true);
                } else {
                    double timeQuotient = timeSpend / trajectory[1].time;
                    for (int i = 0; i < nrJoints; i++)
                        jointTargetPosition[i] = trajectory[0].jointTargetPosition[i] * (1.0 - timeQuotient)
                            + trajectory[1].jointTargetPosition[i] * timeQuotient;
                }
            }
        } // end mutex

        for (int i = 0; i < nrJoints; i++)
            jointMotor[i]->setPosition(jointTargetPosition[i]);

        // distance sensor is at 0.001m in front of vacuum gripper
        // only grip if distance from vacuum gripper to box is less then 0.1m

        if (isVacuumOn && distanceSensor->getValue() < 0.099)
            connector->lock();
        if (!isVacuumOn)
            connector->unlock();
/*
        if (params.getManipulator().getVerbose()) {
            std::cout << "program=" << program;
            for (int i = 0; i < nrJoints; i++)
                std::cout << " " << i << ":" << jointPosition[i];
            std::cout << " vacuum:" << isVacuumOn << std::endl;
        }
*/

        CommManipulatorObjects::CommMobileManipulatorState mobileState;
        getMobileManipulatorState(mobileState);
        this->posePushServerPut(mobileState);
    }
    delete robot;
    return 1; // webots world has ended, stop thread
}

int PoseUpdateActivity::on_exit() {
    return 0;
}
