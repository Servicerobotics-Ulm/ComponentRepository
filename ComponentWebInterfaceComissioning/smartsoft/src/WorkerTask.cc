//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "WorkerTask.hh"
#include "ComponentWebInterfaceComissioning.hh"

#include <iostream>

WorkerTask::WorkerTask(SmartACE::SmartComponent *comp) 
:	WorkerTaskCore(comp)
{
	std::cout << "constructor WorkerTask\n";
}
WorkerTask::~WorkerTask() 
{
	std::cout << "destructor WorkerTask\n";
}

int WorkerTask::error(std::string msg)
{
	std::cerr << "ERROR: " << msg << std::endl;
	return 0;
}

int WorkerTask::on_entry()
{

	connections = 0;
	std::cout << "Starting the server..." << std::endl;

	if(server_addr.set(COMP->getGlobalState().getSettings().getWorkerServerPort()) == -1){
		error("Error on set!");
		std::cout << "Erron no : " <<errno << std::endl;
		return 1;
	}
	if(acceptor.open(server_addr) == -1){
		std::cout << "Erron no : " <<errno << std::endl;
		error("Error on open!");
		return 1;
	}

	job_id = 1;

	return 0;
}
int WorkerTask::on_execute()
{
	std::cout << "Waiting for request..." << std::endl;
	if (acceptor.accept(peer) == -1){
		std::cout << "Erron no : " <<errno << std::endl;
		error( "Error on accept!");
	}else{
		std::cout << "Request accepted" << std::endl;
	}
	peer.disable (ACE_NONBLOCK);
	 // ip-filter: als addresse immer localhost angeben dass es funzt, nicht den umweg auf die ip "von aussen"!
	ACE_INET_Addr client_addr;
	peer.get_remote_addr(client_addr);
	std::string a = "localhost";
	std::string b = client_addr.get_host_name();
//	if(a != b){
	if(false){
		error("Client is NOT localhost, closing connection!");
		std::cout << std::endl << std::endl;
	}else{
	    memset(buffer,0,sizeof(buffer));
	    messageSize = peer.recv(buffer, sizeof(buffer));
	    if(messageSize <0){
	    	error("Error reading from socket");
	    }
	    std::string in(buffer);
	    std::cout << ++connections << ". client message is: '" << in << "'" << std::endl;


	    std::vector<std::string> parameters;
	    std::stringstream request(buffer);
	    std::string cur;
	    while(std::getline(request, cur, ';')) {
	    	if(cur.length() > 0)
	    		parameters.push_back(cur);
	    	else
	    		parameters.push_back("");
	    }

		std::cout << "Request received with following values: " << std::endl;
	    for(std::vector<std::string>::iterator it = parameters.begin(); it < parameters.end(); it++) {
	    	std::cout << " - " << *it << std::endl;
	    }





	    ////////////////////////////////////////////////////////////////////////
	    // PROCESS REQUESTS FROM UI AFTER HERE:
	    ////////////////////////////////////////////////////////////////////////
	    if(parameters[0] == "AUTH") {
	    	std::cout << "Auth request: " << std::endl;

	    	if(parameters.size() != 3) {
	    		std::cout << "ERROR: invalid auth request! (Number of parameters)" << std::endl;
	    	    peer.close();
	    		return 0;
	    	}

		    std::cout << "User:     " << parameters[1] << std::endl;
		    std::cout << "Password: '" << parameters[2] << "'" << std::endl;
/*
		    // QUERY AUTH COMPONENT HERE
		    CommIndoorOutdoorNavigationObjects::CommAuthenticationRequest commRequest;
		    CommIndoorOutdoorNavigationObjects::CommAuthenticationResponse commResponse;

		    commRequest.setUsername(parameters[1]);
		    commRequest.setPassword(parameters[2]);
		    CHS::StatusCode status = COMP->authenticationRequestor->query(commRequest, commResponse);
		    std::string response("NACK");
		    if(status == CHS::SMART_OK) {
		    	if(commResponse.getAccessGranted()) {
		    		response = "ACK";
		    		COMP->setUserName(parameters[1]);
		    	}
		    } else {
		    	std::cout << "Error communicating with authentication component" << std::endl;
		    }

		    std::cout << "response is " << response << std::endl;

		    char* bufferOut;
		    bufferOut = new char[response.length()];
		    strcpy(bufferOut, response.c_str());
		    if(peer.send_n(bufferOut, response.length()) == -1){
		    	error("Error on send_n");
		    }
		    delete bufferOut;
		    if (messageSize < 0) error("ERROR writing to socket");
		    std::cout << std::endl;
*/




		////////////////////////////////////////////////////////////////////////
	    } else if (parameters[0] == "PLAN") {
	    	std::cout << "Path planning request received: " << std::endl;

	    	if(parameters.size() != 5) {
	    		std::cout << "ERROR: invalid planning request. (Number of parameters)" << std::endl;
	    	    peer.close();
	    		return 0;
	    	}

	    	std::cout << "Symbolic name of destination: " << parameters[1] << std::endl;
	    	std::cout << "x coordinate of destination:  " << atof(parameters[2].c_str()) << std::endl;
	    	std::cout << "y coordinate of destination:  " << atof(parameters[3].c_str()) << std::endl;
	    	std::cout << "z coordinate of destination:	" << atof(parameters[4].c_str()) << std::endl;

	/*
	    	CommIndoorOutdoorNavigationObjects::CommPosition commPosition;
	    	commPosition.setX(atof(parameters[2].c_str()));
	    	commPosition.setY(atof(parameters[3].c_str()));
	    	commPosition.setZ(atof(parameters[4].c_str()));
	    	commPosition.setIs_valid(true);


	    	CommIndoorOutdoorNavigationObjects::CommDestination commDestination;
	    	commDestination.setUsername(COMP->getUserName());
	    	commDestination.setDestination(commPosition);

	    	CHS::StatusCode status = COMP->destinationPushNewestServer->put(commDestination);
	    	if(status != CHS::SMART_OK) {
	    		std::cout << "Error sending destination request: " << CHS::StatusCodeConversion(status) << std::endl;
	    	}
	    	COMP->newDestinationMutex.acquire();
	    	COMP->newDestination = true;
	    	COMP->newDestinationMutex.release();

	    	COMP->sendInstructionsMutex.acquire();
	    	COMP->sendInstructions = false;
	    	COMP->sendInstructionsMutex.release();

	    	COMP->systemDataMutex.acquire();
	    	COMP->systemData.status = "example status: Destination received...";
	    	COMP->systemDataMutex.release();
*/


	    ////////////////////////////////////////////////////////////////////////
	    }  else if (parameters[0] == "STOP") {
	    	std::cout << "STOP received." << std::endl;

/*
	    	COMP->sendInstructionsMutex.acquire();
	    	COMP->sendInstructions = false;
	    	COMP->sendInstructionsMutex.release();
	    	if(COMP->getGlobalState().getSettings().getUseNavigationInstructions()){
	    		CommSpeechObjects::CommSpeechOutputMessage message("navigation canceled.");
	    		CHS::StatusCode status = COMP->navInstructionsSendClient->send(message);
	    		if(status != CHS::SMART_OK) {
	    			std::cout << "Error sending navigation instructions: " << CHS::StatusCodeConversion(status) << std::endl;
	    		}
	    	}
	    	std::cout << "STOP signal received." << std::endl;
	    	CommIndoorOutdoorNavigationObjects::CommDestination commDestination;
	    	CommIndoorOutdoorNavigationObjects::CommPosition commPosition;
	    	commPosition.setIs_valid(false);
	    	commDestination.setDestination(commPosition);
	    	CHS::StatusCode status = COMP->destinationPushNewestServer->put(commDestination);
	    	COMP->systemDataMutex.acquire();
	    	COMP->systemData.status = "Component RUNNING";
	    	COMP->systemDataMutex.release();
	    	*/
		    ////////////////////////////////////////////////////////////////////////
		    }  else if (parameters[0] == "ORDER") {
//		    	COMP->sendInstructionsMutex.acquire();
//		    	COMP->sendInstructions = false;
//		    	COMP->sendInstructionsMutex.release();


		    	std::cout << "ORDER received." << std::endl;

			    for(std::vector<std::string>::iterator it = parameters.begin()+1; it < parameters.end(); it++) {
			    	std::cout << "- " << *it;
			    	it++;
			    	std::cout << "x" << *it<< std::endl;
			    }


			    std::stringstream sstr;

//			    PushJob RobotCommissioning JOBID PRIORITY Transportation ROBOTINOID COMMISSIONINGROBOT FROMSTATION FROMBELT TOSTATION TOBELT [ORDER_ITEM QUANTITY]+
// Examples:    PushJob RobotCommissioning 1 0 -1 99 6 0 1 5 1 0 SMACKS 2 CORN-FLAKES 2
//			    PushJob RobotCommissioning 2 0 -1 99 6 0 1 5 1 0 FROSTIES 1 SPECIAL 1 CHOCO 1
			    sstr << "PushJob RobotCommissioning "<< job_id++ <<" 0 -1 1 6 0 1 5 1 0 ";
			    for(std::vector<std::string>::iterator it = parameters.begin()+1; it < parameters.end(); it++) {
			    	sstr << *it << " ";
			    	it++;
			    	sstr << *it << " ";
			    }

			    std::cout << "TCL:"<< "(" << sstr.str() <<")"<< std::endl;
			    CommBasicObjects::CommSkillMsg tcl;
			    tcl.setMsg("(" + sstr.str() + ")");

			    Smart::StatusCode status = COMP->sequencerEventServer->put(tcl);
			    if(status != Smart::SMART_OK) {
			    	std::cout << "## ERROR PUT: " << Smart::StatusCodeConversion(status) << std::endl;
			    } else {
			    	std::cout << "put() done" << std::endl;
			    }


		    	COMP->systemDataMutex.acquire();
		    	COMP->systemData.status = "Component RUNNING";
		    	COMP->systemDataMutex.release();
	    } else if (parameters[0] == "InitFollow") {
	    	std::cout << "InitFollow received." << std::endl;

//	   		for(std::vector<std::string>::iterator it = parameters.begin()+1; it < parameters.end(); it++) {
//	    		std::cout << "- " << *it;
//	    		it++;
//	    		std::cout << "x" << *it<< std::endl;
//	    	}

	    	std::stringstream sstr;

	    	sstr << "PushJob InitFollow " << job_id++ <<" 0 -1 ";

	    	std::cout << "TCL:"<< "(" << sstr.str() <<")"<< std::endl;
	    	CommBasicObjects::CommSkillMsg tcl;
	    	tcl.setMsg("(" + sstr.str() + ")");

			Smart::StatusCode status = COMP->sequencerEventServer->put(tcl);
			if(status != Smart::SMART_OK) {
				std::cout << "## ERROR PUT: " << Smart::StatusCodeConversion(status) << std::endl;
			} else {
				std::cout << "put() done" << std::endl;
			}

			COMP->systemDataMutex.acquire();
			COMP->systemData.status = "Component RUNNING";
			COMP->systemDataMutex.release();
		} else if (parameters[0] == "FOLLOWPERSON") {
	    	std::cout << "FOLLOWPERSON received." << std::endl;

//	   		for(std::vector<std::string>::iterator it = parameters.begin()+1; it < parameters.end(); it++) {
//	    		std::cout << "- " << *it;
//	    		it++;
//	    		std::cout << "x" << *it<< std::endl;
//	    	}

	    	std::stringstream sstr;

	    	// PushJob RobotFollow JOBID PRIORITY ROBOTINOID PERSONID

	    	sstr << "UpdateJob FollowPerson "<< job_id <<" 0 -1 " << parameters[1];

	    	std::cout << "TCL:"<< "(" << sstr.str() <<")"<< std::endl;
	    	CommBasicObjects::CommSkillMsg tcl;
	    	tcl.setMsg("(" + sstr.str() + ")");

	    	Smart::StatusCode status = COMP->sequencerEventServer->put(tcl);
			if(status != Smart::SMART_OK) {
				std::cout << "## ERROR PUT: " << Smart::StatusCodeConversion(status) << std::endl;
			} else {
				std::cout << "put() done" << std::endl;
			}

			COMP->systemDataMutex.acquire();
			COMP->systemData.status = "Component RUNNING";
			COMP->systemDataMutex.release();
		}else if (parameters[0] == "STOPFOLLOWPERSON") {
	    	std::cout << "STOPFOLLOWPERSON received." << std::endl;

//	   		for(std::vector<std::string>::iterator it = parameters.begin()+1; it < parameters.end(); it++) {
//	    		std::cout << "- " << *it;
//	    		it++;
//	    		std::cout << "x" << *it<< std::endl;
//	    	}

	    	std::stringstream sstr;

	    	sstr << "UpdateJob STOPFOLLOWPERSON";

	    	std::cout << "TCL:"<< "(" << sstr.str() <<")"<< std::endl;
	    	CommBasicObjects::CommSkillMsg tcl;
	    	tcl.setMsg("(" + sstr.str() + ")");

			Smart::StatusCode status = COMP->sequencerEventServer->put(tcl);
			if(status != Smart::SMART_OK) {
				std::cout << "## ERROR PUT: " << Smart::StatusCodeConversion(status) << std::endl;
			} else {
				std::cout << "put() done" << std::endl;
			}

			COMP->systemDataMutex.acquire();
			COMP->systemData.status = "Component RUNNING";
			COMP->systemDataMutex.release();
		} else if (parameters[0] == "Deliver") {
	    	std::cout << "Deliver received." << std::endl;

//	   		for(std::vector<std::string>::iterator it = parameters.begin()+1; it < parameters.end(); it++) {
//	    		std::cout << "- " << *it;
//	    		it++;
//	    		std::cout << "x" << *it<< std::endl;
//	    	}

	    	std::stringstream sstr;

	    	// PushJob RobotFollow JOBID PRIORITY ROBOTINOID PERSONID

	    	sstr << "UpdateJob GotoPosition"<< " delivery-station";

	    	std::cout << "TCL:"<< "(" << sstr.str() <<")"<< std::endl;
	    	CommBasicObjects::CommSkillMsg tcl;
	    	tcl.setMsg("(" + sstr.str() + ")");

	    	Smart::StatusCode status = COMP->sequencerEventServer->put(tcl);
			if(status != Smart::SMART_OK) {
				std::cout << "## ERROR PUT: " << Smart::StatusCodeConversion(status) << std::endl;
			} else {
				std::cout << "put() done" << std::endl;
			}

			COMP->systemDataMutex.acquire();
			COMP->systemData.status = "Component RUNNING";
			COMP->systemDataMutex.release();
		} else {
			std::cout << "Unrecognized parameter." << std::endl;
		}



	}

    std::cout << std::endl << std::endl;

    peer.close();
	return 0;
}
int WorkerTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
