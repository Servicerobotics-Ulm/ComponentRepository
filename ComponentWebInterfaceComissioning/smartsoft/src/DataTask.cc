//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2015 Dennis Stampfer, Sandra Frank
//
//        Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "DataTask.hh"
#include "ComponentWebInterfaceComissioning.hh"

#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <time.h>
#include <ctime>
#include <mrpt/gui.h>
#ifdef WITH_MRPT_2_0_VERSION
#else
#include <mrpt/utils.h>
using namespace mrpt::utils;
#endif

using namespace mrpt;
using namespace mrpt::gui;
using namespace mrpt::math;


DataTask::DataTask(SmartACE::SmartComponent *comp) 
:	DataTaskCore(comp)
{
	std::cout << "constructor DataTask\n";
}
DataTask::~DataTask() 
{
	std::cout << "destructor DataTask\n";
}



int DataTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int DataTask::on_execute()
{
	Smart::StatusCode status;


	// collect all data here:
	int random = rand() % 360 + 1;



/**********************
	// get map
	// attention: do we have to get the map every task cycle or only once and then store it locally?
	CommIndoorOutdoorNavigationObjects::CommRasterMap rasterMap;
	CommIndoorOutdoorNavigationObjects::CommRasterMapRequest rasterMapRequest;
	// TODO: fill object raster map request here.
	// blocking call to query: query() will only return when there is an answer.
	status = COMP->rasterMapRequestor->query(rasterMapRequest, rasterMap);
	if(status != CHS::SMART_OK) {
		std::cout << "ERROR GETTING raster map: " << CHS::StatusCodeConversion(status) << std::endl;
	} else {
		std::cout << "Raster Map Reply: " << rasterMap << std::endl;
	}
********************/



//	// get Location
//	CommIndoorOutdoorNavigationObjects::CommLocation location;
//	status = COMP->locationRequestor->getUpdate(location);
//	if(status != CHS::SMART_OK) {
//		std::cout << "ERROR GETTING location: " << CHS::StatusCodeConversion(status) << std::endl;
//	} else {
//		std::cout << "location: " << location << std::endl;
////		std::cout << "Pose ok" << std::endl;
//	}

	//getOrientation
//	CommBasicObjects::CommIMUData imuData;
//	if(COMP->getGlobalState().getSettings().getUseImuData()){
//		std::cout << "getting imuData ..." << std::endl;
//		status = COMP->imuDataPushTimedClient->getUpdateWait(imuData);
//		if(status != CHS::SMART_OK) {
//			std::cout << "ERROR GETTING imuData: " << CHS::StatusCodeConversion(status) << std::endl;
//		} else {
//			std::cout << "imuData: " << imuData << std::endl;
//		}
//	}



//	if(COMP->newDestination){
//		sleep(1);
//		COMP->newDestinationMutex.acquire();
//		COMP->newDestination = false;
//		COMP->newDestinationMutex.release();
//		COMP->sendInstructionsMutex.acquire();
//		COMP->sendInstructions = true;
//		COMP->sendInstructionsMutex.release();
//		instruction = "";
//	}


	// get path
//	CommIndoorOutdoorNavigationObjects::CommPath commPath;
//	status = COMP->pathRequestor->getUpdate(commPath);
//	if(status != CHS::SMART_OK) {
//		std::cout << "ERROR GETTING path: " << CHS::StatusCodeConversion(status) << std::endl;
//	}

	//Destination reached -> send invalid destination and change system status to "Component RUNNING"
//	if(commPath.getWaypointsSize() == 0 && COMP->systemData.status.compare("example status: Destination received...") == 0){
//		CommIndoorOutdoorNavigationObjects::CommDestination commDestination;
//		CommIndoorOutdoorNavigationObjects::CommPosition commPosition;
//		commPosition.setIs_valid(false);
//		commDestination.setDestination(commPosition);
//		CHS::StatusCode status = COMP->destinationPushNewestServer->put(commDestination);
//		COMP->systemDataMutex.acquire();
//		COMP->systemData.status = "Component RUNNING";
//		COMP->systemDataMutex.release();
//	}

	/*
	// TODO: PROGRESS PATH!
	float nav = 0.0;

		if(mapImages.find(location.getPosition().getZ()) != mapImages.end()){
			filename = mapImages.find(location.getPosition().getZ())->second;
		}
		std::cout << "MAP: " << filename << std::endl;

		//calculate navigation angle (Angle between current orientation and next waypoint)
		std::vector<CommIndoorOutdoorNavigationObjects::CommPosition> waypoints = commPath.getWaypointsCopy();
		if(waypoints.size() > 0){
			CommIndoorOutdoorNavigationObjects::CommPosition pos = *waypoints.begin();
			float x = pos.getX() - location.getPosition().getX();
			float y = pos.getY() - location.getPosition().getY();
			float orientation_angle = 0;
			if(COMP->getGlobalState().getSettings().getUseImuData()){
				orientation_angle = imuData.getYaw();
			}else{
				orientation_angle = location.getOrientation().getYaw() * 180/M_PI;
			}
			if(orientation_angle < 0){
				orientation_angle = orientation_angle + 360;
			}

			float x_orientation = cos((orientation_angle + COMP->getGlobalState().getSettings().getOrientation())*M_PI/180);
			float y_orientation = sin((orientation_angle + COMP->getGlobalState().getSettings().getOrientation())*M_PI/180);

			nav = acos((x*x_orientation + y*y_orientation)/(sqrt(pow(x,2)+pow(y,2))*sqrt(pow(x_orientation,2)+pow(y_orientation,2))))*180/M_PI;//Skalarprodukt
			if((x*y_orientation - y*x_orientation) <= 0){ //Kreuzprodukt
				nav = 360 - nav;
			}
		}



	//derive navigation instructions from navigation angle
	if(COMP->getGlobalState().getSettings().getUseNavigationInstructions()){

		oldInstruction = instruction;;
		if(commPath.getWaypointsCopy().size() > 0){
			int angle = (int)(360 + nav) % 360;
			if(commPath.getWaypointsCopy().begin()->getZ() < location.getPosition().getZ()){
				instruction = "Go downstairs.";
			}else if(commPath.getWaypointsCopy().begin()->getZ() > location.getPosition().getZ()){
				instruction = "Go upstairs.";
			}else if(45 >= angle || angle > 315){	//same floor
				instruction = "Keep straight on.";
			}else if(angle > 45 && angle <= 135){
				instruction = "Turn right.";
			}else if(angle > 135 && angle <= 225){
				instruction = "Turn around.";
			}else if(angle > 225 && angle <= 315){
				instruction = "Turn left.";
			}
		}else{
			instruction = "You have reached your destination.";
		}

		if(COMP->sendInstructions && instruction.compare(oldInstruction) != 0){	//send navigation instruction
			CommSpeechObjects::CommSpeechOutputMessage message(instruction);
			CHS::StatusCode status = COMP->navInstructionsSendClient->send(message);
			if(status != CHS::SMART_OK) {
				std::cout << "Error sending navigation instructions: " << CHS::StatusCodeConversion(status) << std::endl;
			}
		}
	}

	//current location to pixel
	std::pair<float,float> location_px = toPixel(location.getPosition());

*/

	// make data available to JSON via file:
	std::stringstream ss;
	ss << COMP->getGlobalState().getSettings().getWwwRoot() << "/data.json";

	std::ofstream myfile;
	myfile.open(ss.str().c_str());
	COMP->systemDataMutex.acquire();
	myfile 	<< "{"
			<< "\"timestamp\" : \"" << std::time(0) << "\","
			<< "\"random\": \"" << random <<"\","
			<< "\"status\": \"" << COMP->systemData.status <<"\","
//			<< "\"nextWaypoint\": \"" << nav << "\","
//			<< "\"location_x\": \"" << location.getPosition().getX() <<"\","
//			<< "\"location_y\": \"" << location.getPosition().getY() <<"\","
//			<< "\"location_z\": \"" << location.getPosition().getZ() <<"\","
//			<< "\"map\": \"" << filename <<"\","
//			<< "\"location_px\": [\"" << location_px.first <<"\", \"" << location_px.second << "\"],"
//			<< "\"orientation\": \"";
			;


//	if(COMP->getGlobalState().getSettings().getUseImuData()){
//		myfile << imuData.getYaw() + COMP->getGlobalState().getSettings().getOrientation() + COMP->getGlobalState().getSettings().getRotation() - 90 <<"\",";
//	}else{
//		myfile << location.getOrientation().getYaw() * 180/M_PI + COMP->getGlobalState().getSettings().getOrientation() + COMP->getGlobalState().getSettings().getRotation() - 90 <<"\",";
//	}
//	myfile << "\"path\": [";
//	waypoints = commPath.getWaypointsCopy();
//	for(std::vector<CommIndoorOutdoorNavigationObjects::CommPosition>::iterator it = waypoints.begin(); it != waypoints.end(); it++){
//		if(it != waypoints.begin()){
//			myfile << ",";
//		}
//		std::pair<float,float> it_px = toPixel(*it);
//		myfile << "[\"" << it_px.first << "\", \"" << it_px.second << "\", \"" << it->getZ() << "\"]";
//	}
//	myfile << "]}";

	COMP->systemDataMutex.release();
	myfile.close();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int DataTask::on_exit()
{
	std::stringstream ss;
	ss << COMP->getGlobalState().getSettings().getWwwRoot() << "/data.json";

	std::ofstream myfile;
	myfile.open(ss.str().c_str());
	myfile 	<< "{"
			<< "\"timestamp\" : \"" << std::time(0) << "\","
			<< "\"status\": \"" << "Component SHUT DOWN" <<"\""
			<< "}";
	myfile.close();


	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
