//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "PackingTask.hh"
#include "ComponentSlcPacking.hh"

#include <iostream>
#include <sstream>
#include <string>
#include <stdlib.h> // required for random number
#include <cmath>

#include <pcl/pcl_base.h>
//#include <pcl/sample_consensus/ransac.h>
//#include <pcl/sample_consensus/sac_model_normal_plane.h>
//#include <pcl/features/integral_image_normal.h>
//#include <pcl/features/normal_3d.h>
#include <pcl/kdtree/kdtree_flann.h>
#include <pcl/filters/passthrough.h>
#include <pcl/surface/concave_hull.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/search/kdtree.h>

#include <pcl/ModelCoefficients.h>
#include <pcl/point_types.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/segmentation/extract_clusters.h>
#include <pcl/common/copy_point.h>

#include "mrpt/math/include/mrpt/math/TPose3D.h"
#include "mrpt/math/include/mrpt/math/TPose2D.h"
#include "mrpt/math/include/mrpt/math/TPoint2D.h"
#include "mrpt/math/include/mrpt/math/TPoint3D.h"
#include "mrpt/math/include/mrpt/math/TLine2D.h"
#include "mrpt/math/include/mrpt/math/TLine3D.h"
#include "mrpt/math/include/mrpt/math/TObject3D.h"
#include "mrpt/poses/include/mrpt/poses/CPose3D.h"
#include "mrpt/poses/include/mrpt/poses/CPose2D.h"

#include <Eigen/src/Core/Matrix.h>

#define STOP while (std::cin.get() != '\n');

PackingTask::PackingTask(SmartACE::SmartComponent *comp) 
:	PackingTaskCore(comp)
{
	std::cout << "constructor PackingTask\n";
}
PackingTask::~PackingTask() 
{
	std::cout << "destructor PackingTask\n";
}



int PackingTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	_layer_cloud_window_idx = _vHelper.createPointCloudWindow("[PackingTask] layers cloud");
	_filtered_cloud_window_idx = _vHelper.createPointCloudWindow("[PackingTask] filtered cloud");

	return 0;
}
int PackingTask::on_execute()
{
	COMP->start_recognition.acquire();

	CommObjectRecognitionObjects::CommObjectRecognitionId objId;
	CommObjectRecognitionObjects::CommObjectRecognitionObjectProperties recognizedObj;

	objId.set_id(COMP->recognizedObjectId);

	// Get new image by query
	Smart::StatusCode status = COMP->objectPropertyQueryClient->query(objId, recognizedObj);
	if (status != Smart::SMART_OK) {
		std::cerr << "[PackingTask] Error objectPropertyQueryClient communication: " << Smart::StatusCodeConversion(status) << std::endl;
		errorQuit();
		return 0;
	}

	if (!recognizedObj.getIs_valid()) {
		std::cerr << "[PackingTask] Error: Data is not valid!" << std::endl;
		errorQuit();
		return 0;
	}


	pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud_filtered = distanceFilter(COMP->point_cloud.makeShared());

	std::cout << "[PackingTask] Detecting Layers..." << std::flush;
	std::vector<Layer> layers;
	findLayers(point_cloud_filtered, layers);
	std::cout << " Done!" << std::endl;

	std::cout << "[PackingTask] Sorting Layers..." << std::flush;
	std::sort(layers.begin(), layers.end());
	int topLayer = layers.size() - 1; //since std::sort reorders to lowest layer index = 0
	std::cout << " Done!" << std::endl;

	//old, non robust version
//	std::cout << "[PackingTask] Detecting Container..." << std::flush;
//	Container slc = findContainer(layers[topLayer]); // todo test with several layers
//	std::cout << " Done!" << std::endl;

	pcl::PointCloud<pcl::PointXYZRGB>::Ptr wholeLayersCloud(new pcl::PointCloud<pcl::PointXYZRGB>);
	for(int k = 0; k<layers.size(); k++){
		for(int l = 0; l<layers[k].getPointCloud()->points.size(); l++){
			wholeLayersCloud->push_back(layers[k].getPointCloud()->points[l]);
		}
	}

	std::cout << "[PackingTask] Detecting Container..." << std::flush;
	std::vector<mrpt::math::TPoint3D> slcCornerPoints = findSlcCornerPoints(wholeLayersCloud);
	mrpt::poses::CPose3D slcPose = calcSlcPose(slcCornerPoints);
	std::cout << " Done!" << std::endl;


	Container slc;
	slc.setTopPoints(slcCornerPoints);
	slc.setPose(slcPose.asTPose());


	mrpt::poses::CPose3D tcpPose;

	Packer packer;
	packer.setLayers(layers);
	packer.setSlc(slc);
	packer.setGridSizeInM(COMP->getGlobalState().getGeneral().getGridSizeInM());
	packer.initLayers();
	tcpPose = packer.findFreeSpaceForBox(recognizedObj);


	std::cout << "---> slcPose: " << slcPose << std::endl;
	//std::cout << "---> freeSpaceSurfacePose: " << freeSpaceSurfacePose << std::endl;


	//mrpt::poses::CPose3D tcpPose = freeSpaceSurfacePose + mrpt::poses::CPose3D((-1) * (objHeight + 0.007), 0 ,0, 0, 0, 0); //todo not hard code
	//mrpt::poses::CPose3D tcpPose = freeSpaceSurfacePose + mrpt::poses::CPose3D(0, 0 ,0, 0, 0, 0);

	std::cout << "---> tcpPose: " << tcpPose << std::endl;


	setEnvId();
	setDetectedObjects(tcpPose, slcPose);
	setObstacleObject(point_cloud_filtered); //todo parts of arm contained
	//setObstacleObject(wholeLayersCloud);

	sendFinishedEvent();


	//DEBUG code: show layer clouds
//	pcl::PointCloud<pcl::PointXYZRGB>::Ptr show_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
//	bool showOriginalCloud = true; //todo not hard code
//	bool showTransformedCloud = true;
//	for(int k = 0; k<layers.size(); k++){
//		for(int l = 0; l<layers[k].getPointCloud()->points.size(); l++){
//			if(showTransformedCloud){
//				mrpt::poses::CPose3D p(layers[k].getPointCloud()->points[l].x, layers[k].getPointCloud()->points[l].y, layers[k].getPointCloud()->points[l].z,0,0,0);
//				mrpt::poses::CPose3D transformedPoint = p - slc.getPose();
//
//				pcl::PointXYZRGB tp(0,0,0);
//				tp.x = transformedPoint.x();
//				tp.y =transformedPoint.y();
//				tp.z =transformedPoint.z();
//				show_cloud->push_back(tp);
//			}
//			if(showOriginalCloud){
//				show_cloud->push_back(layers[k].getPointCloud()->points[l]);
//			}
//		}
//	}


	_vHelper.showPointCloud(wholeLayersCloud, _layer_cloud_window_idx);
	_vHelper.addSmallCoordinateFrame(_layer_cloud_window_idx, tcpPose);
	_vHelper.addSmallCoordinateFrame(_layer_cloud_window_idx, slcPose);

	_vHelper.showPointCloud(point_cloud_filtered, _filtered_cloud_window_idx);
	_vHelper.addSmallCoordinateFrame(_filtered_cloud_window_idx, tcpPose);

	for(int i = 0; i < slcCornerPoints.size(); i++){
		_vHelper.addSmallCoordinateFrame(_filtered_cloud_window_idx, mrpt::poses::CPose3D(slcCornerPoints[i].x, slcCornerPoints[i].y, slcCornerPoints[i].z, 0, 0, 0));
	}


	//STOP;
	return 0;
}
int PackingTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

/*
* Sends a finished event with empty object list
*/
void PackingTask::errorQuit() {
//	vector<Box> boxes;
//	setDetectedObjects(boxes);
//	sendFinishedEvent();
}


void PackingTask::setEnvId() {
//TODO parameters are missing
//	std::cout << "setting env id: " << COMP->getGlobalState().getCommObjectRecognitionObjects().getObjectRecognitionParameter().getSETENVID().getId() << std::endl;
//	COMP->environmentIdCounter = COMP->getGlobalState().getCommObjectRecognitionObjects().getObjectRecognitionParameter().getSETENVID().getId();

//	std::cout << "setting obj id: " << COMP->getGlobalState().getCommObjectRecognitionObjects().getObjectRecognitionParameter().getSETENVID().getId() << std::endl;
//	COMP->objectIdCounter = COMP->getGlobalState().getCommObjectRecognitionObjects().getObjectRecognitionParameter().getSETOBJECTID().getId();
}


/*
 * Prepares and sets an event for signaling the completion of detection
 */
void PackingTask::sendFinishedEvent() {
	CommObjectRecognitionObjects::CommObjectRecognitionEventState event;

	event.set_environment_id(COMP->environmentIdCounter);
	event.set_object_id_size(COMP->concreteObjects.size());

	uint32_t index = 0;
	for (std::list<ConcreteObject>::const_iterator iter = COMP->concreteObjects.begin(); iter != COMP->concreteObjects.end(); iter++) {
		event.set_object_id(index, iter->getId());
		index++;
	}


	COMP->objectEventServer->put(event);
	std::cout << "[PackingTask]" << " Sent " << event.get_object_id_size()
			<< " object IDs by event." << std::endl;
}




/*
 * Returns values in following sequence (vector index): 0 = minXPoint; 1 = maxXPoint; 2 = minYPoint; 3 = maxYPoint
 */
std::vector<mrpt::math::TPoint3D> PackingTask::findSlcCornerPoints(pcl::PointCloud<pcl::PointXYZRGB>::Ptr layerCloud) {

	pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);
	pcl::copyPointCloud(*layerCloud, *cloud);



	pcl::PointXYZ minXPoint(1000, 0, 0);
	pcl::PointXYZ maxXPoint(-1000, 0, 0);
	pcl::PointXYZ minYPoint(0, 1000, 0);
	pcl::PointXYZ maxYPoint(0, -1000, 0);
	pcl::PointXYZ maxZPoint(0, 0, -1000);

	for(int i = 0; i<cloud->size(); i++){

		if(cloud->points[i].x == 0 || cloud->points[i].y == 0){continue;}

		if(cloud->points[i].x > maxXPoint.x){maxXPoint.x = cloud->points[i].x; maxXPoint.y = cloud->points[i].y;}
		if(cloud->points[i].x < minXPoint.x){minXPoint.x = cloud->points[i].x; minXPoint.y = cloud->points[i].y;}

		if(cloud->points[i].y > maxYPoint.y){maxYPoint.x = cloud->points[i].x; maxYPoint.y = cloud->points[i].y;}
		if(cloud->points[i].y < minYPoint.y){minYPoint.x = cloud->points[i].x; minYPoint.y = cloud->points[i].y;}

		if(cloud->points[i].z > maxZPoint.z){maxZPoint.x = cloud->points[i].x; maxZPoint.y = cloud->points[i].y; maxZPoint.z = cloud->points[i].z;}

	}

	std::cout << "[PackingTask] point cloud size: " << cloud->points.size()  << std::endl;

	minXPoint.z = maxZPoint.z;
	maxXPoint.z = maxZPoint.z;
	minYPoint.z = maxZPoint.z;
	maxYPoint.z = maxZPoint.z;


	std::vector<mrpt::math::TPoint3D> cornerPoints;
	cornerPoints.push_back(mrpt::math::TPoint3D(minXPoint.x, minXPoint.y, minXPoint.z));
	cornerPoints.push_back(mrpt::math::TPoint3D(maxXPoint.x, maxXPoint.y, maxXPoint.z));
	cornerPoints.push_back(mrpt::math::TPoint3D(minYPoint.x, minYPoint.y, minYPoint.z));
	cornerPoints.push_back(mrpt::math::TPoint3D(maxYPoint.x, maxYPoint.y, maxYPoint.z));




	std::cout << "[PackingTask]  minXPointrgb: " << minXPoint  << std::endl;
	std::cout << "[PackingTask]  maxXPointrgb: " << maxXPoint  << std::endl;

	std::cout << "[PackingTask]  minYPointrgb: " << minYPoint  << std::endl;
	std::cout << "[PackingTask]  maxYPointrgb: " << maxYPoint  << std::endl;

	///////////////////
	//finding minXPoint, because there are problems because of robotino emergency button

	double slcShortSide = 0.3; //Todo not hard code
	double slcLongSide = 0.4;//Todo not hard code

	double hyp =  sqrt(pow(slcShortSide, 2) + pow(slcLongSide, 2));

	double alpha = cos(slcShortSide/hyp);

	mrpt::math::TLine2D hypStraight(mrpt::math::TPoint2D(minYPoint.x, minYPoint.y), mrpt::math::TPoint2D(maxYPoint.x, maxYPoint.y));
	//mrpt::math::TLine2D xAxis(mrpt::math::TPoint2D(0, 0), mrpt::math::TPoint2D(1,0));
	//mrpt::math::getAngle(xAxis, hypStraight);

	mrpt::math::TPose2D maxYPose;
	hypStraight.getAsPose2D(maxYPose);

	double newPhi = maxYPose.phi - M_PI;
	newPhi = newPhi - alpha;

	maxYPose.phi= newPhi;

	mrpt::poses::CPose2D minXPose = mrpt::poses::CPose2D(maxYPose) + mrpt::poses::CPose2D(slcShortSide, 0, maxYPose.phi);
	minXPoint.x = minXPose.x();
	minXPoint.y = minXPose.y();

	mrpt::poses::CPose3D maxYPose3D(maxYPoint.x, maxYPoint.y, maxYPoint.z, maxYPose.phi, 0, 0);
	mrpt::poses::CPose3D minXPose3D = maxYPose3D + mrpt::poses::CPose3D(slcShortSide, 0, 0, M_PI/2, 0, 0);

	//sort points by x to surface midpoint
	std::sort(cloud->points.begin(), cloud->points.end(),
			[&](pcl::PointXYZRGB a, pcl::PointXYZRGB b) {

		return a.x < b.x;
	});

	double maxY = minXPose3D.y() + 0.03; //todo not hard code
	double minY = minXPose3D.y() - 0.03;//todo not hard code

	for (int i = 0; i < cloud->size(); i++){
		if(cloud->points[i].y <= maxY && cloud->points[i].y >= minY){
			minXPose3D.x(cloud->points[i].x);
			minXPose3D.y(cloud->points[i].y);
			break;
		}
	}

	///////////



	cornerPoints[0].x = minXPose3D.x();
	cornerPoints[0].y = minXPose3D.y();


//	int windowId = _vHelper.createPointCloudWindow("[PackingTask] Min Max Points");
//	_vHelper.showPointCloud(cloud, windowId);
//	_vHelper.addSmallCoordinateFrame(windowId, mrpt::poses::CPose3D(minXPoint.x, minXPoint.y, minXPoint.z, maxYPose.phi() + M_PI, 0, 0));
//	_vHelper.addSmallCoordinateFrame(windowId, mrpt::poses::CPose3D(maxXPoint.x, maxXPoint.y, maxXPoint.z, 0, 0, 0));
//	_vHelper.addSmallCoordinateFrame(windowId, mrpt::poses::CPose3D(minYPoint.x, minYPoint.y, minYPoint.z, 0, 0, 0));
//	_vHelper.addSmallCoordinateFrame(windowId, mrpt::poses::CPose3D(maxYPoint.x, maxYPoint.y, maxYPoint.z, maxYPose.phi(), 0, 0));


	return cornerPoints;

}

/*
 * expects corner points in in following sequence (vector index):
 * 0 = minXPoint; 1 = maxXPoint; 2 = minYPoint; 3 = maxYPoint
 */
mrpt::poses::CPose3D PackingTask::calcSlcPose(std::vector<mrpt::math::TPoint3D> cornerPoints) {
	mrpt::math::TPoint2D minXPoint(cornerPoints[0].x, cornerPoints[0].y);
	mrpt::math::TPoint2D maxXPoint(cornerPoints[1].x, cornerPoints[1].y);
	mrpt::math::TPoint2D minYPoint(cornerPoints[2].x, cornerPoints[2].y);
	mrpt::math::TPoint2D maxYPoint(cornerPoints[3].x, cornerPoints[3].y);


	mrpt::math::TLine2D xAxis(mrpt::math::TPoint2D(0,0), mrpt::math::TPoint2D(10,0));
	mrpt::math::TLine2D line1(minXPoint, maxYPoint);
	mrpt::math::TLine2D line2(minXPoint, minYPoint);

	double angle1 = mrpt::math::getAngle(line1, xAxis);
	double angle2 = mrpt::math::getAngle(line2, xAxis);
	std::cout << "angle between line 1 " << " and x-axis = " << angle1 << std::endl;
	std::cout << "angle between line 2 " << " and x-axis = " << angle2 << std::endl;

	double yaw;
//	if(angle1 < angle2){
//		yaw = angle1 + M_PI;
//	}else {
//		yaw = angle1 + M_PI;
//	}

	yaw = (-1)* angle2;


	mrpt::poses::CPose3D containerPose(cornerPoints[0].x, cornerPoints[0].y, cornerPoints[0].z, yaw, 0, 0);
	std::cout << "Container pose: " << containerPose << std::endl;
	return containerPose;
}

//#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/common/transforms.h>
#include <pcl/common/common.h>

void PackingTask::findBoundingBox(Layer& containerTopLayer) {
	pcl::PointCloud<pcl::PointXYZRGB> cloud_colored(*(containerTopLayer.getPointCloud()));
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
	//pcl::copyPointCloud(cloud_colored, *cloud);




	pcl::PointXYZRGB minXPointrgb(0, 0, 255);
	pcl::PointXYZRGB maxXPointrgb(0, 0, 255);
	pcl::PointXYZRGB minYPointrgb(0, 0, 255);
	pcl::PointXYZRGB maxYPointrgb(0, 0, 255);
	minXPointrgb.x = 1000; minXPointrgb.y = 0; minXPointrgb.z = 0;
	maxXPointrgb.x = -1000; maxXPointrgb.y = 0; maxXPointrgb.z = 0;
	minYPointrgb.x = 0; minYPointrgb.y = 1000; minYPointrgb.z = 0;
	maxYPointrgb.x = 0; maxYPointrgb.y = -1000; maxYPointrgb.z = 0;


	for(int i = 0; i<cloud_colored.size(); i++){
		pcl::PointXYZ tmpPoint;

		tmpPoint.x = cloud_colored.points[i].x;
		tmpPoint.y = cloud_colored.points[i].y;
		tmpPoint.z = cloud_colored.points[i].z;

		if(tmpPoint.x == 0 || tmpPoint.y == 0){continue;}

		cloud->points.push_back(tmpPoint);


		if(tmpPoint.x > maxXPointrgb.x){maxXPointrgb.x = tmpPoint.x; maxXPointrgb.y = tmpPoint.y;}
		if(tmpPoint.x < minXPointrgb.x){minXPointrgb.x = tmpPoint.x; minXPointrgb.y = tmpPoint.y;}

		if(tmpPoint.y > maxYPointrgb.y){maxYPointrgb.x = tmpPoint.x; maxYPointrgb.y = tmpPoint.y;}
		if(tmpPoint.y < minYPointrgb.y){minYPointrgb.x = tmpPoint.x; minYPointrgb.y = tmpPoint.y;}
	}

	std::cout << "[PackingTask] top layer point cloud size: " << containerTopLayer.getPointCloud()->size()  << std::endl;
	std::cout << "[PackingTask] colored point cloud size: " << cloud_colored.size()  << std::endl;
	std::cout << "[PackingTask] point cloud size: " << cloud->size()  << std::endl;


	// Compute principal directions
//	Eigen::Vector4f pcaCentroid;
//	pcl::compute3DCentroid(cloud, pcaCentroid);
//	Eigen::Matrix3f covariance;
//	pcl::computeCovarianceMatrixNormalized(cloud, pcaCentroid, covariance);
//	Eigen::SelfAdjointEigenSolver<Eigen::Matrix3f> eigen_solver(covariance, Eigen::ComputeEigenvectors);
//	Eigen::Matrix3f eigenVectorsPCA = eigen_solver.eigenvectors();
//	eigenVectorsPCA.col(2) = eigenVectorsPCA.col(0).cross(eigenVectorsPCA.col(1));  /// This line is necessary for proper orientation in some cases. The numbers come out the same without it, but
//
//	///    the signs are different and the box doesn't get correctly oriented in some cases.
//	// Transform the original cloud to the origin where the principal components correspond to the axes.
//	Eigen::Matrix4f projectionTransform(Eigen::Matrix4f::Identity());
//	projectionTransform.block<3,3>(0,0) = eigenVectorsPCA.transpose();
//	projectionTransform.block<3,1>(0,3) = -1.f * (projectionTransform.block<3,3>(0,0) * pcaCentroid.head<3>());
//	pcl::PointCloud<pcl::PointXYZ>::Ptr cloudPointsProjected (new pcl::PointCloud<pcl::PointXYZ>);
//	pcl::transformPointCloud(cloud, *cloudPointsProjected, projectionTransform);
//
//	// Get the minimum and maximum points of the transformed cloud.
//	pcl::PointXYZ minPoint, maxPoint;
//	pcl::getMinMax3D(*cloudPointsProjected, minPoint, maxPoint);

//
//	const Eigen::Vector3f meanDiagonal = 0.5f*(maxPoint.getVector3fMap() + minPoint.getVector3fMap());
//
//
//	// Final transform
//	const Eigen::Quaternionf bboxQuaternion(eigenVectorsPCA); //Quaternions are a way to do rotations https://www.youtube.com/watch?v=mHVwd8gYLnI
//	const Eigen::Vector3f bboxTransform = eigenVectorsPCA * meanDiagonal + pcaCentroid.head<3>();

	// This viewer has 4 windows, but is only showing images in one of them as written here.
//	pcl::visualization::PCLVisualizer *visu;
//	visu = new pcl::visualization::PCLVisualizer ("PlyViewer");
//	int mesh_vp_1, mesh_vp_2, mesh_vp_3, mesh_vp_4;
//	visu->createViewPort (0.0, 0.5, 0.5, 1.0,  mesh_vp_1);
//	visu->createViewPort (0.5, 0.5, 1.0, 1.0,  mesh_vp_2);
//	visu->createViewPort (0.0, 0, 0.5, 0.5,  mesh_vp_3);
//	visu->createViewPort (0.5, 0, 1.0, 0.5, mesh_vp_4);
////	pcl::visualization::PCLVisualizer::ColorHandlerPtr<pcl::PointXYZRGB> rgb(cloud);
//	visu->addPointCloud(cloud.makeShared(), "bboxedCloud", mesh_vp_3);
//	visu->addCube(bboxTransform, bboxQuaternion, maxPoint.x - minPoint.x, maxPoint.y - minPoint.y, maxPoint.z - minPoint.z, "bbox", mesh_vp_3);

	// Get the minimum and maximum points of the transformed cloud.
	pcl::PointXYZ minPoint, maxPoint;
	pcl::PointXYZRGB minPointrgb, maxPointrgb;
	pcl::getMinMax3D(*cloud, minPoint, maxPoint);

	cloud_colored.points.push_back(maxXPointrgb);
	cloud_colored.points.push_back(minXPointrgb);
	cloud_colored.points.push_back(maxYPointrgb);
	cloud_colored.points.push_back(minYPointrgb);

	std::cout << "[PackingTask]  minPoint: " << minPoint  << std::endl;
	std::cout << "[PackingTask]  maxPoint: " << maxPoint  << std::endl;

	std::cout << "[PackingTask]  minXPointrgb: " << minXPointrgb  << std::endl;
	std::cout << "[PackingTask]  maxXPointrgb: " << maxXPointrgb  << std::endl;

	std::cout << "[PackingTask]  minYPointrgb: " << minYPointrgb  << std::endl;
	std::cout << "[PackingTask]  maxYPointrgb: " << maxYPointrgb  << std::endl;


	minPointrgb.x = minPoint.x;
	minPointrgb.y = minPoint.y;
	minPointrgb.z = minPoint.z;
	minPointrgb.r = 0;
	minPointrgb.g = 255;
	minPointrgb.b = 0;
	maxPointrgb.x = maxPoint.x;
	maxPointrgb.y = maxPoint.y;
	maxPointrgb.z = maxPoint.z;
	maxPointrgb.r = 0;
	maxPointrgb.g = 255;
	maxPointrgb.b = 0;


	cloud_colored.points.push_back(maxPointrgb);
	cloud_colored.points.push_back(minPointrgb);

	int windowId = _vHelper.createPointCloudWindow("[PackingTask] Min Max Points");
	_vHelper.showPointCloud(cloud_colored.makeShared(), windowId);
	STOP;
}





/*
 * Inserts the detected objects into the global list,
 * for publishing them via queries.
 */
void PackingTask::setDetectedObjects(mrpt::poses::CPose3D spaceSurfacePose, mrpt::poses::CPose3D slcPose) {

	COMP->concreteObjects.clear();

	ConcreteObject freeSpace;
	COMP->objectIdCounter++;
	freeSpace.setId(COMP->objectIdCounter);
	freeSpace.setSurfacePose(spaceSurfacePose);
	freeSpace.setObjectClass("FREE-SPACE");

	//setting dimensions is not necessary, since object
	//size is taken from openrave DB.
	//box.setDimension(box_dimension);
	COMP->concreteObjects.push_back(freeSpace);

	ConcreteObject robotino;
	COMP->objectIdCounter++;
	mrpt::poses::CPose3D robotinoPose (slcPose.x() + (0.45 / 2) + 0.05, slcPose.y() - (0.40 / 2) + 0.04, (0.95 / 2) - 0.19, slcPose.yaw(), 0, 0); //todo not hardcode robotino dimensions/calculation
	robotino.setId(COMP->objectIdCounter);
	robotino.setPose(robotinoPose);
	robotino.setObjectClass("ROBOTINO");
	COMP->concreteObjects.push_back(robotino);
}

/*
 * Sets the whole cloud without the detected objects as mesh to the concrete objects list.
 * This will be used for avoiding obstacles during path planning.
 */
void PackingTask::setObstacleObject(pcl::PointCloud<pcl::PointXYZRGB>::Ptr filtered_obstacles_cloud) {
//	pcl::PointCloud<pcl::PointXYZRGB>::Ptr env_cloud_filtered_y(new pcl::PointCloud<pcl::PointXYZRGB>);
//	pcl::PassThrough<pcl::PointXYZRGB> pass_y;
//	pass_y.setInputCloud (filtered_obstacles_cloud);
//	pass_y.setFilterFieldName ("y");
//	pass_y.setFilterLimits (-2.0, -0.25);
//	std::cout << "[PackingTask] Distance filter y cloud..." << std::flush;
//	pass_y.filter(*env_cloud_filtered_y);
//	std::cout << " Done!" << std::endl;
//	std::cout << "Cloud size: " << env_cloud_filtered_y->size() << std::endl;


//	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_x(new pcl::PointCloud<pcl::PointXYZ>);
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_filtered_y(new pcl::PointCloud<pcl::PointXYZRGB>);

//	pcl::PassThrough<pcl::PointXYZ> pass_env_x;
//	pass_env_x.setInputCloud(filtered_obstacles_cloud);
//	pass_env_x.setFilterFieldName("x");
//	pass_env_x.setFilterLimits(min_x, max_x);
//	pass_env_x.filter(*cloud_filtered_x);

	pcl::PassThrough<pcl::PointXYZRGB> pass_env_y;
	pass_env_y.setInputCloud(filtered_obstacles_cloud);
	pass_env_y.setFilterFieldName("y");
	pass_env_y.setFilterLimits(-2, -0.25); //todo not hard code!
	pass_env_y.filter(*cloud_filtered_y);


	//////////////////////////////////////////////////
	// VoxelGrid filter to reduce the number of points. Additionally filter cloud in y-direction

	//PclPointCloudPtr downsampled_cloud(new PclPointCloud);
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr downsampled_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);

	pcl::VoxelGrid<pcl::PointXYZRGB> voxel_grid;

	float leaf_size = 0.003; //in m

	//voxel_grid.setInputCloud(filtered_obstacles_cloud);
	voxel_grid.setInputCloud(cloud_filtered_y);
	voxel_grid.setLeafSize(leaf_size, leaf_size, leaf_size);
//	if (COMP->getGlobalState().getGeneral().getDo_y_filtering()) {
//		voxel_grid.setFilterFieldName("y");
//		voxel_grid.setFilterLimits(_y_detection_distance_min, _y_detection_distance_max);
//	}
	std::cout << "Voxel filter cloud..." << std::flush;
	voxel_grid.filter(*downsampled_cloud);
	std::cout << " Done!" << std::endl;
	std::cout << "Cloud size: " << downsampled_cloud->size() << std::endl;



	///////////////////////////////////////////
	// Delete flying pixels

	//PclPointCloudPtr radius_filtered_cloud(new PclPointCloud);
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr radius_filtered_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);

	pcl::RadiusOutlierRemoval<pcl::PointXYZRGB> outrem;
	outrem.setInputCloud(downsampled_cloud);
	outrem.setRadiusSearch(0.05);
	outrem.setMinNeighborsInRadius(20);
	outrem.filter (*radius_filtered_cloud);


	///////////////////////////////////////////
	// Create mesh (code from mapper.cc:915)

	pcl::ConcaveHull<pcl::PointXYZRGB> hr;
	hr.setAlpha(leaf_size);
	hr.setInputCloud(radius_filtered_cloud);

	pcl::PointCloud<pcl::PointXYZRGB>::Ptr hull_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
	std::vector<pcl::Vertices> vertices;
	//calculate mesh from point cloud
	std::cout << "Create mesh cloud..." << std::flush;
	hr.reconstruct(*hull_cloud, vertices);
	std::cout << " Done!" << std::endl;
	std::cout << "Mesh cloud size: " << hull_cloud->size() << std::endl;

	PclPointCloudPtr hull_cloud_xyz(new PclPointCloud);
	hull_cloud_xyz->reserve((*hull_cloud).size());
	for(int i=0; i< (*hull_cloud).size(); ++i)
	{
	hull_cloud_xyz->push_back(pcl::PointXYZ(hull_cloud->points[i].x, hull_cloud->points[i].y, hull_cloud->points[i].z));
	}
	//pcl::copyPointCloud(hull_cloud, hull_cloud_xyz);

	///////////////////////////////////////////
	// Convert mesh into transmission format

	PointCloud cloud_out;
	cloud_out.setPclPointCloud(hull_cloud_xyz);

	std::vector<std::vector<uint32_t> > vertices_out;
	vertices_out.resize(vertices.size());

	uint32_t vertices_size = vertices[0].vertices.size();
	for (size_t i = 0; i < vertices.size(); ++i) {
		vertices_out[i].resize(vertices_size);
		vertices_out[i][0] = vertices[i].vertices[0];
		vertices_out[i][1] = vertices[i].vertices[1];
		vertices_out[i][2] = vertices[i].vertices[2];
	}

	///////////////////////////////////////////
	// Prepare transmission object

	ConcreteObject obstacle_hull;
	mrpt::poses::CPose3D zero_pose;
	mrpt::math::TPoint3D zero_point;

	obstacle_hull.setMinPoint(zero_point);
	obstacle_hull.setMaxPoint(zero_point);
	obstacle_hull.setPose(zero_pose);

	COMP->objectIdCounter++;
	obstacle_hull.setId(COMP->objectIdCounter);
	//obstacle_hull.setId(10000); //Todo not hard code!!!
	obstacle_hull.setObjectClass("OBSTACLE-HULL");

	ObjectBeliefs belief_hull;
	belief_hull.setBelief("OBSTACLE-HULL", 1.0);
	obstacle_hull.setBeliefs(belief_hull);

	obstacle_hull.setObstacleHullPointCloud(cloud_out);
	obstacle_hull.setObstacleHullvertices(vertices_out);

	COMP->concreteObjects.push_back(obstacle_hull);
}



/*
 * Defines the properties, which are needed for the detection
 * Before detection (trigger recognize) the trigger addobject needs
 * to be executed to set the searched object type. Object properties
 * should rewuested from database.
 * If object type is unknown false is reruned, otherwise true.
 */
bool PackingTask::setSpaceDimensions() {
//	std::string obj_type_upper = COMP->searched_obj_type;
//	std::transform(COMP->searched_obj_type.begin(), COMP->searched_obj_type.end(), obj_type_upper.begin(), ::toupper);
//	cout << "[DetectionTask] Set object type " << obj_type_upper << endl;
//
//	if (obj_type_upper.compare("RATIOPHARM-IBU") == 0) {
//		cout << "[DetectionTask] Setting search properties for RATIOPHARM-IBU" << endl;
//		// Values for IBU Fiebersaft
//		_searched_obj.sides[0] = 0.135;
//		_searched_obj.sides[1] = 0.062;
//		_searched_obj.sides[2] = 0.05;
//		_searched_obj.shelf_level_height[0] = -0.18;
//		_searched_obj.shelf_level_height[1] = 0.42;
//		_searched_obj.object_type = obj_type_upper;
//		return true;
//	} else if (obj_type_upper.compare("RATIOPHARM-IBU-LYSIN") == 0) {
//		cout << "[DetectionTask] Setting search properties for RATIOPHARM-IBU-LYSIN" << endl;
//		//Values for IBU-Lysin
//		_searched_obj.sides[0] = 0.095;
//		_searched_obj.sides[1] = 0.061;
//		_searched_obj.sides[2] = 0.021;
//		//negative value, since robot (Larry) origin is at z = 20
//		_searched_obj.shelf_level_height[0] = -0.18;
//		_searched_obj.shelf_level_height[1] = 0.42;
//		_searched_obj.object_type = obj_type_upper;
//		return true;
//	} else if (obj_type_upper.compare("RATIOPHARM-ASS") == 0) {
//		cout << "[DetectionTask] Setting search properties for RATIOPHARM-ASS" << endl;
//		// Values for ASS+C
//		_searched_obj.sides[0] = 0.08;
//		_searched_obj.sides[1] = 0.074;
//		_searched_obj.sides[2] = 0.038;
//		//negative value, since robot (Larry) origin is at z = 20
//		_searched_obj.shelf_level_height[0] = 0.42;
//		_searched_obj.shelf_level_height[1] = 0.92;
//		_searched_obj.object_type = obj_type_upper;
//		return true;
//	}

	//if no match, object type or article is unknown
	return false;

}


pcl::PointCloud<pcl::PointXYZRGB>::Ptr PackingTask::distanceFilter(pcl::PointCloud<pcl::PointXYZRGB>::Ptr env_cloud) {

//	float robotPlatformHeight = 0.72 -0.19;
//	float slcHeight = 0.12;
//	float slcInnerHeight = 0.105;
//	float biggestProductHeight;
//	float maxZ =


	///////////////////////////////////////////
	// filter cloud in z-direction to shrink size for faster calculations and get rid of NaN values
	// and deleting the floor

	pcl::PointCloud<pcl::PointXYZRGB>::Ptr env_cloud_filtered_z(new pcl::PointCloud<pcl::PointXYZRGB>);
	pcl::PassThrough<pcl::PointXYZRGB> pass;
	pass.setInputCloud (env_cloud);
	pass.setFilterFieldName ("z");
	pass.setFilterLimits (0.5, 2.0);
	std::cout << "[PackingTask] Distance filter z cloud..." << std::flush;
	pass.filter(*env_cloud_filtered_z);
	std::cout << " Done!" << std::endl;
	std::cout << "Cloud size: " << env_cloud_filtered_z->size() << std::endl;


	return env_cloud_filtered_z;
}

void PackingTask::findLayers(pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud_in, std::vector<Layer>& layers) {
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud (new pcl::PointCloud<pcl::PointXYZRGB>);
	pcl::copyPointCloud(*point_cloud_in, *point_cloud);

	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients ());
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_p (new pcl::PointCloud<pcl::PointXYZRGB>), cloud_f (new pcl::PointCloud<pcl::PointXYZRGB>);

	pcl::PointIndices::Ptr inliers (new pcl::PointIndices ());
	pcl::SACSegmentation<pcl::PointXYZRGB> seg;
	// Optional
	seg.setOptimizeCoefficients (true);
	// Mandatory
	//seg.setModelType (pcl::SACMODEL_PARALLEL_PLANE);
	seg.setModelType (pcl::SACMODEL_PERPENDICULAR_PLANE);
	seg.setMethodType (pcl::SAC_RANSAC);
	seg.setMaxIterations (1000);
	//seg.setDistanceThreshold (0.005);
	seg.setDistanceThreshold (0.01);

	//search for planes parallel to floor (=> horizontal planes)
	Eigen::Vector3f axisVector(0, 0, 1);
	seg.setAxis(axisVector);
	seg.setEpsAngle(4 * M_PI / 180.0);

	// Create the filtering object
	pcl::ExtractIndices<pcl::PointXYZRGB> extract;

	int nr_points = (int) point_cloud->points.size ();
	// While 30% of the original cloud is still there
	while (point_cloud->points.size () > 0.1 * nr_points)
	{
		// Segment the largest planar component from the remaining cloud
		seg.setInputCloud (point_cloud);
		seg.segment (*inliers, *coefficients);
		if (inliers->indices.size () == 0)
		{
			std::cerr << "Could not estimate a planar model for the given dataset." << std::endl;
			break;
		}

		// Extract the inliers
		extract.setInputCloud (point_cloud);
		extract.setIndices (inliers);
		extract.setNegative (false);
		extract.filter (*cloud_p);
		std::cout << "PointCloud representing the planar component: " << cloud_p->width * cloud_p->height << " data points." << std::endl;

		// Creating the KdTree object for the search method of the extraction
		pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZRGB>);
		tree->setInputCloud (cloud_p);

		std::vector<pcl::PointIndices> cluster_indices;
		pcl::EuclideanClusterExtraction<pcl::PointXYZRGB> ec;
		ec.setClusterTolerance (0.007); // original: 0.5cm  (layer thickness = 2x) Todo: not hard code
		ec.setMinClusterSize (1000); //originally 3000
		ec.setMaxClusterSize (700000);
		ec.setSearchMethod (tree);
		ec.setInputCloud (cloud_p);
		ec.extract (cluster_indices);

		pcl::PointCloud<pcl::PointXYZRGB>::Ptr layer_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
		int r = rand() % 255, g= rand() % 255, b= rand() % 255;

		for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)
		{
			//pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_cluster (new pcl::PointCloud<pcl::PointXYZRGB>);

			for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit){
				pcl::PointXYZRGB p(r, g, b);
				p.x = cloud_p->points[*pit].x;
				p.y = cloud_p->points[*pit].y;
				p.z = cloud_p->points[*pit].z;
				layer_cloud->points.push_back(p);

				//cloud_cluster->points.push_back (cloud_p->points[*pit]); //*
			}

			std::cout << "PointCloud representing the Cluster: " << it->indices.size() << " data points." << std::endl;
		}

		layers.push_back(Layer());
		mrpt::math::TPlane layerPlane((double) coefficients->values[0], (double) coefficients->values[1], (double) coefficients->values[2], (double) coefficients->values[3]);
		layers.back().setPlane(layerPlane);
		layers.back().setPointCloud(layer_cloud);


//		int r = rand() % 255, g= rand() % 255, b= rand() % 255;
//
//		for (size_t j = 0; j < cloud_p->points.size(); j++){
//			pcl::PointXYZRGB p(r, g, b);
//			p.x = cloud_p->points[j].x;
//			p.y = cloud_p->points[j].y;
//			p.z = cloud_p->points[j].z;
//
//			show_cloud->points.push_back(p);
//		}


		// Create the filtering object
		extract.setNegative (true);
		extract.filter (*cloud_f);
		point_cloud.swap (cloud_f);
	}

}

Container PackingTask::findContainer(Layer& containerTopLayer) {
	std::vector<mrpt::math::TLine3D> lines;
	std::vector<mrpt::math::TPlane3D> planes;

	pcl::PointCloud<pcl::PointXYZRGB> cloud(*(containerTopLayer.getPointCloud()));
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloudPtr = cloud.makeShared();

	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients ());
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_p (new pcl::PointCloud<pcl::PointXYZRGB>), cloud_f (new pcl::PointCloud<pcl::PointXYZRGB>);

	pcl::PointIndices::Ptr inliers (new pcl::PointIndices ());
	pcl::SACSegmentation<pcl::PointXYZRGB> seg;
	// Optional
	seg.setOptimizeCoefficients (true);
	// Mandatory
	seg.setModelType (pcl::SACMODEL_LINE);
	seg.setMethodType (pcl::SAC_RANSAC);
	seg.setMaxIterations (1000);
	seg.setDistanceThreshold (0.01);

	// Create the filtering object
	pcl::ExtractIndices<pcl::PointXYZRGB> extract;

	int nr_points = (int) cloudPtr->points.size ();
	// While 30% of the original cloud is still there
	//while (cloudPtr->points.size () > 0.03 * nr_points)
	for (int l = 0; l < 4; l++)
	{
		if(cloudPtr->size()<100){continue;}

		// Segment the largest planar component from the remaining cloud
		seg.setInputCloud (cloudPtr);
		seg.segment (*inliers, *coefficients);
		if (inliers->indices.size () == 0)
		{
			std::cerr << "Could not estimate a line model for the given dataset." << std::endl;
			break;
		}

		float svx = coefficients->values[0],svy = coefficients->values[1], svz = coefficients->values[2]; //straight support vector
		float dvx = coefficients->values[3],dvy = coefficients->values[4], dvz = coefficients->values[5]; //straight directional vector
		float p1x = svx + dvx, p1y = svy + dvy, p1z = svz + dvz; //point on straight
		float p2x = svx, p2y = svy, p2z = 0; //point on plane


		mrpt::math::TPoint3D p1(svx, svy, svz);
		mrpt::math::TPoint3D p2(p1x, p1y, p1z);
		mrpt::math::TPoint3D p3(p2x, p2y, p2z); //only for plane
		mrpt::math::TLine3D line(p1, p2);
		//mrpt::math::TPlane3D plane(p1, p2, p3);
		mrpt::math::TPlane3D plane(p3, line);

		lines.push_back(line);
		std::cout << "Found line: support vector (" << svx << "," << svy << "," << svz << ") Direction vector (" << dvx << "," << dvy << "," << dvz << ")" << std::endl;

		planes.push_back(plane);

		// Extract the inliers
		extract.setInputCloud (cloudPtr);
		extract.setIndices (inliers);
		extract.setNegative (false);
		extract.filter (*cloud_p);

		// Create the filtering object
		extract.setNegative (true);
		extract.filter (*cloud_f);
		cloudPtr.swap(cloud_f);

		std::cout << "PointCloud representing the line: " << inliers->indices.size() << " data points." << std::endl;
	}

	std::vector<mrpt::math::TPoint3D> intersectionPoints;
	std::vector< std::vector<int> > intersectionLines;

	for(int i = 0; i < lines.size(); i++){
		for(int j = i + 1; j < lines.size(); j++){
			mrpt::math::TObject3D obj;

			bool doIntersect = mrpt::math::intersect(planes[i], lines[j], obj);
			if(!doIntersect){
				continue;
			}

			mrpt::math::TPoint3D point;
			obj.getPoint(point);
			if(std::abs(point.x) > 1.0 || std::abs(point.y) > 1.0){
				continue;
			}

			intersectionPoints.push_back(point);
			std::vector<int> tmpLines;
			tmpLines.push_back(i);
			tmpLines.push_back(j);
			intersectionLines.push_back(tmpLines);
			std::cout << "Found intersection between line: " << i << " and " << j << " at: " << point << std::endl;

		}
	}


	int closestPoint = -1;
	double currentMinDist = 100000.0;
	std::cout << "intersectionPoints.size() = " << intersectionPoints.size() <<  std::endl;
	for(int i = 0; i < intersectionPoints.size(); i++){
		if(intersectionPoints[i].x < currentMinDist){
			closestPoint = i;
			currentMinDist = intersectionPoints[i].x;
		}
		std::cout << "closest Point = " << closestPoint << " , i = " << i << std::endl;
	}
	std::cout << "closest Point = " << closestPoint <<  std::endl;

	//no SLC could be found
	if(intersectionPoints.size() <= 0 || intersectionPoints.size() > 4){
		std::cout << "Error: No intersections could be found... " <<  std::endl;
		return Container();
	}

	std::cout << "closest Point: ID = " << closestPoint << " , Values = " << intersectionPoints[closestPoint] << std::endl;
	std::cout << "closest Point intersects line: " << intersectionLines[closestPoint][0] << " and " <<  intersectionLines[closestPoint][1] << std::endl;

	//mrpt::math::TLine3D xAxis(mrpt::math::TPoint3D(0,0,0), mrpt::math::TPoint3D(10,0,0));
	mrpt::math::TLine2D xAxis(mrpt::math::TPoint2D(0,0), mrpt::math::TPoint2D(10,0));
	mrpt::math::TLine2D line1, line2;
	lines[intersectionLines[closestPoint][0]].generate2DObject(line1);
	lines[intersectionLines[closestPoint][1]].generate2DObject(line2);
//	double angle0 = mrpt::math::getAngle(xAxis, lines[intersectionLines[closestPoint][0]]);
//	double angle1 = mrpt::math::getAngle(xAxis, lines[intersectionLines[closestPoint][1]]);
	double angle0 = mrpt::math::getAngle(line1, xAxis);
	double angle1 = mrpt::math::getAngle(line2, xAxis);
	std::cout << "angle between line " << intersectionLines[closestPoint][0] << " and x-axis = " << angle0 << std::endl;
	std::cout << "angle between line " << intersectionLines[closestPoint][1] << " and x-axis = " << angle1 << std::endl;

	double yaw;
	if(angle0 < angle1){
		yaw = angle0 + M_PI;
	}else {
		yaw = angle1 + M_PI;
	}

	mrpt::poses::CPose3D containerPose(intersectionPoints[closestPoint].x, intersectionPoints[closestPoint].y, intersectionPoints[closestPoint].z, yaw, 0, 0);
	std::cout << "Container pose: " << containerPose << std::endl;

	Container slc;
	slc.setPose(containerPose.asTPose());
	//TODO: sort points correctly!!!
	slc.setTopPoints(intersectionPoints);


	pcl::PointCloud<pcl::PointXYZRGB>::Ptr show_cloud(new pcl::PointCloud<pcl::PointXYZRGB>);
	//int r = rand() % 255, g= rand() % 255, b= rand() % 255;
	int r = 250, g=0, b= 0;

	for (int k = 0; k < intersectionPoints.size(); k++){
		pcl::PointXYZRGB p(r, g, b);
		p.x = intersectionPoints[k].x;
		p.y = intersectionPoints[k].y;
		p.z = intersectionPoints[k].z;

		show_cloud->points.push_back(p);
	}

	int intersectionWindowId = _vHelper.createPointCloudWindow("[PackingTask] intersections top layer");
	_vHelper.showPointCloud(show_cloud, intersectionWindowId);
	_vHelper.addSmallCoordinateFrame(intersectionWindowId, containerPose);


	return slc;

}

int PackingTask::sortLayers(std::vector<Layer>& layers) {
	int topLayer = 0;
	double currentMaxDist = 0.0;
	mrpt::math::TPoint3D origin(0, 0, 0);

	for(int i = 0; i < layers.size(); i++){
		double tmp_dist = layers[i].getPlane().distance(origin);
		if(tmp_dist > currentMaxDist){
			topLayer = i;
			currentMaxDist = tmp_dist;
		}
	}

	//delete all clouds, beside top layer
	for(int i = 0; i < layers.size(); i++){
		double tmp_dist = layers[i].getPlane().distance(origin);
		if(i == topLayer){
			continue;
		}
		layers[i].getPointCloud()->clear();
	}

	return topLayer;
}
