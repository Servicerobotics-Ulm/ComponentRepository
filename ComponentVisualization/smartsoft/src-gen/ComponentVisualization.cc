//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#include "ComponentVisualization.hh"
#include "smartTimedTaskTrigger.h"
//FIXME: implement logging
//#include "smartGlobalLogger.hh"

// the ace port-factory is used as a default port-mapping
#include "ComponentVisualizationAcePortFactory.hh"


// initialize static singleton pointer to zero
ComponentVisualization* ComponentVisualization::_componentVisualization = 0;

// constructor
ComponentVisualization::ComponentVisualization()
{
	std::cout << "constructor of ComponentVisualization\n";
	
	// set all pointer members to NULL
	baseTask = NULL;
	baseTaskTrigger = NULL;
	//componentVisualizationParams = NULL;
	//coordinationPort = NULL;
	curMapTask = NULL;
	curMapTaskTrigger = NULL;
	depthTask = NULL;
	depthTaskTrigger = NULL;
	iRTask = NULL;
	iRTaskTrigger = NULL;
	imageTask = NULL;
	imageTaskTrigger = NULL;
	laser1Task = NULL;
	laser1TaskTrigger = NULL;
	laser2Task = NULL;
	laser2TaskTrigger = NULL;
	laser3Task = NULL;
	laser3TaskTrigger = NULL;
	managementTask = NULL;
	managementTaskTrigger = NULL;
	markerListDetectionServiceIn = NULL;
	markerListDetectionServiceInInputTaskTrigger = NULL;
	markerListDetectionServiceInUpcallManager = NULL;
	markerListTask = NULL;
	markerListTaskTrigger = NULL;
	personDetectionTask = NULL;
	personDetectionTaskTrigger = NULL;
	rGBDImageQueryServiceReq = NULL;
	rGBDTask = NULL;
	rGBDTaskTrigger = NULL;
	uSArTask = NULL;
	uSArTaskTrigger = NULL;
	baseClient = NULL;
	baseClientInputTaskTrigger = NULL;
	baseClientUpcallManager = NULL;
	curPushClient = NULL;
	curPushClientInputTaskTrigger = NULL;
	curPushClientUpcallManager = NULL;
	depthPushNewestClient = NULL;
	depthPushNewestClientInputTaskTrigger = NULL;
	depthPushNewestClientUpcallManager = NULL;
	imagePushNewestClient = NULL;
	imagePushNewestClientInputTaskTrigger = NULL;
	imagePushNewestClientUpcallManager = NULL;
	irPushNewestClient = NULL;
	irPushNewestClientInputTaskTrigger = NULL;
	irPushNewestClientUpcallManager = NULL;
	laserClient1 = NULL;
	laserClient1InputTaskTrigger = NULL;
	laserClient1UpcallManager = NULL;
	laserClient2 = NULL;
	laserClient2InputTaskTrigger = NULL;
	laserClient2UpcallManager = NULL;
	laserClient3 = NULL;
	laserClient3InputTaskTrigger = NULL;
	laserClient3UpcallManager = NULL;
	ltmQueryClient = NULL;
	personDetectionEventClient = NULL;
	personDetectionEventClientInputTaskTrigger = NULL;
	personDetectionEventClientUpcallManager = NULL;
	personDetectionQueryClient = NULL;
	rgbdPushNewestClient = NULL;
	rgbdPushNewestClientInputTaskTrigger = NULL;
	rgbdPushNewestClientUpcallManager = NULL;
	rgbdQueryClient = NULL;
	rgbdQueryClientInputTaskTrigger = NULL;
	rgbdQueryClientUpcallManager = NULL;
	ultrasonicPushNewestClient = NULL;
	ultrasonicPushNewestClientInputTaskTrigger = NULL;
	ultrasonicPushNewestClientUpcallManager = NULL;
	stateChangeHandler = NULL;
	stateSlave = NULL;
	wiringSlave = NULL;
	param = NULL;
	
	// set default ini parameter values
	connections.component.name = "ComponentVisualization";
	connections.component.initialComponentMode = "Neutral";
	connections.component.defaultScheduler = "DEFAULT";
	connections.component.useLogger = false;
	
	connections.markerListDetectionServiceIn.initialConnect = false;
	connections.markerListDetectionServiceIn.wiringName = "MarkerListDetectionServiceIn";
	connections.markerListDetectionServiceIn.serverName = "unknown";
	connections.markerListDetectionServiceIn.serviceName = "unknown";
	connections.markerListDetectionServiceIn.interval = 1;
	connections.markerListDetectionServiceIn.roboticMiddleware = "ACE_SmartSoft";
	connections.rGBDImageQueryServiceReq.initialConnect = false;
	connections.rGBDImageQueryServiceReq.wiringName = "RGBDImageQueryServiceReq";
	connections.rGBDImageQueryServiceReq.serverName = "unknown";
	connections.rGBDImageQueryServiceReq.serviceName = "unknown";
	connections.rGBDImageQueryServiceReq.interval = 1;
	connections.rGBDImageQueryServiceReq.roboticMiddleware = "ACE_SmartSoft";
	connections.baseClient.initialConnect = false;
	connections.baseClient.wiringName = "baseClient";
	connections.baseClient.serverName = "unknown";
	connections.baseClient.serviceName = "unknown";
	connections.baseClient.interval = 1;
	connections.baseClient.roboticMiddleware = "ACE_SmartSoft";
	connections.curPushClient.initialConnect = false;
	connections.curPushClient.wiringName = "curPushClient";
	connections.curPushClient.serverName = "unknown";
	connections.curPushClient.serviceName = "unknown";
	connections.curPushClient.interval = 1;
	connections.curPushClient.roboticMiddleware = "ACE_SmartSoft";
	connections.depthPushNewestClient.initialConnect = false;
	connections.depthPushNewestClient.wiringName = "depthPushNewestClient";
	connections.depthPushNewestClient.serverName = "unknown";
	connections.depthPushNewestClient.serviceName = "unknown";
	connections.depthPushNewestClient.interval = 1;
	connections.depthPushNewestClient.roboticMiddleware = "ACE_SmartSoft";
	connections.imagePushNewestClient.initialConnect = false;
	connections.imagePushNewestClient.wiringName = "imagePushNewestClient";
	connections.imagePushNewestClient.serverName = "unknown";
	connections.imagePushNewestClient.serviceName = "unknown";
	connections.imagePushNewestClient.interval = 1;
	connections.imagePushNewestClient.roboticMiddleware = "ACE_SmartSoft";
	connections.irPushNewestClient.initialConnect = false;
	connections.irPushNewestClient.wiringName = "irPushNewestClient";
	connections.irPushNewestClient.serverName = "unknown";
	connections.irPushNewestClient.serviceName = "unknown";
	connections.irPushNewestClient.interval = 1;
	connections.irPushNewestClient.roboticMiddleware = "ACE_SmartSoft";
	connections.laserClient1.initialConnect = false;
	connections.laserClient1.wiringName = "laserClient1";
	connections.laserClient1.serverName = "unknown";
	connections.laserClient1.serviceName = "unknown";
	connections.laserClient1.interval = 1;
	connections.laserClient1.roboticMiddleware = "ACE_SmartSoft";
	connections.laserClient2.initialConnect = false;
	connections.laserClient2.wiringName = "laserClient2";
	connections.laserClient2.serverName = "unknown";
	connections.laserClient2.serviceName = "unknown";
	connections.laserClient2.interval = 1;
	connections.laserClient2.roboticMiddleware = "ACE_SmartSoft";
	connections.laserClient3.initialConnect = false;
	connections.laserClient3.wiringName = "laserClient3";
	connections.laserClient3.serverName = "unknown";
	connections.laserClient3.serviceName = "unknown";
	connections.laserClient3.interval = 1;
	connections.laserClient3.roboticMiddleware = "ACE_SmartSoft";
	connections.ltmQueryClient.initialConnect = false;
	connections.ltmQueryClient.wiringName = "ltmQueryClient";
	connections.ltmQueryClient.serverName = "unknown";
	connections.ltmQueryClient.serviceName = "unknown";
	connections.ltmQueryClient.interval = 1;
	connections.ltmQueryClient.roboticMiddleware = "ACE_SmartSoft";
	connections.personDetectionEventClient.initialConnect = false;
	connections.personDetectionEventClient.wiringName = "personDetectionEventClient";
	connections.personDetectionEventClient.serverName = "unknown";
	connections.personDetectionEventClient.serviceName = "unknown";
	connections.personDetectionEventClient.interval = 1;
	connections.personDetectionEventClient.roboticMiddleware = "ACE_SmartSoft";
	connections.personDetectionQueryClient.initialConnect = false;
	connections.personDetectionQueryClient.wiringName = "personDetectionQueryClient";
	connections.personDetectionQueryClient.serverName = "unknown";
	connections.personDetectionQueryClient.serviceName = "unknown";
	connections.personDetectionQueryClient.interval = 1;
	connections.personDetectionQueryClient.roboticMiddleware = "ACE_SmartSoft";
	connections.rgbdPushNewestClient.initialConnect = false;
	connections.rgbdPushNewestClient.wiringName = "rgbdPushNewestClient";
	connections.rgbdPushNewestClient.serverName = "unknown";
	connections.rgbdPushNewestClient.serviceName = "unknown";
	connections.rgbdPushNewestClient.interval = 1;
	connections.rgbdPushNewestClient.roboticMiddleware = "ACE_SmartSoft";
	connections.rgbdQueryClient.initialConnect = false;
	connections.rgbdQueryClient.wiringName = "rgbdQueryClient";
	connections.rgbdQueryClient.serverName = "unknown";
	connections.rgbdQueryClient.serviceName = "unknown";
	connections.rgbdQueryClient.interval = 1;
	connections.rgbdQueryClient.roboticMiddleware = "ACE_SmartSoft";
	connections.ultrasonicPushNewestClient.initialConnect = false;
	connections.ultrasonicPushNewestClient.wiringName = "ultrasonicPushNewestClient";
	connections.ultrasonicPushNewestClient.serverName = "unknown";
	connections.ultrasonicPushNewestClient.serviceName = "unknown";
	connections.ultrasonicPushNewestClient.interval = 1;
	connections.ultrasonicPushNewestClient.roboticMiddleware = "ACE_SmartSoft";
	connections.baseTask.minActFreq = 0.0;
	connections.baseTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.baseTask.scheduler = "DEFAULT";
	connections.baseTask.priority = -1;
	connections.baseTask.cpuAffinity = -1;
	connections.curMapTask.minActFreq = 0.0;
	connections.curMapTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.curMapTask.scheduler = "DEFAULT";
	connections.curMapTask.priority = -1;
	connections.curMapTask.cpuAffinity = -1;
	connections.depthTask.minActFreq = 0.0;
	connections.depthTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.depthTask.scheduler = "DEFAULT";
	connections.depthTask.priority = -1;
	connections.depthTask.cpuAffinity = -1;
	connections.iRTask.minActFreq = 0.0;
	connections.iRTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.iRTask.scheduler = "DEFAULT";
	connections.iRTask.priority = -1;
	connections.iRTask.cpuAffinity = -1;
	connections.imageTask.minActFreq = 0.0;
	connections.imageTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.imageTask.scheduler = "DEFAULT";
	connections.imageTask.priority = -1;
	connections.imageTask.cpuAffinity = -1;
	connections.laser1Task.minActFreq = 0.0;
	connections.laser1Task.maxActFreq = 0.0;
	// scheduling default parameters
	connections.laser1Task.scheduler = "DEFAULT";
	connections.laser1Task.priority = -1;
	connections.laser1Task.cpuAffinity = -1;
	connections.laser2Task.minActFreq = 0.0;
	connections.laser2Task.maxActFreq = 0.0;
	// scheduling default parameters
	connections.laser2Task.scheduler = "DEFAULT";
	connections.laser2Task.priority = -1;
	connections.laser2Task.cpuAffinity = -1;
	connections.laser3Task.minActFreq = 0.0;
	connections.laser3Task.maxActFreq = 0.0;
	// scheduling default parameters
	connections.laser3Task.scheduler = "DEFAULT";
	connections.laser3Task.priority = -1;
	connections.laser3Task.cpuAffinity = -1;
	connections.managementTask.minActFreq = 0.0;
	connections.managementTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.managementTask.scheduler = "DEFAULT";
	connections.managementTask.priority = -1;
	connections.managementTask.cpuAffinity = -1;
	connections.markerListTask.minActFreq = 0.0;
	connections.markerListTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.markerListTask.scheduler = "DEFAULT";
	connections.markerListTask.priority = -1;
	connections.markerListTask.cpuAffinity = -1;
	connections.personDetectionTask.minActFreq = 0.0;
	connections.personDetectionTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.personDetectionTask.scheduler = "DEFAULT";
	connections.personDetectionTask.priority = -1;
	connections.personDetectionTask.cpuAffinity = -1;
	connections.rGBDTask.minActFreq = 0.0;
	connections.rGBDTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.rGBDTask.scheduler = "DEFAULT";
	connections.rGBDTask.priority = -1;
	connections.rGBDTask.cpuAffinity = -1;
	connections.uSArTask.minActFreq = 0.0;
	connections.uSArTask.maxActFreq = 0.0;
	// scheduling default parameters
	connections.uSArTask.scheduler = "DEFAULT";
	connections.uSArTask.priority = -1;
	connections.uSArTask.cpuAffinity = -1;
	
	// initialize members of OpcUaBackendComponentGeneratorExtension
	
	// initialize members of ComponentVisualizationROSExtension
	
	// initialize members of PlainOpcUaComponentVisualizationExtension
	
}

void ComponentVisualization::addPortFactory(const std::string &name, ComponentVisualizationPortFactoryInterface *portFactory)
{
	portFactoryRegistry[name] = portFactory;
}

void ComponentVisualization::addExtension(ComponentVisualizationExtension *extension)
{
	componentExtensionRegistry[extension->getName()] = extension;
}

SmartACE::SmartComponent* ComponentVisualization::getComponentImpl()
{
	return dynamic_cast<ComponentVisualizationAcePortFactory*>(portFactoryRegistry["ACE_SmartSoft"])->getComponentImpl();
}

/**
 * Notify the component that setup/initialization is finished.
 * You may call this function from anywhere in the component.
 *
 * Set component's internal lifecycle state automaton (if any) into 
 * Alive mode (from here on the component is ready to provide its services)
 */
void ComponentVisualization::setStartupFinished() {
	stateSlave->setWaitState("Alive");
	std::cout << "ComponentDefinition initialization/startup finished." << std::endl;
}


Smart::StatusCode ComponentVisualization::connectMarkerListDetectionServiceIn(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.markerListDetectionServiceIn.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = markerListDetectionServiceIn->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->markerListDetectionServiceIn->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	markerListDetectionServiceIn->subscribe(connections.markerListDetectionServiceIn.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectRGBDImageQueryServiceReq(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.rGBDImageQueryServiceReq.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = rGBDImageQueryServiceReq->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->rGBDImageQueryServiceReq->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	return status;
}
Smart::StatusCode ComponentVisualization::connectBaseClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.baseClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = baseClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->baseClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	baseClient->subscribe(connections.baseClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectCurPushClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.curPushClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = curPushClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->curPushClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	curPushClient->subscribe(connections.curPushClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectDepthPushNewestClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.depthPushNewestClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = depthPushNewestClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->depthPushNewestClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	depthPushNewestClient->subscribe(connections.depthPushNewestClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectImagePushNewestClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.imagePushNewestClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = imagePushNewestClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->imagePushNewestClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	imagePushNewestClient->subscribe(connections.imagePushNewestClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectIrPushNewestClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.irPushNewestClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = irPushNewestClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->irPushNewestClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	irPushNewestClient->subscribe(connections.irPushNewestClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectLaserClient1(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.laserClient1.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = laserClient1->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->laserClient1->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	laserClient1->subscribe(connections.laserClient1.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectLaserClient2(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.laserClient2.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = laserClient2->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->laserClient2->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	laserClient2->subscribe(connections.laserClient2.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectLaserClient3(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.laserClient3.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = laserClient3->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->laserClient3->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	laserClient3->subscribe(connections.laserClient3.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectLtmQueryClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.ltmQueryClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = ltmQueryClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->ltmQueryClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	return status;
}
Smart::StatusCode ComponentVisualization::connectPersonDetectionEventClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.personDetectionEventClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = personDetectionEventClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->personDetectionEventClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	return status;
}
Smart::StatusCode ComponentVisualization::connectPersonDetectionQueryClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.personDetectionQueryClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = personDetectionQueryClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->personDetectionQueryClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	return status;
}
Smart::StatusCode ComponentVisualization::connectRgbdPushNewestClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.rgbdPushNewestClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = rgbdPushNewestClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->rgbdPushNewestClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	rgbdPushNewestClient->subscribe(connections.rgbdPushNewestClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectRgbdQueryClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.rgbdQueryClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = rgbdQueryClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->rgbdQueryClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	rgbdQueryClient->subscribe(connections.rgbdQueryClient.interval);
	return status;
}
Smart::StatusCode ComponentVisualization::connectUltrasonicPushNewestClient(const std::string &serverName, const std::string &serviceName) {
	Smart::StatusCode status;
	
	if(connections.ultrasonicPushNewestClient.initialConnect == false) {
		return Smart::SMART_OK;
	}
	std::cout << "connecting to: " << serverName << "; " << serviceName << std::endl;
	status = ultrasonicPushNewestClient->connect(serverName, serviceName);
	while(status != Smart::SMART_OK)
	{
		ACE_OS::sleep(ACE_Time_Value(0,500000));
		status = COMP->ultrasonicPushNewestClient->connect(serverName, serviceName);
	}
	std::cout << "connected.\n";
	ultrasonicPushNewestClient->subscribe(connections.ultrasonicPushNewestClient.interval);
	return status;
}


/**
 * First connect ALL client ports contained in this component, then start all services:
 * activate state, push, etc...
 */
Smart::StatusCode ComponentVisualization::connectAndStartAllServices() {
	Smart::StatusCode status = Smart::SMART_OK;
	
	status = connectMarkerListDetectionServiceIn(connections.markerListDetectionServiceIn.serverName, connections.markerListDetectionServiceIn.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectRGBDImageQueryServiceReq(connections.rGBDImageQueryServiceReq.serverName, connections.rGBDImageQueryServiceReq.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectBaseClient(connections.baseClient.serverName, connections.baseClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectCurPushClient(connections.curPushClient.serverName, connections.curPushClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectDepthPushNewestClient(connections.depthPushNewestClient.serverName, connections.depthPushNewestClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectImagePushNewestClient(connections.imagePushNewestClient.serverName, connections.imagePushNewestClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectIrPushNewestClient(connections.irPushNewestClient.serverName, connections.irPushNewestClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectLaserClient1(connections.laserClient1.serverName, connections.laserClient1.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectLaserClient2(connections.laserClient2.serverName, connections.laserClient2.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectLaserClient3(connections.laserClient3.serverName, connections.laserClient3.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectLtmQueryClient(connections.ltmQueryClient.serverName, connections.ltmQueryClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectPersonDetectionEventClient(connections.personDetectionEventClient.serverName, connections.personDetectionEventClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectPersonDetectionQueryClient(connections.personDetectionQueryClient.serverName, connections.personDetectionQueryClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectRgbdPushNewestClient(connections.rgbdPushNewestClient.serverName, connections.rgbdPushNewestClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectRgbdQueryClient(connections.rgbdQueryClient.serverName, connections.rgbdQueryClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	status = connectUltrasonicPushNewestClient(connections.ultrasonicPushNewestClient.serverName, connections.ultrasonicPushNewestClient.serviceName);
	if(status != Smart::SMART_OK) return status;
	return status;
}

/**
 * Start all tasks contained in this component.
 */
void ComponentVisualization::startAllTasks() {
	// start task BaseTask
	if(connections.baseTask.scheduler != "DEFAULT") {
		ACE_Sched_Params baseTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.baseTask.scheduler == "FIFO") {
			baseTask_SchedParams.policy(ACE_SCHED_FIFO);
			baseTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.baseTask.scheduler == "RR") {
			baseTask_SchedParams.policy(ACE_SCHED_RR);
			baseTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		baseTask->start(baseTask_SchedParams, connections.baseTask.cpuAffinity);
	} else {
		baseTask->start();
	}
	// start task CurMapTask
	if(connections.curMapTask.scheduler != "DEFAULT") {
		ACE_Sched_Params curMapTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.curMapTask.scheduler == "FIFO") {
			curMapTask_SchedParams.policy(ACE_SCHED_FIFO);
			curMapTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.curMapTask.scheduler == "RR") {
			curMapTask_SchedParams.policy(ACE_SCHED_RR);
			curMapTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		curMapTask->start(curMapTask_SchedParams, connections.curMapTask.cpuAffinity);
	} else {
		curMapTask->start();
	}
	// start task DepthTask
	if(connections.depthTask.scheduler != "DEFAULT") {
		ACE_Sched_Params depthTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.depthTask.scheduler == "FIFO") {
			depthTask_SchedParams.policy(ACE_SCHED_FIFO);
			depthTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.depthTask.scheduler == "RR") {
			depthTask_SchedParams.policy(ACE_SCHED_RR);
			depthTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		depthTask->start(depthTask_SchedParams, connections.depthTask.cpuAffinity);
	} else {
		depthTask->start();
	}
	// start task IRTask
	if(connections.iRTask.scheduler != "DEFAULT") {
		ACE_Sched_Params iRTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.iRTask.scheduler == "FIFO") {
			iRTask_SchedParams.policy(ACE_SCHED_FIFO);
			iRTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.iRTask.scheduler == "RR") {
			iRTask_SchedParams.policy(ACE_SCHED_RR);
			iRTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		iRTask->start(iRTask_SchedParams, connections.iRTask.cpuAffinity);
	} else {
		iRTask->start();
	}
	// start task ImageTask
	if(connections.imageTask.scheduler != "DEFAULT") {
		ACE_Sched_Params imageTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.imageTask.scheduler == "FIFO") {
			imageTask_SchedParams.policy(ACE_SCHED_FIFO);
			imageTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.imageTask.scheduler == "RR") {
			imageTask_SchedParams.policy(ACE_SCHED_RR);
			imageTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		imageTask->start(imageTask_SchedParams, connections.imageTask.cpuAffinity);
	} else {
		imageTask->start();
	}
	// start task Laser1Task
	if(connections.laser1Task.scheduler != "DEFAULT") {
		ACE_Sched_Params laser1Task_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.laser1Task.scheduler == "FIFO") {
			laser1Task_SchedParams.policy(ACE_SCHED_FIFO);
			laser1Task_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.laser1Task.scheduler == "RR") {
			laser1Task_SchedParams.policy(ACE_SCHED_RR);
			laser1Task_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		laser1Task->start(laser1Task_SchedParams, connections.laser1Task.cpuAffinity);
	} else {
		laser1Task->start();
	}
	// start task Laser2Task
	if(connections.laser2Task.scheduler != "DEFAULT") {
		ACE_Sched_Params laser2Task_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.laser2Task.scheduler == "FIFO") {
			laser2Task_SchedParams.policy(ACE_SCHED_FIFO);
			laser2Task_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.laser2Task.scheduler == "RR") {
			laser2Task_SchedParams.policy(ACE_SCHED_RR);
			laser2Task_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		laser2Task->start(laser2Task_SchedParams, connections.laser2Task.cpuAffinity);
	} else {
		laser2Task->start();
	}
	// start task Laser3Task
	if(connections.laser3Task.scheduler != "DEFAULT") {
		ACE_Sched_Params laser3Task_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.laser3Task.scheduler == "FIFO") {
			laser3Task_SchedParams.policy(ACE_SCHED_FIFO);
			laser3Task_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.laser3Task.scheduler == "RR") {
			laser3Task_SchedParams.policy(ACE_SCHED_RR);
			laser3Task_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		laser3Task->start(laser3Task_SchedParams, connections.laser3Task.cpuAffinity);
	} else {
		laser3Task->start();
	}
	// start task ManagementTask
	if(connections.managementTask.scheduler != "DEFAULT") {
		ACE_Sched_Params managementTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.managementTask.scheduler == "FIFO") {
			managementTask_SchedParams.policy(ACE_SCHED_FIFO);
			managementTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.managementTask.scheduler == "RR") {
			managementTask_SchedParams.policy(ACE_SCHED_RR);
			managementTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		managementTask->start(managementTask_SchedParams, connections.managementTask.cpuAffinity);
	} else {
		managementTask->start();
	}
	// start task MarkerListTask
	if(connections.markerListTask.scheduler != "DEFAULT") {
		ACE_Sched_Params markerListTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.markerListTask.scheduler == "FIFO") {
			markerListTask_SchedParams.policy(ACE_SCHED_FIFO);
			markerListTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.markerListTask.scheduler == "RR") {
			markerListTask_SchedParams.policy(ACE_SCHED_RR);
			markerListTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		markerListTask->start(markerListTask_SchedParams, connections.markerListTask.cpuAffinity);
	} else {
		markerListTask->start();
	}
	// start task PersonDetectionTask
	if(connections.personDetectionTask.scheduler != "DEFAULT") {
		ACE_Sched_Params personDetectionTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.personDetectionTask.scheduler == "FIFO") {
			personDetectionTask_SchedParams.policy(ACE_SCHED_FIFO);
			personDetectionTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.personDetectionTask.scheduler == "RR") {
			personDetectionTask_SchedParams.policy(ACE_SCHED_RR);
			personDetectionTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		personDetectionTask->start(personDetectionTask_SchedParams, connections.personDetectionTask.cpuAffinity);
	} else {
		personDetectionTask->start();
	}
	// start task RGBDTask
	if(connections.rGBDTask.scheduler != "DEFAULT") {
		ACE_Sched_Params rGBDTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.rGBDTask.scheduler == "FIFO") {
			rGBDTask_SchedParams.policy(ACE_SCHED_FIFO);
			rGBDTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.rGBDTask.scheduler == "RR") {
			rGBDTask_SchedParams.policy(ACE_SCHED_RR);
			rGBDTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		rGBDTask->start(rGBDTask_SchedParams, connections.rGBDTask.cpuAffinity);
	} else {
		rGBDTask->start();
	}
	// start task USArTask
	if(connections.uSArTask.scheduler != "DEFAULT") {
		ACE_Sched_Params uSArTask_SchedParams(ACE_SCHED_OTHER, ACE_THR_PRI_OTHER_DEF);
		if(connections.uSArTask.scheduler == "FIFO") {
			uSArTask_SchedParams.policy(ACE_SCHED_FIFO);
			uSArTask_SchedParams.priority(ACE_THR_PRI_FIFO_MIN);
		} else if(connections.uSArTask.scheduler == "RR") {
			uSArTask_SchedParams.policy(ACE_SCHED_RR);
			uSArTask_SchedParams.priority(ACE_THR_PRI_RR_MIN);
		}
		uSArTask->start(uSArTask_SchedParams, connections.uSArTask.cpuAffinity);
	} else {
		uSArTask->start();
	}
}

/**
 * Start all timers contained in this component
 */
void ComponentVisualization::startAllTimers() {
}


Smart::TaskTriggerSubject* ComponentVisualization::getInputTaskTriggerFromString(const std::string &client)
{
	if(client == "MarkerListDetectionServiceIn") return markerListDetectionServiceInInputTaskTrigger;
	if(client == "baseClient") return baseClientInputTaskTrigger;
	if(client == "curPushClient") return curPushClientInputTaskTrigger;
	if(client == "depthPushNewestClient") return depthPushNewestClientInputTaskTrigger;
	if(client == "imagePushNewestClient") return imagePushNewestClientInputTaskTrigger;
	if(client == "irPushNewestClient") return irPushNewestClientInputTaskTrigger;
	if(client == "laserClient1") return laserClient1InputTaskTrigger;
	if(client == "laserClient2") return laserClient2InputTaskTrigger;
	if(client == "laserClient3") return laserClient3InputTaskTrigger;
	if(client == "personDetectionEventClient") return personDetectionEventClientInputTaskTrigger;
	if(client == "rgbdPushNewestClient") return rgbdPushNewestClientInputTaskTrigger;
	if(client == "rgbdQueryClient") return rgbdQueryClientInputTaskTrigger;
	if(client == "ultrasonicPushNewestClient") return ultrasonicPushNewestClientInputTaskTrigger;
	
	return NULL;
}


void ComponentVisualization::init(int argc, char *argv[])
{
	try {
		Smart::StatusCode status;
		
		// load initial parameters from ini-file (if found)
		loadParameter(argc, argv);
		
		// print out the actual parameters which are used to initialize the component
		std::cout << " \nComponentDefinition Initial-Parameters:\n" << COMP->getParameters() << std::endl;
		
		// initializations of OpcUaBackendComponentGeneratorExtension
		
		// initializations of ComponentVisualizationROSExtension
		
		// initializations of PlainOpcUaComponentVisualizationExtension
		
		
		// initialize all registered port-factories
		for(auto portFactory = portFactoryRegistry.begin(); portFactory != portFactoryRegistry.end(); portFactory++) 
		{
			portFactory->second->initialize(this, argc, argv);
		}
		
		// initialize all registered component-extensions
		for(auto extension = componentExtensionRegistry.begin(); extension != componentExtensionRegistry.end(); extension++) 
		{
			extension->second->initialize(this, argc, argv);
		}
		
		ComponentVisualizationPortFactoryInterface *acePortFactory = portFactoryRegistry["ACE_SmartSoft"];
		if(acePortFactory == 0) {
			std::cerr << "ERROR: acePortFactory NOT instantiated -> exit(-1)" << std::endl;
			exit(-1);
		}
		
		// this pointer is used for backwards compatibility (deprecated: should be removed as soon as all patterns, including coordination, are moved to port-factory)
		SmartACE::SmartComponent *component = dynamic_cast<ComponentVisualizationAcePortFactory*>(acePortFactory)->getComponentImpl();
		
		std::cout << "ComponentDefinition ComponentVisualization is named " << connections.component.name << std::endl;
		
		if(connections.component.useLogger == true) {
			//FIXME: use logging
			//Smart::LOGGER->openLogFileInFolder("data/"+connections.component.name);
			//Smart::LOGGER->startLogging();
		}

		// create event-test handlers (if needed)
		
		// create server ports
		// TODO: set minCycleTime from Ini-file
		
		// create client ports
		markerListDetectionServiceIn = portFactoryRegistry[connections.markerListDetectionServiceIn.roboticMiddleware]->createMarkerListDetectionServiceIn();
		rGBDImageQueryServiceReq = portFactoryRegistry[connections.rGBDImageQueryServiceReq.roboticMiddleware]->createRGBDImageQueryServiceReq();
		baseClient = portFactoryRegistry[connections.baseClient.roboticMiddleware]->createBaseClient();
		curPushClient = portFactoryRegistry[connections.curPushClient.roboticMiddleware]->createCurPushClient();
		depthPushNewestClient = portFactoryRegistry[connections.depthPushNewestClient.roboticMiddleware]->createDepthPushNewestClient();
		imagePushNewestClient = portFactoryRegistry[connections.imagePushNewestClient.roboticMiddleware]->createImagePushNewestClient();
		irPushNewestClient = portFactoryRegistry[connections.irPushNewestClient.roboticMiddleware]->createIrPushNewestClient();
		laserClient1 = portFactoryRegistry[connections.laserClient1.roboticMiddleware]->createLaserClient1();
		laserClient2 = portFactoryRegistry[connections.laserClient2.roboticMiddleware]->createLaserClient2();
		laserClient3 = portFactoryRegistry[connections.laserClient3.roboticMiddleware]->createLaserClient3();
		ltmQueryClient = portFactoryRegistry[connections.ltmQueryClient.roboticMiddleware]->createLtmQueryClient();
		personDetectionEventClient = portFactoryRegistry[connections.personDetectionEventClient.roboticMiddleware]->createPersonDetectionEventClient();
		personDetectionQueryClient = portFactoryRegistry[connections.personDetectionQueryClient.roboticMiddleware]->createPersonDetectionQueryClient();
		rgbdPushNewestClient = portFactoryRegistry[connections.rgbdPushNewestClient.roboticMiddleware]->createRgbdPushNewestClient();
		rgbdQueryClient = portFactoryRegistry[connections.rgbdQueryClient.roboticMiddleware]->createRgbdQueryClient();
		ultrasonicPushNewestClient = portFactoryRegistry[connections.ultrasonicPushNewestClient.roboticMiddleware]->createUltrasonicPushNewestClient();
		
		// create InputTaskTriggers and UpcallManagers
		markerListDetectionServiceInInputTaskTrigger = new Smart::InputTaskTrigger<CommTrackingObjects::CommDetectedMarkerList>(markerListDetectionServiceIn);
		markerListDetectionServiceInUpcallManager = new MarkerListDetectionServiceInUpcallManager(markerListDetectionServiceIn);
		baseClientInputTaskTrigger = new Smart::InputTaskTrigger<CommBasicObjects::CommBaseState>(baseClient);
		baseClientUpcallManager = new BaseClientUpcallManager(baseClient);
		curPushClientInputTaskTrigger = new Smart::InputTaskTrigger<CommNavigationObjects::CommGridMap>(curPushClient);
		curPushClientUpcallManager = new CurPushClientUpcallManager(curPushClient);
		depthPushNewestClientInputTaskTrigger = new Smart::InputTaskTrigger<DomainVision::CommDepthImage>(depthPushNewestClient);
		depthPushNewestClientUpcallManager = new DepthPushNewestClientUpcallManager(depthPushNewestClient);
		imagePushNewestClientInputTaskTrigger = new Smart::InputTaskTrigger<DomainVision::CommVideoImage>(imagePushNewestClient);
		imagePushNewestClientUpcallManager = new ImagePushNewestClientUpcallManager(imagePushNewestClient);
		irPushNewestClientInputTaskTrigger = new Smart::InputTaskTrigger<CommBasicObjects::CommMobileIRScan>(irPushNewestClient);
		irPushNewestClientUpcallManager = new IrPushNewestClientUpcallManager(irPushNewestClient);
		laserClient1InputTaskTrigger = new Smart::InputTaskTrigger<CommBasicObjects::CommMobileLaserScan>(laserClient1);
		laserClient1UpcallManager = new LaserClient1UpcallManager(laserClient1);
		laserClient2InputTaskTrigger = new Smart::InputTaskTrigger<CommBasicObjects::CommMobileLaserScan>(laserClient2);
		laserClient2UpcallManager = new LaserClient2UpcallManager(laserClient2);
		laserClient3InputTaskTrigger = new Smart::InputTaskTrigger<CommBasicObjects::CommMobileLaserScan>(laserClient3);
		laserClient3UpcallManager = new LaserClient3UpcallManager(laserClient3);
		personDetectionEventClientInputTaskTrigger = new Smart::InputTaskTrigger<Smart::EventInputType<CommTrackingObjects::CommPersonDetectionEventResult>>(personDetectionEventClient);
		personDetectionEventClientUpcallManager = new PersonDetectionEventClientUpcallManager(personDetectionEventClient);
		rgbdPushNewestClientInputTaskTrigger = new Smart::InputTaskTrigger<DomainVision::CommRGBDImage>(rgbdPushNewestClient);
		rgbdPushNewestClientUpcallManager = new RgbdPushNewestClientUpcallManager(rgbdPushNewestClient);
		rgbdQueryClientInputTaskTrigger = new Smart::InputTaskTrigger<DomainVision::CommDepthImage>(rgbdQueryClient);
		rgbdQueryClientUpcallManager = new RgbdQueryClientUpcallManager(rgbdQueryClient);
		ultrasonicPushNewestClientInputTaskTrigger = new Smart::InputTaskTrigger<CommBasicObjects::CommMobileUltrasonicScan>(ultrasonicPushNewestClient);
		ultrasonicPushNewestClientUpcallManager = new UltrasonicPushNewestClientUpcallManager(ultrasonicPushNewestClient);
		
		// create input-handler
		
		// create request-handlers
		
		// create state pattern
		stateChangeHandler = new SmartStateChangeHandler();
		stateSlave = new SmartACE::StateSlave(component, stateChangeHandler);
		status = stateSlave->setUpInitialState(connections.component.initialComponentMode);
		if (status != Smart::SMART_OK) std::cerr << status << "; failed setting initial ComponentMode: " << connections.component.initialComponentMode << std::endl;
		// activate state slave
		status = stateSlave->activate();
		if(status != Smart::SMART_OK) std::cerr << "ERROR: activate state" << std::endl;
		
		wiringSlave = new SmartACE::WiringSlave(component);
		// add client port to wiring slave
		if(connections.markerListDetectionServiceIn.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommTrackingObjects::CommDetectedMarkerList>*>(markerListDetectionServiceIn)->add(wiringSlave, connections.markerListDetectionServiceIn.wiringName);
		}
		if(connections.rGBDImageQueryServiceReq.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::QueryClient<CommBasicObjects::CommVoid, DomainVision::CommRGBDImage>*>(rGBDImageQueryServiceReq)->add(wiringSlave, connections.rGBDImageQueryServiceReq.wiringName);
		}
		if(connections.baseClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommBasicObjects::CommBaseState>*>(baseClient)->add(wiringSlave, connections.baseClient.wiringName);
		}
		if(connections.curPushClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommNavigationObjects::CommGridMap>*>(curPushClient)->add(wiringSlave, connections.curPushClient.wiringName);
		}
		if(connections.depthPushNewestClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<DomainVision::CommDepthImage>*>(depthPushNewestClient)->add(wiringSlave, connections.depthPushNewestClient.wiringName);
		}
		if(connections.imagePushNewestClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<DomainVision::CommVideoImage>*>(imagePushNewestClient)->add(wiringSlave, connections.imagePushNewestClient.wiringName);
		}
		if(connections.irPushNewestClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommBasicObjects::CommMobileIRScan>*>(irPushNewestClient)->add(wiringSlave, connections.irPushNewestClient.wiringName);
		}
		if(connections.laserClient1.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommBasicObjects::CommMobileLaserScan>*>(laserClient1)->add(wiringSlave, connections.laserClient1.wiringName);
		}
		if(connections.laserClient2.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommBasicObjects::CommMobileLaserScan>*>(laserClient2)->add(wiringSlave, connections.laserClient2.wiringName);
		}
		if(connections.laserClient3.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommBasicObjects::CommMobileLaserScan>*>(laserClient3)->add(wiringSlave, connections.laserClient3.wiringName);
		}
		if(connections.ltmQueryClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::QueryClient<CommNavigationObjects::CommGridMapRequest, CommNavigationObjects::CommGridMap>*>(ltmQueryClient)->add(wiringSlave, connections.ltmQueryClient.wiringName);
		}
		if(connections.personDetectionEventClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::EventClient<CommTrackingObjects::CommPersonLostEventParameter, CommTrackingObjects::CommPersonDetectionEventResult>*>(personDetectionEventClient)->add(wiringSlave, connections.personDetectionEventClient.wiringName);
		}
		if(connections.personDetectionQueryClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::QueryClient<CommTrackingObjects::CommPersonId, CommTrackingObjects::CommDetectedPerson>*>(personDetectionQueryClient)->add(wiringSlave, connections.personDetectionQueryClient.wiringName);
		}
		if(connections.rgbdPushNewestClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<DomainVision::CommRGBDImage>*>(rgbdPushNewestClient)->add(wiringSlave, connections.rgbdPushNewestClient.wiringName);
		}
		if(connections.rgbdQueryClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<DomainVision::CommDepthImage>*>(rgbdQueryClient)->add(wiringSlave, connections.rgbdQueryClient.wiringName);
		}
		if(connections.ultrasonicPushNewestClient.roboticMiddleware == "ACE_SmartSoft") {
			//FIXME: this must also work with other implementations
			dynamic_cast<SmartACE::PushClient<CommBasicObjects::CommMobileUltrasonicScan>*>(ultrasonicPushNewestClient)->add(wiringSlave, connections.ultrasonicPushNewestClient.wiringName);
		}
		
		// create parameter slave
		param = new SmartACE::ParameterSlave(component, &paramHandler);
		
		
		// create Task BaseTask
		baseTask = new BaseTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.baseTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.baseTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(baseTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				baseTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task BaseTask" << std::endl;
			}
		} else if(connections.baseTask.trigger == "DataTriggered") {
			baseTaskTrigger = getInputTaskTriggerFromString(connections.baseTask.inPortRef);
			if(baseTaskTrigger != NULL) {
				baseTaskTrigger->attach(baseTask, connections.baseTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.baseTask.inPortRef << " as activation source for Task BaseTask" << std::endl;
			}
		} 
		
		// create Task CurMapTask
		curMapTask = new CurMapTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.curMapTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.curMapTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(curMapTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				curMapTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task CurMapTask" << std::endl;
			}
		} else if(connections.curMapTask.trigger == "DataTriggered") {
			curMapTaskTrigger = getInputTaskTriggerFromString(connections.curMapTask.inPortRef);
			if(curMapTaskTrigger != NULL) {
				curMapTaskTrigger->attach(curMapTask, connections.curMapTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.curMapTask.inPortRef << " as activation source for Task CurMapTask" << std::endl;
			}
		} 
		
		// create Task DepthTask
		depthTask = new DepthTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.depthTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.depthTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(depthTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				depthTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task DepthTask" << std::endl;
			}
		} else if(connections.depthTask.trigger == "DataTriggered") {
			depthTaskTrigger = getInputTaskTriggerFromString(connections.depthTask.inPortRef);
			if(depthTaskTrigger != NULL) {
				depthTaskTrigger->attach(depthTask, connections.depthTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.depthTask.inPortRef << " as activation source for Task DepthTask" << std::endl;
			}
		} 
		
		// create Task IRTask
		iRTask = new IRTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.iRTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.iRTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(iRTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				iRTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task IRTask" << std::endl;
			}
		} else if(connections.iRTask.trigger == "DataTriggered") {
			iRTaskTrigger = getInputTaskTriggerFromString(connections.iRTask.inPortRef);
			if(iRTaskTrigger != NULL) {
				iRTaskTrigger->attach(iRTask, connections.iRTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.iRTask.inPortRef << " as activation source for Task IRTask" << std::endl;
			}
		} 
		
		// create Task ImageTask
		imageTask = new ImageTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.imageTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.imageTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(imageTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				imageTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task ImageTask" << std::endl;
			}
		} else if(connections.imageTask.trigger == "DataTriggered") {
			imageTaskTrigger = getInputTaskTriggerFromString(connections.imageTask.inPortRef);
			if(imageTaskTrigger != NULL) {
				imageTaskTrigger->attach(imageTask, connections.imageTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.imageTask.inPortRef << " as activation source for Task ImageTask" << std::endl;
			}
		} 
		
		// create Task Laser1Task
		laser1Task = new Laser1Task(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.laser1Task.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.laser1Task.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(laser1Task);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				laser1TaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task Laser1Task" << std::endl;
			}
		} else if(connections.laser1Task.trigger == "DataTriggered") {
			laser1TaskTrigger = getInputTaskTriggerFromString(connections.laser1Task.inPortRef);
			if(laser1TaskTrigger != NULL) {
				laser1TaskTrigger->attach(laser1Task, connections.laser1Task.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.laser1Task.inPortRef << " as activation source for Task Laser1Task" << std::endl;
			}
		} 
		
		// create Task Laser2Task
		laser2Task = new Laser2Task(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.laser2Task.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.laser2Task.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(laser2Task);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				laser2TaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task Laser2Task" << std::endl;
			}
		} else if(connections.laser2Task.trigger == "DataTriggered") {
			laser2TaskTrigger = getInputTaskTriggerFromString(connections.laser2Task.inPortRef);
			if(laser2TaskTrigger != NULL) {
				laser2TaskTrigger->attach(laser2Task, connections.laser2Task.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.laser2Task.inPortRef << " as activation source for Task Laser2Task" << std::endl;
			}
		} 
		
		// create Task Laser3Task
		laser3Task = new Laser3Task(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.laser3Task.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.laser3Task.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(laser3Task);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				laser3TaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task Laser3Task" << std::endl;
			}
		} else if(connections.laser3Task.trigger == "DataTriggered") {
			laser3TaskTrigger = getInputTaskTriggerFromString(connections.laser3Task.inPortRef);
			if(laser3TaskTrigger != NULL) {
				laser3TaskTrigger->attach(laser3Task, connections.laser3Task.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.laser3Task.inPortRef << " as activation source for Task Laser3Task" << std::endl;
			}
		} 
		
		// create Task ManagementTask
		managementTask = new ManagementTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.managementTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.managementTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(managementTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				managementTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task ManagementTask" << std::endl;
			}
		} else if(connections.managementTask.trigger == "DataTriggered") {
			managementTaskTrigger = getInputTaskTriggerFromString(connections.managementTask.inPortRef);
			if(managementTaskTrigger != NULL) {
				managementTaskTrigger->attach(managementTask, connections.managementTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.managementTask.inPortRef << " as activation source for Task ManagementTask" << std::endl;
			}
		} 
		
		// create Task MarkerListTask
		markerListTask = new MarkerListTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.markerListTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.markerListTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(markerListTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				markerListTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task MarkerListTask" << std::endl;
			}
		} else if(connections.markerListTask.trigger == "DataTriggered") {
			markerListTaskTrigger = getInputTaskTriggerFromString(connections.markerListTask.inPortRef);
			if(markerListTaskTrigger != NULL) {
				markerListTaskTrigger->attach(markerListTask, connections.markerListTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.markerListTask.inPortRef << " as activation source for Task MarkerListTask" << std::endl;
			}
		} 
		
		// create Task PersonDetectionTask
		personDetectionTask = new PersonDetectionTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.personDetectionTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.personDetectionTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(personDetectionTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				personDetectionTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task PersonDetectionTask" << std::endl;
			}
		} else if(connections.personDetectionTask.trigger == "DataTriggered") {
			personDetectionTaskTrigger = getInputTaskTriggerFromString(connections.personDetectionTask.inPortRef);
			if(personDetectionTaskTrigger != NULL) {
				personDetectionTaskTrigger->attach(personDetectionTask, connections.personDetectionTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.personDetectionTask.inPortRef << " as activation source for Task PersonDetectionTask" << std::endl;
			}
		} 
		
		// create Task RGBDTask
		rGBDTask = new RGBDTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.rGBDTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.rGBDTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(rGBDTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				rGBDTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task RGBDTask" << std::endl;
			}
		} else if(connections.rGBDTask.trigger == "DataTriggered") {
			rGBDTaskTrigger = getInputTaskTriggerFromString(connections.rGBDTask.inPortRef);
			if(rGBDTaskTrigger != NULL) {
				rGBDTaskTrigger->attach(rGBDTask, connections.rGBDTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.rGBDTask.inPortRef << " as activation source for Task RGBDTask" << std::endl;
			}
		} 
		
		// create Task USArTask
		uSArTask = new USArTask(component);
		// configure input-links
		// configure task-trigger (if task is configurable)
		if(connections.uSArTask.trigger == "PeriodicTimer") {
			// create PeriodicTimerTrigger
			int microseconds = 1000*1000 / connections.uSArTask.periodicActFreq;
			if(microseconds > 0) {
				Smart::TimedTaskTrigger *triggerPtr = new Smart::TimedTaskTrigger();
				triggerPtr->attach(uSArTask);
				component->getTimerManager()->scheduleTimer(triggerPtr, (void *) 0, std::chrono::microseconds(microseconds), std::chrono::microseconds(microseconds));
				// store trigger in class member
				uSArTaskTrigger = triggerPtr;
			} else {
				std::cerr << "ERROR: could not set-up Timer with cycle-time " << microseconds << " as activation source for Task USArTask" << std::endl;
			}
		} else if(connections.uSArTask.trigger == "DataTriggered") {
			uSArTaskTrigger = getInputTaskTriggerFromString(connections.uSArTask.inPortRef);
			if(uSArTaskTrigger != NULL) {
				uSArTaskTrigger->attach(uSArTask, connections.uSArTask.prescale);
			} else {
				std::cerr << "ERROR: could not set-up InPort " << connections.uSArTask.inPortRef << " as activation source for Task USArTask" << std::endl;
			}
		} 
		
		
		// link observers with subjects
	} catch (const std::exception &ex) {
		std::cerr << "Uncaught std exception" << ex.what() << std::endl;
	} catch (...) {
		std::cerr << "Uncaught exception" << std::endl;
	}
}

// run the component
void ComponentVisualization::run()
{
	stateSlave->acquire("init");
	// startup all registered port-factories
	for(auto portFactory = portFactoryRegistry.begin(); portFactory != portFactoryRegistry.end(); portFactory++) 
	{
		portFactory->second->onStartup();
	}
	
	// startup all registered component-extensions
	for(auto extension = componentExtensionRegistry.begin(); extension != componentExtensionRegistry.end(); extension++) 
	{
		extension->second->onStartup();
	}
	stateSlave->release("init");
	
	// do not call this handler within the init state (see above) as this handler internally calls setStartupFinished() (this should be fixed in future)
	compHandler.onStartup();
	
	// this call blocks until the component is commanded to shutdown
	stateSlave->acquire("shutdown");
	
	// shutdown all registered component-extensions
	for(auto extension = componentExtensionRegistry.begin(); extension != componentExtensionRegistry.end(); extension++) 
	{
		extension->second->onShutdown();
	}
	
	// shutdown all registered port-factories
	for(auto portFactory = portFactoryRegistry.begin(); portFactory != portFactoryRegistry.end(); portFactory++) 
	{
		portFactory->second->onShutdown();
	}
	
	if(connections.component.useLogger == true) {
		//FIXME: use logging
		//Smart::LOGGER->stopLogging();
	}
	
	compHandler.onShutdown();
	
	stateSlave->release("shutdown");
}

// clean-up component's resources
void ComponentVisualization::fini()
{
	// unlink all observers
	
	// destroy all task instances
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(baseTaskTrigger != NULL){
		baseTaskTrigger->detach(baseTask);
		delete baseTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(curMapTaskTrigger != NULL){
		curMapTaskTrigger->detach(curMapTask);
		delete curMapTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(depthTaskTrigger != NULL){
		depthTaskTrigger->detach(depthTask);
		delete depthTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(iRTaskTrigger != NULL){
		iRTaskTrigger->detach(iRTask);
		delete iRTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(imageTaskTrigger != NULL){
		imageTaskTrigger->detach(imageTask);
		delete imageTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(laser1TaskTrigger != NULL){
		laser1TaskTrigger->detach(laser1Task);
		delete laser1Task;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(laser2TaskTrigger != NULL){
		laser2TaskTrigger->detach(laser2Task);
		delete laser2Task;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(laser3TaskTrigger != NULL){
		laser3TaskTrigger->detach(laser3Task);
		delete laser3Task;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(managementTaskTrigger != NULL){
		managementTaskTrigger->detach(managementTask);
		delete managementTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(markerListTaskTrigger != NULL){
		markerListTaskTrigger->detach(markerListTask);
		delete markerListTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(personDetectionTaskTrigger != NULL){
		personDetectionTaskTrigger->detach(personDetectionTask);
		delete personDetectionTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(rGBDTaskTrigger != NULL){
		rGBDTaskTrigger->detach(rGBDTask);
		delete rGBDTask;
	}
	// unlink all UpcallManagers
	// unlink the TaskTrigger
	if(uSArTaskTrigger != NULL){
		uSArTaskTrigger->detach(uSArTask);
		delete uSArTask;
	}

	// destroy all input-handler

	// destroy InputTaskTriggers and UpcallManagers
	delete markerListDetectionServiceInInputTaskTrigger;
	delete markerListDetectionServiceInUpcallManager;
	delete baseClientInputTaskTrigger;
	delete baseClientUpcallManager;
	delete curPushClientInputTaskTrigger;
	delete curPushClientUpcallManager;
	delete depthPushNewestClientInputTaskTrigger;
	delete depthPushNewestClientUpcallManager;
	delete imagePushNewestClientInputTaskTrigger;
	delete imagePushNewestClientUpcallManager;
	delete irPushNewestClientInputTaskTrigger;
	delete irPushNewestClientUpcallManager;
	delete laserClient1InputTaskTrigger;
	delete laserClient1UpcallManager;
	delete laserClient2InputTaskTrigger;
	delete laserClient2UpcallManager;
	delete laserClient3InputTaskTrigger;
	delete laserClient3UpcallManager;
	delete personDetectionEventClientInputTaskTrigger;
	delete personDetectionEventClientUpcallManager;
	delete rgbdPushNewestClientInputTaskTrigger;
	delete rgbdPushNewestClientUpcallManager;
	delete rgbdQueryClientInputTaskTrigger;
	delete rgbdQueryClientUpcallManager;
	delete ultrasonicPushNewestClientInputTaskTrigger;
	delete ultrasonicPushNewestClientUpcallManager;

	// destroy client ports
	delete markerListDetectionServiceIn;
	delete rGBDImageQueryServiceReq;
	delete baseClient;
	delete curPushClient;
	delete depthPushNewestClient;
	delete imagePushNewestClient;
	delete irPushNewestClient;
	delete laserClient1;
	delete laserClient2;
	delete laserClient3;
	delete ltmQueryClient;
	delete personDetectionEventClient;
	delete personDetectionQueryClient;
	delete rgbdPushNewestClient;
	delete rgbdQueryClient;
	delete ultrasonicPushNewestClient;

	// destroy server ports
	// destroy event-test handlers (if needed)
	
	// destroy request-handlers
	
	delete stateSlave;
	// destroy state-change-handler
	delete stateChangeHandler;
	
	// destroy all master/slave ports
	delete wiringSlave;
	delete param;
	

	// destroy all registered component-extensions
	for(auto extension = componentExtensionRegistry.begin(); extension != componentExtensionRegistry.end(); extension++) 
	{
		extension->second->destroy();
	}

	// destroy all registered port-factories
	for(auto portFactory = portFactoryRegistry.begin(); portFactory != portFactoryRegistry.end(); portFactory++) 
	{
		portFactory->second->destroy();
	}
	
	// destruction of OpcUaBackendComponentGeneratorExtension
	
	// destruction of ComponentVisualizationROSExtension
	
	// destruction of PlainOpcUaComponentVisualizationExtension
	
}

void ComponentVisualization::loadParameter(int argc, char *argv[])
{
	/*
	 Parameters can be specified via command line --filename=<filename> or -f <filename>

	 With this parameter present:
	   - The component will look for the file in the current working directory,
	     a path relative to the current directory or any absolute path
	   - The component will use the default values if the file cannot be found

	 With this parameter absent:
	   - <Name of Component>.ini will be read from current working directory, if found there
	   - $SMART_ROOT/etc/<Name of Component>.ini will be read otherwise
	   - Default values will be used if neither found in working directory or /etc
	 */
	SmartACE::SmartIniParameter parameter;
	std::ifstream parameterfile;
	bool parameterFileFound = false;

	// load parameters
	try
	{
		// if paramfile is given as argument
		if(parameter.tryAddFileFromArgs(argc,argv,"filename", 'f'))
		{
			parameterFileFound = true;
			std::cout << "parameter file is loaded from an argv argument \n";
		} else if(parameter.searchFile("ComponentVisualization.ini", parameterfile)) {
			parameterFileFound = true;
			std::cout << "load ComponentVisualization.ini parameter file\n";
			parameter.addFile(parameterfile);
		} else {
			std::cout << "WARNING: ComponentVisualization.ini parameter file not found! (using default values or command line arguments)\n";
		}
		
		// add command line arguments to allow overwriting of parameters
		// from file
		parameter.addCommandLineArgs(argc,argv,"component");
		
		// initialize the naming service using the command line parameters parsed in the
		// SmartIniParameter class. The naming service parameters are expected to be in
		// the "component" parameter group.
		SmartACE::NAMING::instance()->checkForHelpArg(argc,argv);
		if(parameterFileFound) 
		{
			if(SmartACE::NAMING::instance()->init(parameter.getAllParametersFromGroup("component")) != 0) {
				// initialization of naming service failed
				throw std::logic_error( "<NamingService> Service initialization failed!\nPossible causes could be:\n-> Erroneous configuration.\n-> Naming service not reachable.\n" );
			}
		} else {
			if(SmartACE::NAMING::instance()->init(argc, argv) != 0) {
				// initialization of naming service failed
				throw std::logic_error( "<NamingService> Service initialization failed!\nPossible causes could be:\n-> Erroneous configuration.\n-> Naming service not reachable.\n" );
			}
		}
			
		// print all known parameters
		// parameter.print();
		
		//--- server port // client port // other parameter ---
		// load parameter
		parameter.getString("component", "name", connections.component.name);
		parameter.getString("component", "initialComponentMode", connections.component.initialComponentMode);
		if(parameter.checkIfParameterExists("component", "defaultScheduler")) {
			parameter.getString("component", "defaultScheduler", connections.component.defaultScheduler);
		}
		if(parameter.checkIfParameterExists("component", "useLogger")) {
			parameter.getBoolean("component", "useLogger", connections.component.useLogger);
		}
		
		// load parameters for client MarkerListDetectionServiceIn
		parameter.getBoolean("MarkerListDetectionServiceIn", "initialConnect", connections.markerListDetectionServiceIn.initialConnect);
		parameter.getString("MarkerListDetectionServiceIn", "serviceName", connections.markerListDetectionServiceIn.serviceName);
		parameter.getString("MarkerListDetectionServiceIn", "serverName", connections.markerListDetectionServiceIn.serverName);
		parameter.getString("MarkerListDetectionServiceIn", "wiringName", connections.markerListDetectionServiceIn.wiringName);
		parameter.getInteger("MarkerListDetectionServiceIn", "interval", connections.markerListDetectionServiceIn.interval);
		if(parameter.checkIfParameterExists("MarkerListDetectionServiceIn", "roboticMiddleware")) {
			parameter.getString("MarkerListDetectionServiceIn", "roboticMiddleware", connections.markerListDetectionServiceIn.roboticMiddleware);
		}
		// load parameters for client RGBDImageQueryServiceReq
		parameter.getBoolean("RGBDImageQueryServiceReq", "initialConnect", connections.rGBDImageQueryServiceReq.initialConnect);
		parameter.getString("RGBDImageQueryServiceReq", "serviceName", connections.rGBDImageQueryServiceReq.serviceName);
		parameter.getString("RGBDImageQueryServiceReq", "serverName", connections.rGBDImageQueryServiceReq.serverName);
		parameter.getString("RGBDImageQueryServiceReq", "wiringName", connections.rGBDImageQueryServiceReq.wiringName);
		if(parameter.checkIfParameterExists("RGBDImageQueryServiceReq", "roboticMiddleware")) {
			parameter.getString("RGBDImageQueryServiceReq", "roboticMiddleware", connections.rGBDImageQueryServiceReq.roboticMiddleware);
		}
		// load parameters for client baseClient
		parameter.getBoolean("baseClient", "initialConnect", connections.baseClient.initialConnect);
		parameter.getString("baseClient", "serviceName", connections.baseClient.serviceName);
		parameter.getString("baseClient", "serverName", connections.baseClient.serverName);
		parameter.getString("baseClient", "wiringName", connections.baseClient.wiringName);
		parameter.getInteger("baseClient", "interval", connections.baseClient.interval);
		if(parameter.checkIfParameterExists("baseClient", "roboticMiddleware")) {
			parameter.getString("baseClient", "roboticMiddleware", connections.baseClient.roboticMiddleware);
		}
		// load parameters for client curPushClient
		parameter.getBoolean("curPushClient", "initialConnect", connections.curPushClient.initialConnect);
		parameter.getString("curPushClient", "serviceName", connections.curPushClient.serviceName);
		parameter.getString("curPushClient", "serverName", connections.curPushClient.serverName);
		parameter.getString("curPushClient", "wiringName", connections.curPushClient.wiringName);
		parameter.getInteger("curPushClient", "interval", connections.curPushClient.interval);
		if(parameter.checkIfParameterExists("curPushClient", "roboticMiddleware")) {
			parameter.getString("curPushClient", "roboticMiddleware", connections.curPushClient.roboticMiddleware);
		}
		// load parameters for client depthPushNewestClient
		parameter.getBoolean("depthPushNewestClient", "initialConnect", connections.depthPushNewestClient.initialConnect);
		parameter.getString("depthPushNewestClient", "serviceName", connections.depthPushNewestClient.serviceName);
		parameter.getString("depthPushNewestClient", "serverName", connections.depthPushNewestClient.serverName);
		parameter.getString("depthPushNewestClient", "wiringName", connections.depthPushNewestClient.wiringName);
		parameter.getInteger("depthPushNewestClient", "interval", connections.depthPushNewestClient.interval);
		if(parameter.checkIfParameterExists("depthPushNewestClient", "roboticMiddleware")) {
			parameter.getString("depthPushNewestClient", "roboticMiddleware", connections.depthPushNewestClient.roboticMiddleware);
		}
		// load parameters for client imagePushNewestClient
		parameter.getBoolean("imagePushNewestClient", "initialConnect", connections.imagePushNewestClient.initialConnect);
		parameter.getString("imagePushNewestClient", "serviceName", connections.imagePushNewestClient.serviceName);
		parameter.getString("imagePushNewestClient", "serverName", connections.imagePushNewestClient.serverName);
		parameter.getString("imagePushNewestClient", "wiringName", connections.imagePushNewestClient.wiringName);
		parameter.getInteger("imagePushNewestClient", "interval", connections.imagePushNewestClient.interval);
		if(parameter.checkIfParameterExists("imagePushNewestClient", "roboticMiddleware")) {
			parameter.getString("imagePushNewestClient", "roboticMiddleware", connections.imagePushNewestClient.roboticMiddleware);
		}
		// load parameters for client irPushNewestClient
		parameter.getBoolean("irPushNewestClient", "initialConnect", connections.irPushNewestClient.initialConnect);
		parameter.getString("irPushNewestClient", "serviceName", connections.irPushNewestClient.serviceName);
		parameter.getString("irPushNewestClient", "serverName", connections.irPushNewestClient.serverName);
		parameter.getString("irPushNewestClient", "wiringName", connections.irPushNewestClient.wiringName);
		parameter.getInteger("irPushNewestClient", "interval", connections.irPushNewestClient.interval);
		if(parameter.checkIfParameterExists("irPushNewestClient", "roboticMiddleware")) {
			parameter.getString("irPushNewestClient", "roboticMiddleware", connections.irPushNewestClient.roboticMiddleware);
		}
		// load parameters for client laserClient1
		parameter.getBoolean("laserClient1", "initialConnect", connections.laserClient1.initialConnect);
		parameter.getString("laserClient1", "serviceName", connections.laserClient1.serviceName);
		parameter.getString("laserClient1", "serverName", connections.laserClient1.serverName);
		parameter.getString("laserClient1", "wiringName", connections.laserClient1.wiringName);
		parameter.getInteger("laserClient1", "interval", connections.laserClient1.interval);
		if(parameter.checkIfParameterExists("laserClient1", "roboticMiddleware")) {
			parameter.getString("laserClient1", "roboticMiddleware", connections.laserClient1.roboticMiddleware);
		}
		// load parameters for client laserClient2
		parameter.getBoolean("laserClient2", "initialConnect", connections.laserClient2.initialConnect);
		parameter.getString("laserClient2", "serviceName", connections.laserClient2.serviceName);
		parameter.getString("laserClient2", "serverName", connections.laserClient2.serverName);
		parameter.getString("laserClient2", "wiringName", connections.laserClient2.wiringName);
		parameter.getInteger("laserClient2", "interval", connections.laserClient2.interval);
		if(parameter.checkIfParameterExists("laserClient2", "roboticMiddleware")) {
			parameter.getString("laserClient2", "roboticMiddleware", connections.laserClient2.roboticMiddleware);
		}
		// load parameters for client laserClient3
		parameter.getBoolean("laserClient3", "initialConnect", connections.laserClient3.initialConnect);
		parameter.getString("laserClient3", "serviceName", connections.laserClient3.serviceName);
		parameter.getString("laserClient3", "serverName", connections.laserClient3.serverName);
		parameter.getString("laserClient3", "wiringName", connections.laserClient3.wiringName);
		parameter.getInteger("laserClient3", "interval", connections.laserClient3.interval);
		if(parameter.checkIfParameterExists("laserClient3", "roboticMiddleware")) {
			parameter.getString("laserClient3", "roboticMiddleware", connections.laserClient3.roboticMiddleware);
		}
		// load parameters for client ltmQueryClient
		parameter.getBoolean("ltmQueryClient", "initialConnect", connections.ltmQueryClient.initialConnect);
		parameter.getString("ltmQueryClient", "serviceName", connections.ltmQueryClient.serviceName);
		parameter.getString("ltmQueryClient", "serverName", connections.ltmQueryClient.serverName);
		parameter.getString("ltmQueryClient", "wiringName", connections.ltmQueryClient.wiringName);
		if(parameter.checkIfParameterExists("ltmQueryClient", "roboticMiddleware")) {
			parameter.getString("ltmQueryClient", "roboticMiddleware", connections.ltmQueryClient.roboticMiddleware);
		}
		// load parameters for client personDetectionEventClient
		parameter.getBoolean("personDetectionEventClient", "initialConnect", connections.personDetectionEventClient.initialConnect);
		parameter.getString("personDetectionEventClient", "serviceName", connections.personDetectionEventClient.serviceName);
		parameter.getString("personDetectionEventClient", "serverName", connections.personDetectionEventClient.serverName);
		parameter.getString("personDetectionEventClient", "wiringName", connections.personDetectionEventClient.wiringName);
		if(parameter.checkIfParameterExists("personDetectionEventClient", "roboticMiddleware")) {
			parameter.getString("personDetectionEventClient", "roboticMiddleware", connections.personDetectionEventClient.roboticMiddleware);
		}
		// load parameters for client personDetectionQueryClient
		parameter.getBoolean("personDetectionQueryClient", "initialConnect", connections.personDetectionQueryClient.initialConnect);
		parameter.getString("personDetectionQueryClient", "serviceName", connections.personDetectionQueryClient.serviceName);
		parameter.getString("personDetectionQueryClient", "serverName", connections.personDetectionQueryClient.serverName);
		parameter.getString("personDetectionQueryClient", "wiringName", connections.personDetectionQueryClient.wiringName);
		if(parameter.checkIfParameterExists("personDetectionQueryClient", "roboticMiddleware")) {
			parameter.getString("personDetectionQueryClient", "roboticMiddleware", connections.personDetectionQueryClient.roboticMiddleware);
		}
		// load parameters for client rgbdPushNewestClient
		parameter.getBoolean("rgbdPushNewestClient", "initialConnect", connections.rgbdPushNewestClient.initialConnect);
		parameter.getString("rgbdPushNewestClient", "serviceName", connections.rgbdPushNewestClient.serviceName);
		parameter.getString("rgbdPushNewestClient", "serverName", connections.rgbdPushNewestClient.serverName);
		parameter.getString("rgbdPushNewestClient", "wiringName", connections.rgbdPushNewestClient.wiringName);
		parameter.getInteger("rgbdPushNewestClient", "interval", connections.rgbdPushNewestClient.interval);
		if(parameter.checkIfParameterExists("rgbdPushNewestClient", "roboticMiddleware")) {
			parameter.getString("rgbdPushNewestClient", "roboticMiddleware", connections.rgbdPushNewestClient.roboticMiddleware);
		}
		// load parameters for client rgbdQueryClient
		parameter.getBoolean("rgbdQueryClient", "initialConnect", connections.rgbdQueryClient.initialConnect);
		parameter.getString("rgbdQueryClient", "serviceName", connections.rgbdQueryClient.serviceName);
		parameter.getString("rgbdQueryClient", "serverName", connections.rgbdQueryClient.serverName);
		parameter.getString("rgbdQueryClient", "wiringName", connections.rgbdQueryClient.wiringName);
		parameter.getInteger("rgbdQueryClient", "interval", connections.rgbdQueryClient.interval);
		if(parameter.checkIfParameterExists("rgbdQueryClient", "roboticMiddleware")) {
			parameter.getString("rgbdQueryClient", "roboticMiddleware", connections.rgbdQueryClient.roboticMiddleware);
		}
		// load parameters for client ultrasonicPushNewestClient
		parameter.getBoolean("ultrasonicPushNewestClient", "initialConnect", connections.ultrasonicPushNewestClient.initialConnect);
		parameter.getString("ultrasonicPushNewestClient", "serviceName", connections.ultrasonicPushNewestClient.serviceName);
		parameter.getString("ultrasonicPushNewestClient", "serverName", connections.ultrasonicPushNewestClient.serverName);
		parameter.getString("ultrasonicPushNewestClient", "wiringName", connections.ultrasonicPushNewestClient.wiringName);
		parameter.getInteger("ultrasonicPushNewestClient", "interval", connections.ultrasonicPushNewestClient.interval);
		if(parameter.checkIfParameterExists("ultrasonicPushNewestClient", "roboticMiddleware")) {
			parameter.getString("ultrasonicPushNewestClient", "roboticMiddleware", connections.ultrasonicPushNewestClient.roboticMiddleware);
		}
		
		
		// load parameters for task BaseTask
		parameter.getDouble("BaseTask", "minActFreqHz", connections.baseTask.minActFreq);
		parameter.getDouble("BaseTask", "maxActFreqHz", connections.baseTask.maxActFreq);
		parameter.getString("BaseTask", "triggerType", connections.baseTask.trigger);
		if(connections.baseTask.trigger == "PeriodicTimer") {
			parameter.getDouble("BaseTask", "periodicActFreqHz", connections.baseTask.periodicActFreq);
		} else if(connections.baseTask.trigger == "DataTriggered") {
			parameter.getString("BaseTask", "inPortRef", connections.baseTask.inPortRef);
			parameter.getInteger("BaseTask", "prescale", connections.baseTask.prescale);
		}
		if(parameter.checkIfParameterExists("BaseTask", "scheduler")) {
			parameter.getString("BaseTask", "scheduler", connections.baseTask.scheduler);
		}
		if(parameter.checkIfParameterExists("BaseTask", "priority")) {
			parameter.getInteger("BaseTask", "priority", connections.baseTask.priority);
		}
		if(parameter.checkIfParameterExists("BaseTask", "cpuAffinity")) {
			parameter.getInteger("BaseTask", "cpuAffinity", connections.baseTask.cpuAffinity);
		}
		// load parameters for task CurMapTask
		parameter.getDouble("CurMapTask", "minActFreqHz", connections.curMapTask.minActFreq);
		parameter.getDouble("CurMapTask", "maxActFreqHz", connections.curMapTask.maxActFreq);
		parameter.getString("CurMapTask", "triggerType", connections.curMapTask.trigger);
		if(connections.curMapTask.trigger == "PeriodicTimer") {
			parameter.getDouble("CurMapTask", "periodicActFreqHz", connections.curMapTask.periodicActFreq);
		} else if(connections.curMapTask.trigger == "DataTriggered") {
			parameter.getString("CurMapTask", "inPortRef", connections.curMapTask.inPortRef);
			parameter.getInteger("CurMapTask", "prescale", connections.curMapTask.prescale);
		}
		if(parameter.checkIfParameterExists("CurMapTask", "scheduler")) {
			parameter.getString("CurMapTask", "scheduler", connections.curMapTask.scheduler);
		}
		if(parameter.checkIfParameterExists("CurMapTask", "priority")) {
			parameter.getInteger("CurMapTask", "priority", connections.curMapTask.priority);
		}
		if(parameter.checkIfParameterExists("CurMapTask", "cpuAffinity")) {
			parameter.getInteger("CurMapTask", "cpuAffinity", connections.curMapTask.cpuAffinity);
		}
		// load parameters for task DepthTask
		parameter.getDouble("DepthTask", "minActFreqHz", connections.depthTask.minActFreq);
		parameter.getDouble("DepthTask", "maxActFreqHz", connections.depthTask.maxActFreq);
		parameter.getString("DepthTask", "triggerType", connections.depthTask.trigger);
		if(connections.depthTask.trigger == "PeriodicTimer") {
			parameter.getDouble("DepthTask", "periodicActFreqHz", connections.depthTask.periodicActFreq);
		} else if(connections.depthTask.trigger == "DataTriggered") {
			parameter.getString("DepthTask", "inPortRef", connections.depthTask.inPortRef);
			parameter.getInteger("DepthTask", "prescale", connections.depthTask.prescale);
		}
		if(parameter.checkIfParameterExists("DepthTask", "scheduler")) {
			parameter.getString("DepthTask", "scheduler", connections.depthTask.scheduler);
		}
		if(parameter.checkIfParameterExists("DepthTask", "priority")) {
			parameter.getInteger("DepthTask", "priority", connections.depthTask.priority);
		}
		if(parameter.checkIfParameterExists("DepthTask", "cpuAffinity")) {
			parameter.getInteger("DepthTask", "cpuAffinity", connections.depthTask.cpuAffinity);
		}
		// load parameters for task IRTask
		parameter.getDouble("IRTask", "minActFreqHz", connections.iRTask.minActFreq);
		parameter.getDouble("IRTask", "maxActFreqHz", connections.iRTask.maxActFreq);
		parameter.getString("IRTask", "triggerType", connections.iRTask.trigger);
		if(connections.iRTask.trigger == "PeriodicTimer") {
			parameter.getDouble("IRTask", "periodicActFreqHz", connections.iRTask.periodicActFreq);
		} else if(connections.iRTask.trigger == "DataTriggered") {
			parameter.getString("IRTask", "inPortRef", connections.iRTask.inPortRef);
			parameter.getInteger("IRTask", "prescale", connections.iRTask.prescale);
		}
		if(parameter.checkIfParameterExists("IRTask", "scheduler")) {
			parameter.getString("IRTask", "scheduler", connections.iRTask.scheduler);
		}
		if(parameter.checkIfParameterExists("IRTask", "priority")) {
			parameter.getInteger("IRTask", "priority", connections.iRTask.priority);
		}
		if(parameter.checkIfParameterExists("IRTask", "cpuAffinity")) {
			parameter.getInteger("IRTask", "cpuAffinity", connections.iRTask.cpuAffinity);
		}
		// load parameters for task ImageTask
		parameter.getDouble("ImageTask", "minActFreqHz", connections.imageTask.minActFreq);
		parameter.getDouble("ImageTask", "maxActFreqHz", connections.imageTask.maxActFreq);
		parameter.getString("ImageTask", "triggerType", connections.imageTask.trigger);
		if(connections.imageTask.trigger == "PeriodicTimer") {
			parameter.getDouble("ImageTask", "periodicActFreqHz", connections.imageTask.periodicActFreq);
		} else if(connections.imageTask.trigger == "DataTriggered") {
			parameter.getString("ImageTask", "inPortRef", connections.imageTask.inPortRef);
			parameter.getInteger("ImageTask", "prescale", connections.imageTask.prescale);
		}
		if(parameter.checkIfParameterExists("ImageTask", "scheduler")) {
			parameter.getString("ImageTask", "scheduler", connections.imageTask.scheduler);
		}
		if(parameter.checkIfParameterExists("ImageTask", "priority")) {
			parameter.getInteger("ImageTask", "priority", connections.imageTask.priority);
		}
		if(parameter.checkIfParameterExists("ImageTask", "cpuAffinity")) {
			parameter.getInteger("ImageTask", "cpuAffinity", connections.imageTask.cpuAffinity);
		}
		// load parameters for task Laser1Task
		parameter.getDouble("Laser1Task", "minActFreqHz", connections.laser1Task.minActFreq);
		parameter.getDouble("Laser1Task", "maxActFreqHz", connections.laser1Task.maxActFreq);
		parameter.getString("Laser1Task", "triggerType", connections.laser1Task.trigger);
		if(connections.laser1Task.trigger == "PeriodicTimer") {
			parameter.getDouble("Laser1Task", "periodicActFreqHz", connections.laser1Task.periodicActFreq);
		} else if(connections.laser1Task.trigger == "DataTriggered") {
			parameter.getString("Laser1Task", "inPortRef", connections.laser1Task.inPortRef);
			parameter.getInteger("Laser1Task", "prescale", connections.laser1Task.prescale);
		}
		if(parameter.checkIfParameterExists("Laser1Task", "scheduler")) {
			parameter.getString("Laser1Task", "scheduler", connections.laser1Task.scheduler);
		}
		if(parameter.checkIfParameterExists("Laser1Task", "priority")) {
			parameter.getInteger("Laser1Task", "priority", connections.laser1Task.priority);
		}
		if(parameter.checkIfParameterExists("Laser1Task", "cpuAffinity")) {
			parameter.getInteger("Laser1Task", "cpuAffinity", connections.laser1Task.cpuAffinity);
		}
		// load parameters for task Laser2Task
		parameter.getDouble("Laser2Task", "minActFreqHz", connections.laser2Task.minActFreq);
		parameter.getDouble("Laser2Task", "maxActFreqHz", connections.laser2Task.maxActFreq);
		parameter.getString("Laser2Task", "triggerType", connections.laser2Task.trigger);
		if(connections.laser2Task.trigger == "PeriodicTimer") {
			parameter.getDouble("Laser2Task", "periodicActFreqHz", connections.laser2Task.periodicActFreq);
		} else if(connections.laser2Task.trigger == "DataTriggered") {
			parameter.getString("Laser2Task", "inPortRef", connections.laser2Task.inPortRef);
			parameter.getInteger("Laser2Task", "prescale", connections.laser2Task.prescale);
		}
		if(parameter.checkIfParameterExists("Laser2Task", "scheduler")) {
			parameter.getString("Laser2Task", "scheduler", connections.laser2Task.scheduler);
		}
		if(parameter.checkIfParameterExists("Laser2Task", "priority")) {
			parameter.getInteger("Laser2Task", "priority", connections.laser2Task.priority);
		}
		if(parameter.checkIfParameterExists("Laser2Task", "cpuAffinity")) {
			parameter.getInteger("Laser2Task", "cpuAffinity", connections.laser2Task.cpuAffinity);
		}
		// load parameters for task Laser3Task
		parameter.getDouble("Laser3Task", "minActFreqHz", connections.laser3Task.minActFreq);
		parameter.getDouble("Laser3Task", "maxActFreqHz", connections.laser3Task.maxActFreq);
		parameter.getString("Laser3Task", "triggerType", connections.laser3Task.trigger);
		if(connections.laser3Task.trigger == "PeriodicTimer") {
			parameter.getDouble("Laser3Task", "periodicActFreqHz", connections.laser3Task.periodicActFreq);
		} else if(connections.laser3Task.trigger == "DataTriggered") {
			parameter.getString("Laser3Task", "inPortRef", connections.laser3Task.inPortRef);
			parameter.getInteger("Laser3Task", "prescale", connections.laser3Task.prescale);
		}
		if(parameter.checkIfParameterExists("Laser3Task", "scheduler")) {
			parameter.getString("Laser3Task", "scheduler", connections.laser3Task.scheduler);
		}
		if(parameter.checkIfParameterExists("Laser3Task", "priority")) {
			parameter.getInteger("Laser3Task", "priority", connections.laser3Task.priority);
		}
		if(parameter.checkIfParameterExists("Laser3Task", "cpuAffinity")) {
			parameter.getInteger("Laser3Task", "cpuAffinity", connections.laser3Task.cpuAffinity);
		}
		// load parameters for task ManagementTask
		parameter.getDouble("ManagementTask", "minActFreqHz", connections.managementTask.minActFreq);
		parameter.getDouble("ManagementTask", "maxActFreqHz", connections.managementTask.maxActFreq);
		parameter.getString("ManagementTask", "triggerType", connections.managementTask.trigger);
		if(connections.managementTask.trigger == "PeriodicTimer") {
			parameter.getDouble("ManagementTask", "periodicActFreqHz", connections.managementTask.periodicActFreq);
		} else if(connections.managementTask.trigger == "DataTriggered") {
			parameter.getString("ManagementTask", "inPortRef", connections.managementTask.inPortRef);
			parameter.getInteger("ManagementTask", "prescale", connections.managementTask.prescale);
		}
		if(parameter.checkIfParameterExists("ManagementTask", "scheduler")) {
			parameter.getString("ManagementTask", "scheduler", connections.managementTask.scheduler);
		}
		if(parameter.checkIfParameterExists("ManagementTask", "priority")) {
			parameter.getInteger("ManagementTask", "priority", connections.managementTask.priority);
		}
		if(parameter.checkIfParameterExists("ManagementTask", "cpuAffinity")) {
			parameter.getInteger("ManagementTask", "cpuAffinity", connections.managementTask.cpuAffinity);
		}
		// load parameters for task MarkerListTask
		parameter.getDouble("MarkerListTask", "minActFreqHz", connections.markerListTask.minActFreq);
		parameter.getDouble("MarkerListTask", "maxActFreqHz", connections.markerListTask.maxActFreq);
		parameter.getString("MarkerListTask", "triggerType", connections.markerListTask.trigger);
		if(connections.markerListTask.trigger == "PeriodicTimer") {
			parameter.getDouble("MarkerListTask", "periodicActFreqHz", connections.markerListTask.periodicActFreq);
		} else if(connections.markerListTask.trigger == "DataTriggered") {
			parameter.getString("MarkerListTask", "inPortRef", connections.markerListTask.inPortRef);
			parameter.getInteger("MarkerListTask", "prescale", connections.markerListTask.prescale);
		}
		if(parameter.checkIfParameterExists("MarkerListTask", "scheduler")) {
			parameter.getString("MarkerListTask", "scheduler", connections.markerListTask.scheduler);
		}
		if(parameter.checkIfParameterExists("MarkerListTask", "priority")) {
			parameter.getInteger("MarkerListTask", "priority", connections.markerListTask.priority);
		}
		if(parameter.checkIfParameterExists("MarkerListTask", "cpuAffinity")) {
			parameter.getInteger("MarkerListTask", "cpuAffinity", connections.markerListTask.cpuAffinity);
		}
		// load parameters for task PersonDetectionTask
		parameter.getDouble("PersonDetectionTask", "minActFreqHz", connections.personDetectionTask.minActFreq);
		parameter.getDouble("PersonDetectionTask", "maxActFreqHz", connections.personDetectionTask.maxActFreq);
		parameter.getString("PersonDetectionTask", "triggerType", connections.personDetectionTask.trigger);
		if(connections.personDetectionTask.trigger == "PeriodicTimer") {
			parameter.getDouble("PersonDetectionTask", "periodicActFreqHz", connections.personDetectionTask.periodicActFreq);
		} else if(connections.personDetectionTask.trigger == "DataTriggered") {
			parameter.getString("PersonDetectionTask", "inPortRef", connections.personDetectionTask.inPortRef);
			parameter.getInteger("PersonDetectionTask", "prescale", connections.personDetectionTask.prescale);
		}
		if(parameter.checkIfParameterExists("PersonDetectionTask", "scheduler")) {
			parameter.getString("PersonDetectionTask", "scheduler", connections.personDetectionTask.scheduler);
		}
		if(parameter.checkIfParameterExists("PersonDetectionTask", "priority")) {
			parameter.getInteger("PersonDetectionTask", "priority", connections.personDetectionTask.priority);
		}
		if(parameter.checkIfParameterExists("PersonDetectionTask", "cpuAffinity")) {
			parameter.getInteger("PersonDetectionTask", "cpuAffinity", connections.personDetectionTask.cpuAffinity);
		}
		// load parameters for task RGBDTask
		parameter.getDouble("RGBDTask", "minActFreqHz", connections.rGBDTask.minActFreq);
		parameter.getDouble("RGBDTask", "maxActFreqHz", connections.rGBDTask.maxActFreq);
		parameter.getString("RGBDTask", "triggerType", connections.rGBDTask.trigger);
		if(connections.rGBDTask.trigger == "PeriodicTimer") {
			parameter.getDouble("RGBDTask", "periodicActFreqHz", connections.rGBDTask.periodicActFreq);
		} else if(connections.rGBDTask.trigger == "DataTriggered") {
			parameter.getString("RGBDTask", "inPortRef", connections.rGBDTask.inPortRef);
			parameter.getInteger("RGBDTask", "prescale", connections.rGBDTask.prescale);
		}
		if(parameter.checkIfParameterExists("RGBDTask", "scheduler")) {
			parameter.getString("RGBDTask", "scheduler", connections.rGBDTask.scheduler);
		}
		if(parameter.checkIfParameterExists("RGBDTask", "priority")) {
			parameter.getInteger("RGBDTask", "priority", connections.rGBDTask.priority);
		}
		if(parameter.checkIfParameterExists("RGBDTask", "cpuAffinity")) {
			parameter.getInteger("RGBDTask", "cpuAffinity", connections.rGBDTask.cpuAffinity);
		}
		// load parameters for task USArTask
		parameter.getDouble("USArTask", "minActFreqHz", connections.uSArTask.minActFreq);
		parameter.getDouble("USArTask", "maxActFreqHz", connections.uSArTask.maxActFreq);
		parameter.getString("USArTask", "triggerType", connections.uSArTask.trigger);
		if(connections.uSArTask.trigger == "PeriodicTimer") {
			parameter.getDouble("USArTask", "periodicActFreqHz", connections.uSArTask.periodicActFreq);
		} else if(connections.uSArTask.trigger == "DataTriggered") {
			parameter.getString("USArTask", "inPortRef", connections.uSArTask.inPortRef);
			parameter.getInteger("USArTask", "prescale", connections.uSArTask.prescale);
		}
		if(parameter.checkIfParameterExists("USArTask", "scheduler")) {
			parameter.getString("USArTask", "scheduler", connections.uSArTask.scheduler);
		}
		if(parameter.checkIfParameterExists("USArTask", "priority")) {
			parameter.getInteger("USArTask", "priority", connections.uSArTask.priority);
		}
		if(parameter.checkIfParameterExists("USArTask", "cpuAffinity")) {
			parameter.getInteger("USArTask", "cpuAffinity", connections.uSArTask.cpuAffinity);
		}
		
		// load parameters for OpcUaBackendComponentGeneratorExtension
		
		// load parameters for ComponentVisualizationROSExtension
		
		// load parameters for PlainOpcUaComponentVisualizationExtension
		
		
		// load parameters for all registered component-extensions
		for(auto extension = componentExtensionRegistry.begin(); extension != componentExtensionRegistry.end(); extension++) 
		{
			extension->second->loadParameters(parameter);
		}
		
		paramHandler.loadParameter(parameter);
	
	} catch (const SmartACE::IniParameterError & e) {
		std::cerr << e.what() << std::endl;
	} catch (const std::exception &ex) {
		std::cerr << "Uncaught std::exception: " << ex.what() << std::endl;
	} catch (...) {
		std::cerr << "Uncaught exception" << std::endl;
	}
}
