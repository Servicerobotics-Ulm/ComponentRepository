//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "ManagementTask.hh"
#include "ComponentVisualization.hh"

#include <iostream>


ManagementTask::ManagementTask(SmartACE::SmartComponent *comp) 
:	ManagementTaskCore(comp)
{
	std::cout << "constructor ManagementTask\n";
}
ManagementTask::~ManagementTask() 
{
	std::cout << "destructor ManagementTask\n";
}



int ManagementTask::on_entry()
{
	if(SmartACE::NAMING::instance()->init(0, NULL) == 0) {
		/*// get all entries
		Smart::NSKeyType searchPattern;
		ACE_Unbounded_Queue<Smart::NSKeyType> ns_entries = Smart::NAMING::instance()->getEntriesForMatchingPattern(searchPattern);


		for (ACE_Unbounded_Queue_Iterator<Smart::NSKeyType> iter (ns_entries);
			!iter.done ();
			iter.advance ())
		{
			Smart::NSKeyType *comp = 0;
			iter.next (comp);
			std::string comp_name = comp->names[Smart::NSKeyType::COMP_NAME].c_str();
			components[comp_name].push_back(*comp);
		}*/

	}else{
		std::cout << "Naming service initialization ERROR!" << std::endl;
		return 1;
	}

	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	for(int i = 0; i<sizeof(connected)/sizeof(int); i++){
		connected[i] = 0;
	}

	// show default visual objects here i.e coordinate axis, origin
	default_visualization = std::unique_ptr<DefaultVisualization>(new DefaultVisualization(COMP->getWindow3d(), "default"));

	return 0;
}
int ManagementTask::on_execute()
{
	// this method is called from an outside loop,
		// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
		// also do not use blocking calls which do not result from smartsoft kernel

		int disconnect = 0;

		//std::cout << "\n########################\n";
		printFormattedLine();
		printPorts();
		printFormattedLine();
		//std::cout << "\n########################\n";
		std::cout << "Please choose connect or disconnect" << std::endl;
		std::cout << "(0) connect \n(1) disconnect\n";
		if(!(std::cin >> disconnect) || disconnect < 0 || disconnect > 1){
			std::cin.clear();
			std::cin.ignore();
			std::cout << "invalid input!" << std::endl;
			return 0;
		}


		//SmartVisualization port
		printFormattedLine();
		//std::cout << "\n########################\n";
		if(disconnect){
			std::cout << "Please choose the service which should be disconnected or -1 to abort" << std::endl;
		}else{
			std::cout << "Please choose the service which should be connected or -1 to abort" << std::endl;
		}
		printPorts();


		int port;
		while(!(std::cin >> port) || port < -1 || port > port_max || port < 0){
			std::cin.clear();
			std::cin.ignore();
			std::cout << "invalid input!" << std::endl;
		}
		if(port == -1){ // abort
			return 0;
		}

		ACE_TString portType = "";
		ACE_TString commObject1 = "";
		ACE_TString commObject2 = "";
		switch(port){
			case port_base_push_timed:
				if(disconnect && connected[port_base_push_timed]){
					COMP->baseTask->disconnectServices();
					COMP->baseTask->stop();
					connected[port_base_push_timed] = 0;
					std::cout << display_names[port_base_push_timed]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommBasicObjects::CommBaseState";
				break;
			case port_grid_push_newest:
				if(disconnect && connected[port_grid_push_newest]){
					COMP->curMapTask->disconnectServices();
					COMP->curMapTask->stop();
					connected[port_grid_push_newest] = 0;
					std::cout << display_names[port_grid_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommNavigationObjects::CommGridMap";
				break;
			case port_laser1_push_newest:
				if(disconnect && connected[port_laser1_push_newest]){
					COMP->laser1Task->disconnectServices();
					COMP->laser1Task->stop();
					connected[port_laser1_push_newest] = 0;
					std::cout << display_names[port_laser1_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommBasicObjects::CommMobileLaserScan";

				std::cout << " laser 2 is selected" <<std::endl;
				break;
			case port_laser2_push_newest:
				if(disconnect && connected[port_laser2_push_newest]){
					COMP->laser2Task->disconnectServices();
					COMP->laser2Task->stop();
					connected[port_laser2_push_newest] = 0;
					std::cout << display_names[port_laser2_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommBasicObjects::CommMobileLaserScan";
				break;
			case port_laser3_push_newest:
				if(disconnect && connected[port_laser3_push_newest]){
					COMP->laser3Task->disconnectServices();
					COMP->laser3Task->stop();
					connected[port_laser3_push_newest] = 0;
					std::cout << display_names[port_laser3_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommBasicObjects::CommMobileLaserScan";
				break;
//			case port_person_detection_query:
//				if(disconnect && connected[port_person_detection_query]){
//					COMP->personDetectionTask->stop();
//					connected[port_person_detection_query] = 0;
//					std::cout << "personDetection disconnected." << std::endl;
//					return 0;
//				}
//				portType = "Query";
//				commObject1 = "CommPersonDetectionObjects::CommPersonId";
//				commObject2 = "CommPersonDetectionObjects::CommDetectedPerson";
//				break;
//			case port_uSAr_push_newest:
//				if(disconnect && connected[port_uSAr_push_newest]){
//					COMP->uSArTask->stop();
//					connected[port_uSAr_push_newest] = 0;
//					std::cout << "ultrasonicPushNewestClient disconnected." << std::endl;
//					return 0;
//				}
//				portType = "Push";
//				commObject1 = "CommBasicObjects::CommMobileUltrasonicScan";
//				break;
			case port_iRTask_push_newest:
				if(disconnect && connected[port_iRTask_push_newest]){
					COMP->iRTask->disconnectServices();
					COMP->iRTask->stop();
					connected[port_iRTask_push_newest] = 0;
					std::cout << display_names[port_iRTask_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommBasicObjects::CommMobileIRScan";
				break;
			case port_ltm_query:
				if(disconnect && connected[port_ltm_query]){
					COMP->ltmMapTask->disconnectServices();
					COMP->ltmMapTask->stop();
					connected[port_ltm_query] = 0;
					std::cout << "ltmQueryClient disconnected." << std::endl;
					return 0;
				}
				portType = "Query";
				commObject1 = "CommNavigationObjects::CommGridMapRequest";
				commObject2 = "CommNavigationObjects::CommGridMap";
				break;
			case port_video_image_push_newest:
				if(disconnect && connected[port_video_image_push_newest]){
					COMP->imageTask->disconnectServices();
					COMP->imageTask->stop();
					connected[port_video_image_push_newest] = 0;
					std::cout << display_names[port_video_image_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "DomainVision::CommVideoImage";
				break;
			case port_rgbd_image_push_newest:
				if(disconnect && connected[port_rgbd_image_push_newest]){
					COMP->rGBDTask->disconnectServices();
					COMP->rGBDTask->stop();
					connected[port_rgbd_image_push_newest] = 0;
					std::cout << display_names[port_rgbd_image_push_newest]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "DomainVision::CommRGBDImage";
				break;
			case port_depth_image_client:
				if(disconnect && connected[port_depth_image_client]){
					COMP->depthTask->disconnectServices();
					COMP->depthTask->stop();
					connected[port_depth_image_client] = 0;
					std::cout << display_names[port_depth_image_client]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "DomainVision::CommDepthImage";
				break;
			case port_marker_detection_list_client:
				if(disconnect && connected[port_marker_detection_list_client]){
					COMP->markerListTask->disconnectServices();
					COMP->markerListTask->stop();
					connected[port_marker_detection_list_client] = 0;
					std::cout << display_names[port_marker_detection_list_client]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommTrackingObjects::CommDetectedMarkerList";
				break;
			case port_particle_filter_info:
				if(disconnect && connected[port_particle_filter_info]){
					COMP->amclVizTask->disconnectServices();
					COMP->amclVizTask->stop();
					connected[port_particle_filter_info] = 0;
					std::cout << display_names[port_particle_filter_info]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommLocalizationObjects::CommAmclVisualizationInfo";
				break;

			case port_planner_goal_push_client:
				if(disconnect && connected[port_planner_goal_push_client]){
					COMP->plannerGoalTask->disconnectServices();
					COMP->plannerGoalTask->stop();
					connected[port_planner_goal_push_client] = 0;
					std::cout << display_names[port_planner_goal_push_client]<<" disconnected." << std::endl;
					return 0;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommNavigationObjects::CommPlannerGoal";
				break;

			case port_visual_map:
				if(disconnect && connected[port_visual_map]){
					COMP->visualMarkerMapTask->disconnectServices();
					COMP->visualMarkerMapTask->stop();
					connected[port_visual_map] = 0;
					std::cout << display_names[port_visual_map]<<" disconnected." << std::endl;
				}
				portType = port_type_name[port_types::port_query_type];
				commObject1 = "CommBasicObjects::CommVoid";
				commObject2 = "CommLocalizationObjects::CommVisualLocalizationFeatureMap";
				break;

			case port_planner_wavefront_grid_push_client:
				if(disconnect && connected[port_planner_wavefront_grid_push_client]){
					COMP->plannerGridTask->disconnectServices();
					COMP->plannerGridTask->stop();
					connected[port_planner_wavefront_grid_push_client] = 0;
					std::cout << display_names[port_planner_wavefront_grid_push_client]<<" disconnected." << std::endl;
				}
				portType = port_type_name[port_types::port_push_type];
				commObject1 = "CommNavigationObjects::CommGridMap";
				break;

			default:  //port_max
				std::cout << "invalid input!" << std::endl;
				return 0;
		}

		// get all entries
		SmartACE::NSKeyType searchPattern;

		ACE_Unbounded_Queue<SmartACE::NSKeyType> ns_entries = SmartACE::NAMING::instance()->getEntriesForMatchingPattern(searchPattern);
		components.clear();
		for (ACE_Unbounded_Queue_Iterator<SmartACE::NSKeyType> iter (ns_entries); !iter.done (); iter.advance ()){
			SmartACE::NSKeyType *comp = 0;
			iter.next (comp);
			std::string comp_name = comp->names[SmartACE::NSKeyType::COMP_NAME].c_str();
			components[comp_name].push_back(*comp);
		}

		std::cout <<" size of components" << components.size() << "\n";

		//list all appropriate components with appropriate ports
		std::map<std::string, std::list<SmartACE::NSKeyType> >::iterator it;
		if(port == port_ltm_query){
			printFormattedLine();
			std::cout << "Please choose a QueryServer or -1 to abort.\n";
		}else{
			printFormattedLine();
			std::cout << "Please choose a service to connect to or -1 to abort.\n";
		}
		int i = 0;

		std::list<SmartACE::NSKeyType>::iterator it_port;
		for (it=components.begin(); it!=components.end(); ++it){
			for(it_port = it->second.begin(); it_port != it->second.end(); it_port++){
				if(portType == it_port->names[SmartACE::NSKeyType::PATTERN_NAME]){
					if(commObject2 == "" && commObject1 == it_port->names[SmartACE::NSKeyType::COMMOBJ1_NAME]){
						printFormattedLine();
						std::cout << it->first << std::endl;
						std::cout << "(" << i << ")";
						std::cout << "\t Port-Type: " << it_port->names[SmartACE::NSKeyType::PATTERN_NAME] << std::endl;
						std::cout << "\t Port-Name: " << it_port->names[SmartACE::NSKeyType::SERVICE_NAME] << std::endl;
						con[i] = std::make_pair(it->first, it_port->names[SmartACE::NSKeyType::SERVICE_NAME].c_str());
						i++;
					}else if(commObject2 != ""){
						if((commObject1 == it_port->names[SmartACE::NSKeyType::COMMOBJ1_NAME] && commObject2 == it_port->names[SmartACE::NSKeyType::COMMOBJ2_NAME])
						 || (commObject2 == it_port->names[SmartACE::NSKeyType::COMMOBJ1_NAME] || commObject1 == it_port->names[SmartACE::NSKeyType::COMMOBJ2_NAME])){
							printFormattedLine();
							std::cout << it->first << std::endl;
							std::cout << "(" << i << ")";
							std::cout << "\t Port-Type: " << it_port->names[SmartACE::NSKeyType::PATTERN_NAME] << std::endl;
							std::cout << "\t Port-Name: " << it_port->names[SmartACE::NSKeyType::SERVICE_NAME] << std::endl;
							con[i] = std::make_pair(it->first, it_port->names[SmartACE::NSKeyType::SERVICE_NAME].c_str());
							i++;
						}
					}
				}
			}
		}
		if(i == 0){	//no appropriate ports
			std::cout << "No appropriate ports found." << std::endl;
		}else{
			int toCon;
			while(!(std::cin >> toCon) || toCon >= i || toCon < -1){
				std::cin.clear();
				std::cin.ignore();
				std::cout << "invalid input!" << std::endl;
			}
			if(toCon == -1){ // abort
				con.clear();
				return 0;
			}

			std::string con_server = con[toCon].first;
			switch(port){
				case port_base_push_timed:
					COMP->connections.baseClient.serverName = con[toCon].first;
					COMP->connections.baseClient.serviceName = con[toCon].second;
					std::cout << "starting baseTask" << std::endl;
					COMP->baseTask->connectServices();
					COMP->baseTask->start();
					connected[port_base_push_timed] = 1;
					break;
				case port_grid_push_newest:
					COMP->connections.curPushClient.serverName = con[toCon].first;
					COMP->connections.curPushClient.serviceName = con[toCon].second;
					std::cout << "starting curMapTask" << std::endl;
					COMP->curMapTask->connectServices();
					COMP->curMapTask->start();
					connected[port_grid_push_newest] = 1;
					break;
				case port_laser1_push_newest:
					COMP->connections.laserClient1.serverName = con[toCon].first;
					COMP->connections.laserClient1.serviceName = con[toCon].second;
					std::cout << "starting laser1Task" << std::endl;
					COMP->laser1Task->connectServices();
					COMP->laser1Task->start();
					connected[port_laser1_push_newest] = 1;
					break;
				case port_laser2_push_newest:
					COMP->connections.laserClient2.serverName = con[toCon].first;
					COMP->connections.laserClient2.serviceName = con[toCon].second;
					std::cout << "starting laser2Task" << std::endl;
					COMP->laser2Task->connectServices();
					COMP->laser2Task->start();
					connected[port_laser2_push_newest] = 1;
					break;
				case port_laser3_push_newest:
					COMP->connections.laserClient3.serverName = con[toCon].first;
					COMP->connections.laserClient3.serviceName = con[toCon].second;
					std::cout << "starting laser3Task" << std::endl;
					COMP->laser3Task->connectServices();
					COMP->laser3Task->start();
					connected[port_laser3_push_newest] = 1;
					break;
//				case port_person_detection_query:
//					COMP->connections.personDetectionQueryClient.serverName = con[toCon].first;
//					COMP->connections.personDetectionQueryClient.serviceName = con[toCon].second;
//
//					std::cout << "\n########################\n";
//					std::cout << "Please choose an EventServer or -1 to abort.\n";
//					//list appropriate ports
//					portType = "Event";
//					commObject1 = "CommBasicObjects::CommVoid";
//					commObject2 = "CommPersonDetectionObjects::CommPersonDetectionEventResult";
//					i = 0;
//					con.clear();
//					for(it_port= components[con_server].begin(); it_port!=components[con_server].end(); it_port++){
//						if(portType == it_port->names[Smart::NSKeyType::PATTERN_NAME]){
//							if((commObject1 == it_port->names[Smart::NSKeyType::COMMOBJ1_NAME] && commObject2 == it_port->names[Smart::NSKeyType::COMMOBJ2_NAME])
//							 || (commObject2 == it_port->names[Smart::NSKeyType::COMMOBJ1_NAME] || commObject1 == it_port->names[Smart::NSKeyType::COMMOBJ2_NAME])){
//								std::cout << "------------------------" << std::endl;
//								std::cout << "(" << i << ")";
//								std::cout << "\t Port-Type: " << it_port->names[Smart::NSKeyType::PATTERN_NAME] << std::endl;
//								std::cout << "\t Port-Name: " << it_port->names[Smart::NSKeyType::SERVICE_NAME] << std::endl;
//								con[i] = std::make_pair(con_server, it_port->names[Smart::NSKeyType::SERVICE_NAME].c_str());
//								i++;
//							}
//						}
//					}
//					if(i == 0){	//no appropriate ports
//						std::cout << "No appropriate ports found." << std::endl;
//					}else{
//						while(!(std::cin >> toCon) || toCon < -1 || toCon >= i){
//							std::cin.clear();
//							std::cin.ignore();
//							std::cout << "invalid input!" << std::endl;
//						}
//						if(toCon == -1){ // abort
//							con.clear();
//							return 0;
//						}
//
//						COMP->connections.personDetectionEventClient.serverName = con[toCon].first;
//						COMP->connections.personDetectionEventClient.serviceName = con[toCon].second;
//
//						std::cout << "starting personDetectionTask" << std::endl;
//						COMP->personDetectionTask->start();
//						connected[port_person_detection_query] = 1;
//					}
//					break;
//				case port_uSAr_push_newest:
//					COMP->connections.ultrasonicPushNewestClient.serverName = con[toCon].first;
//					COMP->connections.ultrasonicPushNewestClient.serviceName = con[toCon].second;
//					std::cout << "starting ultrasonicTask" << std::endl;
//					COMP->uSArTask->start();
//					connected[port_uSAr_push_newest] = 1;
//					break;
				case port_iRTask_push_newest:
					COMP->connections.irPushNewestClient.serverName = con[toCon].first;
					COMP->connections.irPushNewestClient.serviceName = con[toCon].second;
					std::cout << "starting irTask" << std::endl;
					COMP->iRTask->connectServices();
					COMP->iRTask->start();
					connected[port_iRTask_push_newest] = 1;
					break;
				case port_ltm_query:
					COMP->connections.ltmQueryClient.serverName = con[toCon].first;
					COMP->connections.ltmQueryClient.serviceName = con[toCon].second;
					std::cout << "starting LtmTimer" << std::endl;
					COMP->ltmMapTask->connectServices();
					COMP->ltmMapTask->start();

					connected[port_ltm_query] = 1;
					break;
				case port_video_image_push_newest:
					COMP->connections.imagePushNewestClient.serverName = con[toCon].first;
					COMP->connections.imagePushNewestClient.serviceName = con[toCon].second;
					std::cout << "starting imageTask" << std::endl;
					COMP->imageTask->connectServices();
					COMP->imageTask->start();
					connected[port_video_image_push_newest] = 1;
					break;
				case port_rgbd_image_push_newest:
					COMP->connections.rgbdPushNewestClient.serverName = con[toCon].first;
					COMP->connections.rgbdPushNewestClient.serviceName = con[toCon].second;
					std::cout << "starting RGBDTask" << std::endl;
					COMP->rGBDTask->connectServices();
					COMP->rGBDTask->start();
					connected[port_rgbd_image_push_newest] = 1;
					break;
				case port_depth_image_client:
					COMP->connections.depthPushNewestClient.serverName = con[toCon].first;
					COMP->connections.depthPushNewestClient.serviceName = con[toCon].second;
					std::cout << "starting depthTask" << std::endl;
					COMP->depthTask->connectServices();
					COMP->depthTask->start();
					connected[port_depth_image_client] = 1;
					break;
				case port_marker_detection_list_client:
					COMP->connections.markerListDetectionServiceIn.serverName = con[toCon].first;
					COMP->connections.markerListDetectionServiceIn.serviceName = con[toCon].second;
					std::cout << "starting markerListTask " << std::endl;
					COMP->markerListTask->connectServices();
					COMP->markerListTask->start();
					connected[port_marker_detection_list_client] = 1;
					break;
				case port_particle_filter_info:
					COMP->connections.amclVisualizationInfoIn.serverName = con[toCon].first;
					COMP->connections.amclVisualizationInfoIn.serviceName = con[toCon].second;
					std::cout << "starting AmclVizTask " << std::endl;
					COMP->amclVizTask->connectServices();
					COMP->amclVizTask->start();
					connected[port_particle_filter_info] = 1;
					break;
				case port_planner_goal_push_client:
					COMP->connections.plannerGoalPushClient.serverName = con[toCon].first;
					COMP->connections.plannerGoalPushClient.serviceName = con[toCon].second;
					std::cout << "starting PlannerGoalTask " << std::endl;
					COMP->plannerGoalTask->connectServices();
					COMP->plannerGoalTask->start();
					connected[port_planner_goal_push_client] = 1;
					break;
				case port_planner_wavefront_grid_push_client:
					COMP->connections.plannerWavefrontGridMap.serverName = con[toCon].first;
					COMP->connections.plannerWavefrontGridMap.serviceName = con[toCon].second;
					std::cout << "starting PlannerGridtask" << std::endl;
					COMP->plannerGridTask->connectServices();
					COMP->plannerGridTask->start();
					connected[port_planner_wavefront_grid_push_client] = 1;
					break;
			}
		}
		con.clear();
		sleep(1);
		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int ManagementTask::on_exit()
{
	SmartACE::NAMING::instance()->fini();
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
void ManagementTask::printPorts(){
	std::cout << "Available services: \n\n";

	for(int i = service_ports::port_base_push_timed; i < service_ports::port_max; ++i)
	{
		std::cout <<"("<<std::setw(2)<< i<<") "<<display_names[i];
		if(connected[i]) std::cout << " (connected)";
		std::cout << std::endl;
	}
}

void ManagementTask::printFormattedLine()
{
	std::cout.width(40);
	std::cout.fill('-');
	std::cout << "\n";
	std::cout.fill(' ');
}
