// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "openRaveObjectsDB.hh"

// object_t
// 

const object_t::type_type& object_t::
type () const
{
  return this->type_.get ();
}

object_t::type_type& object_t::
type ()
{
  return this->type_.get ();
}

void object_t::
type (const type_type& x)
{
  this->type_.set (x);
}

void object_t::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

::std::auto_ptr< object_t::type_type > object_t::
detach_type ()
{
  return this->type_.detach ();
}

const object_t::shape_type& object_t::
shape () const
{
  return this->shape_.get ();
}

object_t::shape_type& object_t::
shape ()
{
  return this->shape_.get ();
}

void object_t::
shape (const shape_type& x)
{
  this->shape_.set (x);
}

void object_t::
shape (::std::auto_ptr< shape_type > x)
{
  this->shape_.set (x);
}

::std::auto_ptr< object_t::shape_type > object_t::
detach_shape ()
{
  return this->shape_.detach ();
}


// objectRecDb_t
// 

const objectRecDb_t::object_sequence& objectRecDb_t::
object () const
{
  return this->object_;
}

objectRecDb_t::object_sequence& objectRecDb_t::
object ()
{
  return this->object_;
}

void objectRecDb_t::
object (const object_sequence& s)
{
  this->object_ = s;
}


// shape_t
// 

const shape_t::mesh_optional& shape_t::
mesh () const
{
  return this->mesh_;
}

shape_t::mesh_optional& shape_t::
mesh ()
{
  return this->mesh_;
}

void shape_t::
mesh (const mesh_type& x)
{
  this->mesh_.set (x);
}

void shape_t::
mesh (const mesh_optional& x)
{
  this->mesh_ = x;
}

void shape_t::
mesh (::std::auto_ptr< mesh_type > x)
{
  this->mesh_.set (x);
}

const shape_t::cylinder_optional& shape_t::
cylinder () const
{
  return this->cylinder_;
}

shape_t::cylinder_optional& shape_t::
cylinder ()
{
  return this->cylinder_;
}

void shape_t::
cylinder (const cylinder_type& x)
{
  this->cylinder_.set (x);
}

void shape_t::
cylinder (const cylinder_optional& x)
{
  this->cylinder_ = x;
}

void shape_t::
cylinder (::std::auto_ptr< cylinder_type > x)
{
  this->cylinder_.set (x);
}

const shape_t::box_optional& shape_t::
box () const
{
  return this->box_;
}

shape_t::box_optional& shape_t::
box ()
{
  return this->box_;
}

void shape_t::
box (const box_type& x)
{
  this->box_.set (x);
}

void shape_t::
box (const box_optional& x)
{
  this->box_ = x;
}

void shape_t::
box (::std::auto_ptr< box_type > x)
{
  this->box_.set (x);
}

const shape_t::sphere_optional& shape_t::
sphere () const
{
  return this->sphere_;
}

shape_t::sphere_optional& shape_t::
sphere ()
{
  return this->sphere_;
}

void shape_t::
sphere (const sphere_type& x)
{
  this->sphere_.set (x);
}

void shape_t::
sphere (const sphere_optional& x)
{
  this->sphere_ = x;
}

void shape_t::
sphere (::std::auto_ptr< sphere_type > x)
{
  this->sphere_.set (x);
}


// mesh_t
// 

const mesh_t::filename_type& mesh_t::
filename () const
{
  return this->filename_.get ();
}

mesh_t::filename_type& mesh_t::
filename ()
{
  return this->filename_.get ();
}

void mesh_t::
filename (const filename_type& x)
{
  this->filename_.set (x);
}

void mesh_t::
filename (::std::auto_ptr< filename_type > x)
{
  this->filename_.set (x);
}

::std::auto_ptr< mesh_t::filename_type > mesh_t::
detach_filename ()
{
  return this->filename_.detach ();
}


// cylinder_t
// 

const cylinder_t::radius_type& cylinder_t::
radius () const
{
  return this->radius_.get ();
}

cylinder_t::radius_type& cylinder_t::
radius ()
{
  return this->radius_.get ();
}

void cylinder_t::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

const cylinder_t::height_type& cylinder_t::
height () const
{
  return this->height_.get ();
}

cylinder_t::height_type& cylinder_t::
height ()
{
  return this->height_.get ();
}

void cylinder_t::
height (const height_type& x)
{
  this->height_.set (x);
}


// box_t
// 

const box_t::sizeX_type& box_t::
sizeX () const
{
  return this->sizeX_.get ();
}

box_t::sizeX_type& box_t::
sizeX ()
{
  return this->sizeX_.get ();
}

void box_t::
sizeX (const sizeX_type& x)
{
  this->sizeX_.set (x);
}

const box_t::sizeY_type& box_t::
sizeY () const
{
  return this->sizeY_.get ();
}

box_t::sizeY_type& box_t::
sizeY ()
{
  return this->sizeY_.get ();
}

void box_t::
sizeY (const sizeY_type& x)
{
  this->sizeY_.set (x);
}

const box_t::sizeZ_type& box_t::
sizeZ () const
{
  return this->sizeZ_.get ();
}

box_t::sizeZ_type& box_t::
sizeZ ()
{
  return this->sizeZ_.get ();
}

void box_t::
sizeZ (const sizeZ_type& x)
{
  this->sizeZ_.set (x);
}


// sphere_t
// 

const sphere_t::radius_type& sphere_t::
radius () const
{
  return this->radius_.get ();
}

sphere_t::radius_type& sphere_t::
radius ()
{
  return this->radius_.get ();
}

void sphere_t::
radius (const radius_type& x)
{
  this->radius_.set (x);
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// object_t
//

object_t::
object_t (const type_type& type,
          const shape_type& shape)
: ::xml_schema::type (),
  type_ (type, this),
  shape_ (shape, this)
{
}

object_t::
object_t (const type_type& type,
          ::std::auto_ptr< shape_type > shape)
: ::xml_schema::type (),
  type_ (type, this),
  shape_ (shape, this)
{
}

object_t::
object_t (const object_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  type_ (x.type_, f, this),
  shape_ (x.shape_, f, this)
{
}

object_t::
object_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  type_ (this),
  shape_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void object_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // type
    //
    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      if (!type_.present ())
      {
        this->type_.set (r);
        continue;
      }
    }

    // shape
    //
    if (n.name () == "shape" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shape_type > r (
        shape_traits::create (i, f, this));

      if (!shape_.present ())
      {
        this->shape_.set (r);
        continue;
      }
    }

    break;
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "type",
      "");
  }

  if (!shape_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "shape",
      "");
  }
}

object_t* object_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class object_t (*this, f, c);
}

object_t& object_t::
operator= (const object_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->type_ = x.type_;
    this->shape_ = x.shape_;
  }

  return *this;
}

object_t::
~object_t ()
{
}

// objectRecDb_t
//

objectRecDb_t::
objectRecDb_t ()
: ::xml_schema::type (),
  object_ (this)
{
}

objectRecDb_t::
objectRecDb_t (const objectRecDb_t& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  object_ (x.object_, f, this)
{
}

objectRecDb_t::
objectRecDb_t (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  object_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void objectRecDb_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // object
    //
    if (n.name () == "object" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< object_type > r (
        object_traits::create (i, f, this));

      this->object_.push_back (r);
      continue;
    }

    break;
  }
}

objectRecDb_t* objectRecDb_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class objectRecDb_t (*this, f, c);
}

objectRecDb_t& objectRecDb_t::
operator= (const objectRecDb_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->object_ = x.object_;
  }

  return *this;
}

objectRecDb_t::
~objectRecDb_t ()
{
}

// shape_t
//

shape_t::
shape_t ()
: ::xml_schema::type (),
  mesh_ (this),
  cylinder_ (this),
  box_ (this),
  sphere_ (this)
{
}

shape_t::
shape_t (const shape_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  mesh_ (x.mesh_, f, this),
  cylinder_ (x.cylinder_, f, this),
  box_ (x.box_, f, this),
  sphere_ (x.sphere_, f, this)
{
}

shape_t::
shape_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  mesh_ (this),
  cylinder_ (this),
  box_ (this),
  sphere_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void shape_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // mesh
    //
    if (n.name () == "mesh" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mesh_type > r (
        mesh_traits::create (i, f, this));

      if (!this->mesh_)
      {
        this->mesh_.set (r);
        continue;
      }
    }

    // cylinder
    //
    if (n.name () == "cylinder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cylinder_type > r (
        cylinder_traits::create (i, f, this));

      if (!this->cylinder_)
      {
        this->cylinder_.set (r);
        continue;
      }
    }

    // box
    //
    if (n.name () == "box" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< box_type > r (
        box_traits::create (i, f, this));

      if (!this->box_)
      {
        this->box_.set (r);
        continue;
      }
    }

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      if (!this->sphere_)
      {
        this->sphere_.set (r);
        continue;
      }
    }

    break;
  }
}

shape_t* shape_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class shape_t (*this, f, c);
}

shape_t& shape_t::
operator= (const shape_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->mesh_ = x.mesh_;
    this->cylinder_ = x.cylinder_;
    this->box_ = x.box_;
    this->sphere_ = x.sphere_;
  }

  return *this;
}

shape_t::
~shape_t ()
{
}

// mesh_t
//

mesh_t::
mesh_t (const filename_type& filename)
: ::xml_schema::type (),
  filename_ (filename, this)
{
}

mesh_t::
mesh_t (const mesh_t& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  filename_ (x.filename_, f, this)
{
}

mesh_t::
mesh_t (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  filename_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void mesh_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // filename
    //
    if (n.name () == "filename" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< filename_type > r (
        filename_traits::create (i, f, this));

      if (!filename_.present ())
      {
        this->filename_.set (r);
        continue;
      }
    }

    break;
  }

  if (!filename_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "filename",
      "");
  }
}

mesh_t* mesh_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class mesh_t (*this, f, c);
}

mesh_t& mesh_t::
operator= (const mesh_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->filename_ = x.filename_;
  }

  return *this;
}

mesh_t::
~mesh_t ()
{
}

// cylinder_t
//

cylinder_t::
cylinder_t (const radius_type& radius,
            const height_type& height)
: ::xml_schema::type (),
  radius_ (radius, this),
  height_ (height, this)
{
}

cylinder_t::
cylinder_t (const cylinder_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this),
  height_ (x.height_, f, this)
{
}

cylinder_t::
cylinder_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this),
  height_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cylinder_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      if (!height_.present ())
      {
        this->height_.set (height_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }

  if (!height_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "height",
      "");
  }
}

cylinder_t* cylinder_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cylinder_t (*this, f, c);
}

cylinder_t& cylinder_t::
operator= (const cylinder_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
    this->height_ = x.height_;
  }

  return *this;
}

cylinder_t::
~cylinder_t ()
{
}

// box_t
//

box_t::
box_t (const sizeX_type& sizeX,
       const sizeY_type& sizeY,
       const sizeZ_type& sizeZ)
: ::xml_schema::type (),
  sizeX_ (sizeX, this),
  sizeY_ (sizeY, this),
  sizeZ_ (sizeZ, this)
{
}

box_t::
box_t (const box_t& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  sizeX_ (x.sizeX_, f, this),
  sizeY_ (x.sizeY_, f, this),
  sizeZ_ (x.sizeZ_, f, this)
{
}

box_t::
box_t (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  sizeX_ (this),
  sizeY_ (this),
  sizeZ_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void box_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // sizeX
    //
    if (n.name () == "sizeX" && n.namespace_ ().empty ())
    {
      if (!sizeX_.present ())
      {
        this->sizeX_.set (sizeX_traits::create (i, f, this));
        continue;
      }
    }

    // sizeY
    //
    if (n.name () == "sizeY" && n.namespace_ ().empty ())
    {
      if (!sizeY_.present ())
      {
        this->sizeY_.set (sizeY_traits::create (i, f, this));
        continue;
      }
    }

    // sizeZ
    //
    if (n.name () == "sizeZ" && n.namespace_ ().empty ())
    {
      if (!sizeZ_.present ())
      {
        this->sizeZ_.set (sizeZ_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!sizeX_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sizeX",
      "");
  }

  if (!sizeY_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sizeY",
      "");
  }

  if (!sizeZ_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "sizeZ",
      "");
  }
}

box_t* box_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class box_t (*this, f, c);
}

box_t& box_t::
operator= (const box_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->sizeX_ = x.sizeX_;
    this->sizeY_ = x.sizeY_;
    this->sizeZ_ = x.sizeZ_;
  }

  return *this;
}

box_t::
~box_t ()
{
}

// sphere_t
//

sphere_t::
sphere_t (const radius_type& radius)
: ::xml_schema::type (),
  radius_ (radius, this)
{
}

sphere_t::
sphere_t (const sphere_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  radius_ (x.radius_, f, this)
{
}

sphere_t::
sphere_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  radius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sphere_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // radius
    //
    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      if (!radius_.present ())
      {
        this->radius_.set (radius_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "radius",
      "");
  }
}

sphere_t* sphere_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere_t (*this, f, c);
}

sphere_t& sphere_t::
operator= (const sphere_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->radius_ = x.radius_;
  }

  return *this;
}

sphere_t::
~sphere_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (const ::std::string& u,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::objectRecDb_t > (
    ::objectRecDb (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (const ::std::string& u,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::objectRecDb_t > (
    ::objectRecDb (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (const ::std::string& u,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::objectRecDb_t > (
    ::objectRecDb (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::std::istream& is,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::objectRecDb (isrc, f, p);
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::std::istream& is,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::objectRecDb (isrc, h, f, p);
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::std::istream& is,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::objectRecDb (isrc, h, f, p);
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::objectRecDb (isrc, f, p);
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::std::istream& is,
             const ::std::string& sid,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::objectRecDb (isrc, h, f, p);
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::std::istream& is,
             const ::std::string& sid,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::objectRecDb (isrc, h, f, p);
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::xercesc::InputSource& i,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::objectRecDb_t > (
    ::objectRecDb (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::xercesc::InputSource& i,
             ::xml_schema::error_handler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::objectRecDb_t > (
    ::objectRecDb (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::xercesc::InputSource& i,
             ::xercesc::DOMErrorHandler& h,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::objectRecDb_t > (
    ::objectRecDb (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (const ::xercesc::DOMDocument& doc,
             ::xml_schema::flags f,
             const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::objectRecDb_t > (
      ::objectRecDb (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "objectRecDb" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::objectRecDb_t > r (
      ::xsd::cxx::tree::traits< ::objectRecDb_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "objectRecDb",
    "");
}

::std::auto_ptr< ::objectRecDb_t >
objectRecDb (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
             ::xml_schema::flags f,
             const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "objectRecDb" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::objectRecDb_t > r (
      ::xsd::cxx::tree::traits< ::objectRecDb_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "objectRecDb",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const object_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // type
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "type",
        e));

    s << i.type ();
  }

  // shape
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "shape",
        e));

    s << i.shape ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const objectRecDb_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // object
  //
  for (objectRecDb_t::object_const_iterator
       b (i.object ().begin ()), n (i.object ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "object",
        e));

    s << *b;
  }
}

void
objectRecDb (::std::ostream& o,
             const ::objectRecDb_t& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::objectRecDb (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
objectRecDb (::std::ostream& o,
             const ::objectRecDb_t& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::objectRecDb (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
objectRecDb (::std::ostream& o,
             const ::objectRecDb_t& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::objectRecDb (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
objectRecDb (::xercesc::XMLFormatTarget& t,
             const ::objectRecDb_t& s,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::objectRecDb (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
objectRecDb (::xercesc::XMLFormatTarget& t,
             const ::objectRecDb_t& s,
             ::xml_schema::error_handler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::objectRecDb (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
objectRecDb (::xercesc::XMLFormatTarget& t,
             const ::objectRecDb_t& s,
             ::xercesc::DOMErrorHandler& h,
             const ::xml_schema::namespace_infomap& m,
             const ::std::string& e,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::objectRecDb (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
objectRecDb (::xercesc::DOMDocument& d,
             const ::objectRecDb_t& s,
             ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "objectRecDb" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "objectRecDb",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
objectRecDb (const ::objectRecDb_t& s,
             const ::xml_schema::namespace_infomap& m,
             ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "objectRecDb",
      "",
      m, f));

  ::objectRecDb (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const shape_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // mesh
  //
  if (i.mesh ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "mesh",
        e));

    s << *i.mesh ();
  }

  // cylinder
  //
  if (i.cylinder ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "cylinder",
        e));

    s << *i.cylinder ();
  }

  // box
  //
  if (i.box ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "box",
        e));

    s << *i.box ();
  }

  // sphere
  //
  if (i.sphere ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sphere",
        e));

    s << *i.sphere ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const mesh_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // filename
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "filename",
        e));

    s << i.filename ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const cylinder_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << ::xml_schema::as_double(i.radius ());
  }

  // height
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "height",
        e));

    s << ::xml_schema::as_double(i.height ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const box_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // sizeX
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sizeX",
        e));

    s << ::xml_schema::as_double(i.sizeX ());
  }

  // sizeY
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sizeY",
        e));

    s << ::xml_schema::as_double(i.sizeY ());
  }

  // sizeZ
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "sizeZ",
        e));

    s << ::xml_schema::as_double(i.sizeZ ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const sphere_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // radius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "radius",
        e));

    s << ::xml_schema::as_double(i.radius ());
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

