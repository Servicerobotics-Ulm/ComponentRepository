//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//  Copyright (C) 2019 Timo Blender
//
//        blender@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartOpenRave component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "TriggerHandler.hh"

#include "ComponentOpenRave.hh"

#include "OpenRave.hh"

#define STOP while (std::cin.get() != '\n');

// trigger user methods
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_CONSTRAINED_PATH(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_CLEAR()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::stringstream ss;
	ss << "PARAMETER apply: ENV_CLEAR";
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
	OPENRAVE->resetAll();
	ss << " --> DONE";
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_LOAD_FILE(const int &fileID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_LOAD_OBJECTRECOGNITION(const int &envID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	std::stringstream ss;
	ss << "PARAMETER apply: ENV_LOAD_OBJECTRECOGNITION " << envID;
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
	OPENRAVE->loadEnvironment(envID);
	ss << " --> DONE";

	//TODO ADD TO TCL BLOCK!
	/*CommManipulationPlannerObjects::CommManipulationPlannerEventState s;
	s.set_event(CommManipulationPlannerObjects::ManipulationPlannerEvent::LOAD_OBJREC_DATA_DONE);
	COMP->eventServer->put(s);
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());*/
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_SAVE_FILE()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_CENTERED(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_NONE()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_SIMPLE(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	std::stringstream ss;
	OPENRAVE->globalParameters.iterationMode = OpenRave::OpenRaveParameter::IterationMode::SIMPLE_COMPS;

	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.fromHeight 		= fromHeight;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.toHeight 		= toHeight;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.fromDepth 		= fromDepth;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.toDepth 		= toDepth;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.fromSide 		= fromSide;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.toSide 			= toSide;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.fromAzimuth 	= fromAzimuth;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.toAzimuth 		= toAzimuth;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.fromElevation 	= fromElevation;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.toElevation 	= toElevation;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.fromRoll 		= fromRoll;
	OPENRAVE->globalParameters.ikSolutionPoseBoundaries.toRoll 			= toRoll;


	OPENRAVE->globalParameters.modified = true;
	ss << "PARAMETER applied: GRASPING_SIMPLE: ";
	ss << "height (" << fromHeight << " " << toHeight << ")" << " depth (" << fromDepth << " " << toDepth << ")" << " side (" << fromSide << " " << toSide << ")" << " azimuth (" << fromAzimuth << " " << toAzimuth
			<< ")" << " elevation (" << fromElevation << " " << toElevation << ")" << " roll (" << fromRoll << " " << toRoll << ")\n";
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
std::cout<<"MATTHIAS Grasping simple done!"<<std::endl;
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_NORMAL_PATH()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_ADD(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_COMPUTEGRASPTABLE(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_DELETE(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::stringstream ss;
	ss << "PARAMETER apply: OBJ_DELETE " << objectID;
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
	OPENRAVE->deleteKinBody(objectID);
	ss << " --> DONE";
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());

}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_MOVE(const int &objectID, const double &x, const double &y, const double &z, const double &yaw, const double &pitch, const double &roll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLANNING_GRASPOBJ(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::stringstream ss;
	ss << "PARAMETER apply: OPENRAVE_GRASPOBJ " << objectID;
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
	OPENRAVE->graspKinBody(objectID);
	ss << " --> DONE";
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLANNING_RELEASEOBJ(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::stringstream ss;
	ss << "PARAMETER apply: OPENRAVE_RELEASEOBJ " << objectID;
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
	OPENRAVE->releaseKinBody();
	ss << " --> DONE";
	MessageHandler::handleMessage(ss.str(), MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugOpenRave());
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLAN_FURNITURE_MANIPUATION_TASK(const PLAN_FURNITURE_MANIPUATION_TASKType::modeType &mode, const unsigned int &furnitureIdentifier, const unsigned int &doorIdentifier, const double &openAmount)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLAN_PATH_TARGET_JOINT_ANGLES(const std::list<double> &angles)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	try {
		// ------------------------------------------------
		// check if activated. If not, do nothing with the
		// trajectory otherwise perform it.
		// ------------------------------------------------
	//	if (COMP->stateSlave->tryAcquire("nonneutral") == Smart::SMART_OK) {
			// release trajectory state so a state change can happen
	//		COMP->stateSlave->release("nonneutral");

			COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			//TODO: parameterTask
			//COMP->parameterTask.waitQueueEmpty(); // wait until all parameters are applied

			/*MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Called and state NONNEUTRAL", MessageHandler::INFO,
					COMP->getGlobalState().getOpenRave().getDebugSend());

			SmartACE::EventId eventId;
			CommManipulatorObjects::CommManipulatorEventParameter katanaEventParameter;

			if (COMP->getGlobalState().getPortParameter().getWithManipulator()) {
				// Set event to "Goal_not_reached" of the Manipulator so that every other event is recognized
				katanaEventParameter.setEvent(CommManipulatorObjects::ManipulatorEvent::GOAL_NOT_REACHED);

				Smart::StatusCode status = COMP->manipulatorEventServiceIn->activate(Smart::continuous, katanaEventParameter, eventId);
				if (status != Smart::SMART_OK) {
					throw MessageHandler::ErrorException(
						"[PathPlanningSendHandler::handleSend] Could not activate EventClient of Manipulator.",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
				}
			}
			else {
				COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			}*/

			//STOP;
			std::cout << "Before sync" << std::endl;
			OPENRAVE->syncManipulator();
			std::cout << "After sync" << std::endl;
			//STOP;

			std::cout << "[TIMO]:AFTER SYNC MANIP" << std::endl;

			std::cout << "!!!LIST SIZE!!!: " << angles.size() << std::endl;

			for (double const &d: angles) {
				std::cout << "angle: " << d << std::endl;
			}

			std::vector<ORUtil::TrajectoryPoint> openraveTrajectory;

			std::vector<double> ang(angles.size());
			std::copy(angles.begin(), angles.end(), ang.begin());

//			if (OPENRAVE->getParameter().simulation_test_ik_only && (COMP->stateSlave->tryAcquire("simulation") == Smart::SMART_OK))
//			{
//				COMP->stateSlave->release("simulation");
//				MessageHandler::handleMessage(
//						"[PathPlanningSendHandler::handleJointAngles] IK Solution Found with SIMULATION_TEST_IK_ONLY parameter.",
//						CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugSend());
//			}

			// For UR5 we plan a trajectory using OpenRave planner
			// For Tiago we plan a trajectory using COMPS planner
//			else if (!OPENRAVE->planPath(ang, openraveTrajectory))
//			{
//				throw MessageHandler::ErrorException("[PathPlanningSendHandler::handleJointAngles] Path planning failed.",
//						CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);
//			}

			if (!OPENRAVE->planPath(ang, openraveTrajectory))
			{
				throw MessageHandler::ErrorException("[PathPlanningSendHandler::handleJointAngles] Path planning failed.",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);
			}

			// Set default parameters into the trajectory which will be sent to the Manipulator
			CommManipulatorObjects::CommManipulatorTrajectory manipulatorTrajectory;
			manipulatorTrajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
			manipulatorTrajectory.set_trajectory_size(openraveTrajectory.size());

			if (openraveTrajectory.size() == 0) {
				manipulatorTrajectory.set_joint_count(0);
			} else {
				manipulatorTrajectory.set_joint_count(openraveTrajectory[0].jointValues.size());
			}

			/*
			 * Iterate over the trajectory calculated by OpenRave and
			 * convert the angles into the real manipulator angles and
			 * set the converted angles into the trajectory sent to the manipulator
			 */
			for (size_t j = 0; j < openraveTrajectory.size(); ++j) {
				manipulatorTrajectory.set_joint_time(j, openraveTrajectory[j].time);
				for (size_t k = 0; k < manipulatorTrajectory.get_joint_count(); ++k) {
					manipulatorTrajectory.set_joint_angle(j, k, openraveTrajectory[j].jointValues[k]);
				}
			}

			// If i == 0 the while-loop will not work this is because the first trajectory is sent
			// because we assume the arm is stationary at that point.
			/*
			 * At this point the component waits till the manipulator has finished its trajectory
			 * which has been sent before.
			 *
			 * If i == 0 the trajectory is sent directly because we assume the arm is stationary.
			 *
			 * Otherwise it tries to look what the  Manipulator Mode is set to.
			 * If it is set to SEND_TRAJECTORY the trajectory will be sent.
			 * Otherwise it tests if a FAILURE has occurred within the manipulator and
			 * exits properly.
			 */
			//CHS::SmartGuard guard(COMP->ManipulatorModeMutex);
			while (COMP->manipulatorMode != COMP->SEND_TRAJECTORY) {
				if (COMP->manipulatorMode == COMP->FAILURE) {
					throw MessageHandler::ErrorException("[PathPlanningSendHandler::handleSend] Something wrong with the Manipulator.",
							CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);

				}
				//guard.release();
				COMP->ManipulatorWaitSem.acquire();
				//guard.acquire();
			}
			//guard.release();

			// Send calculated Trajectory to the Manipulator
			Smart::StatusCode status = COMP->stateSlave->tryAcquire("trajectory");
			if (status == Smart::SMART_OK) {
				COMP->stateSlave->release("trajectory");

				if (COMP->getGlobalState().getPortParameter().getWithManipulator()) {
					std::cout << "[PathPlanningSendHandler] Send trajectory to manipulator ...\n";
					status = COMP->sendTrajectoryOut->send(manipulatorTrajectory);

					if (status != Smart::SMART_OK) {
						throw MessageHandler::ErrorException(
								"[PathPlanningSendHandler] Send of trajectory to manipulator component failed. [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
					}
				}
				else {
					std::cout << "[PathPlanningSendHandler] Component is in state TRAJECTORY, but withManipulator is false \n";
				}
			}
			else {
				std::cout << "[PathPlanningSendHandler] " << Smart::StatusCodeConversion(status) << "\n";
			}

			// If all points or joint angles in the incoming trajectory has been processed we send the event PATH_FOUND.
			MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Path Planning successful.",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, MessageHandler::INFO,
					COMP->getGlobalState().getOpenRave().getDebugSend());

		//} // end stateSlave

		/*else {
			MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Component in \"neutral\" state.\n",
					MessageHandler::WARNING);
		}*/

		std::cout << "[PathPlanningSendHandler] FINISHED \n\n";

	} // end try

	catch (MessageHandler::ErrorException& e) {
		MessageHandler::handleMessage(e.getMessage(), e.getEvent(), MessageHandler::ERROR);
	}
	catch (...) {
		MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Unknown Error",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, MessageHandler::ERROR);
	}
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_PLAN_PATH_TARGET_TCP_POSE(const double &x, const double &y, const double &z, const double &azimuth, const double &elevation, const double &roll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	std::cout <<"[TIMO]: pose x: " << x << std::endl;
	std::cout <<"[TIMO]: pose y: " << y << std::endl;
	std::cout <<"[TIMO]: pose z: " << z << std::endl;
	std::cout <<"[TIMO]: pose azimuth: " << azimuth << std::endl;
	std::cout <<"[TIMO]: pose elevation: " << elevation << std::endl;
	std::cout <<"[TIMO]: pose roll: " << roll << std::endl;

	try {
		// ------------------------------------------------
		// check if activated. If not, do nothing with the
		// trajectory otherwise perform it.
		// ------------------------------------------------
		//if (COMP->stateSlave->tryAcquire("nonneutral") == Smart::SMART_OK) {
			// release trajectory state so a state change can happen
			//COMP->stateSlave->release("nonneutral");

			COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			//TODO: parameterTask
			//COMP->parameterTask.waitQueueEmpty(); // wait until all parameters are applied

			/*MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Called and state NONNEUTRAL", MessageHandler::INFO,
					COMP->getGlobalState().getOpenRave().getDebugSend());

			SmartACE::EventId eventId;
			CommManipulatorObjects::CommManipulatorEventParameter katanaEventParameter;

			if (COMP->getGlobalState().getPortParameter().getWithManipulator()) {
				// Set event to "Goal_not_reached" of the Manipulator so that every other event is recognized
				katanaEventParameter.setEvent(CommManipulatorObjects::ManipulatorEvent::GOAL_NOT_REACHED);

				Smart::StatusCode status = COMP->manipulatorEventServiceIn->activate(Smart::continuous, katanaEventParameter, eventId);
				if (status != Smart::SMART_OK) {
					throw MessageHandler::ErrorException(
						"[PathPlanningSendHandler::handleSend] Could not activate EventClient of Manipulator.",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
				}
			}
			else {
				COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			}*/

			OPENRAVE->syncManipulator();

			std::cout << "[TIMO]:AFTER SYNC MANIP" << std::endl;

			std::vector<ORUtil::TrajectoryPoint> openraveTrajectory;
			double aPose[6];
			std::vector<double> angles;
			CommBasicObjects::CommPose3d resultPoseAfterIteration;

			aPose[0] = x;
			aPose[1] = y;
			aPose[2] = z;
			aPose[3] = azimuth;
			aPose[4] = elevation;
			aPose[5] = roll;

			/*int i = 0;
			for (std::list<double>::const_iterator it = pose.begin(); it != pose.end(); it++) {
				aPose[i] = *it;
				i++;
			}*/

			// Blender: Uses COMPS to solve IK problem
			// COMPS internally also plans the trajectory here
			if (!OPENRAVE->iterateToGetGraspingIKSolution(aPose[0], aPose[1], aPose[2], aPose[3], aPose[4], aPose[5], angles, resultPoseAfterIteration)) {

				throw MessageHandler::ErrorException(
						"[PathPlanningSendHandler::handlePoses] Iteration exceeded to find grasping IK solution using.",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_IK_SOLUTION_FOUND);
			}

			std::cout << "Timo: iterate finished" << std::endl;

			// found IK solution for simple grasping
			// Send PLANNING_PATH event with final TCP pose where the path is planned to
			MessageHandler::handleMessage("[PathPlanningSendHandler::handlePoses] Planning Path.",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::PLANNING_PATH, resultPoseAfterIteration, MessageHandler::INFO,
					COMP->getGlobalState().getOpenRave().getDebugSend());

			// Blender: Trajectory was already planned in the previous call to the COMPS library
			// But for UR5 we plan a new trajectory using OpenRave planner using the resulting angles from the solved IK problem of the COMPS library
			// For Tiago we just read the previously planned trajectory


			if (!OPENRAVE->planPath(angles, openraveTrajectory)) {
				throw MessageHandler::ErrorException("[PathPlanningSendHandler::handlePoses] Path planning failed.",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);
			}

			std::cout << "Timo: plan finished" << std::endl;

			// Set default parameters into the trajectory which will be sent to the Manipulator
			CommManipulatorObjects::CommManipulatorTrajectory manipulatorTrajectory;
			manipulatorTrajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
			manipulatorTrajectory.set_trajectory_size(openraveTrajectory.size());

			if (openraveTrajectory.size() == 0) {
				manipulatorTrajectory.set_joint_count(0);
			} else {
				manipulatorTrajectory.set_joint_count(openraveTrajectory[0].jointValues.size());
			}

			/*
			 * Iterate over the trajectory calculated by OpenRave and
			 * convert the angles into the real manipulator angles and
			 * set the converted angles into the trajectory sent to the manipulator
			 */
			for (size_t j = 0; j < openraveTrajectory.size(); ++j) {
				manipulatorTrajectory.set_joint_time(j, openraveTrajectory[j].time);
				for (size_t k = 0; k < manipulatorTrajectory.get_joint_count(); ++k) {
					manipulatorTrajectory.set_joint_angle(j, k, openraveTrajectory[j].jointValues[k]);
				}
			}

			// If i == 0 the while-loop will not work this is because the first trajectory is sent
			// because we assume the arm is stationary at that point.
			/*
			 * At this point the component waits till the manipulator has finished its trajectory
			 * which has been sent before.
			 *
			 * If i == 0 the trajectory is sent directly because we assume the arm is stationary.
			 *
			 * Otherwise it tries to look what the  Manipulator Mode is set to.
			 * If it is set to SEND_TRAJECTORY the trajectory will be sent.
			 * Otherwise it tests if a FAILURE has occurred within the manipulator and
			 * exits properly.
			 */
			//CHS::SmartGuard guard(COMP->ManipulatorModeMutex);
			while (COMP->manipulatorMode != COMP->SEND_TRAJECTORY) {
				if (COMP->manipulatorMode == COMP->FAILURE) {
					throw MessageHandler::ErrorException("[PathPlanningSendHandler::handleSend] Something wrong with the Manipulator.",
							CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);

				}
				//guard.release();
				COMP->ManipulatorWaitSem.acquire();
				//guard.acquire();
			}
			//guard.release();

			// Send calculated Trajectory to the Manipulator
			Smart::StatusCode status = COMP->stateSlave->tryAcquire("trajectory");
			if (status == Smart::SMART_OK) {
				COMP->stateSlave->release("trajectory");

				if (COMP->getGlobalState().getPortParameter().getWithManipulator()) {
					std::cout << "[PathPlanningSendHandler] Send trajectory to manipulator ...\n";
					status = COMP->sendTrajectoryOut->send(manipulatorTrajectory);

					if (status != Smart::SMART_OK) {
						throw MessageHandler::ErrorException(
								"[PathPlanningSendHandler] Send of trajectory to manipulator component failed. [handleSend in PathPlanningSendHandler]",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
					}
				}
				else {
					std::cout << "[PathPlanningSendHandler] Component is in state TRAJECTORY, but withManipulator is false \n";
				}
			}
			else {
				std::cout << "[PathPlanningSendHandler] " << Smart::StatusCodeConversion(status) << "\n";
			}

			// If all points or joint angles in the incoming trajectory has been processed we send the event PATH_FOUND.
			MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Path Planning successful.",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, MessageHandler::INFO,
					COMP->getGlobalState().getOpenRave().getDebugSend());

		//} // end stateSlave

//		else {
//			MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Component in \"neutral\" state.\n",
//					MessageHandler::WARNING);
//		}

		std::cout << "[PathPlanningSendHandler] FINISHED \n\n";

	} // end try

	catch (MessageHandler::ErrorException& e) {
		MessageHandler::handleMessage(e.getMessage(), e.getEvent(), MessageHandler::ERROR);
	}
	catch (...) {
		MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Unknown Error",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, MessageHandler::ERROR);
	}

}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_SIMULATION_PLAN_ALL()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_SIMULATION_TEST_IK_ONLY()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
