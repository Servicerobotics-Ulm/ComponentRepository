//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C)  2018 Matthias Lutz
//
//              lutz@hs-ulm.de
//              schlegel@hs-ulm.de
//
//      ZAFH Servicerobotic Ulm
//      Christian Schlegel
//      University of Applied Sciences
//      Prittwitzstr. 10
//      89075 Ulm
//      Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//-------------------------------------------------------------------------
#include "LaserDockingTask.hh"
#include "ComponentRobotToRobotDocking.hh"

#include "Driver.h"

#include <pcl/io/pcd_io.h>
#include <pcl/sample_consensus/ransac.h>
#include <pcl/sample_consensus/sac_model_circle.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/radius_outlier_removal.h>


#include <iostream>

LaserDockingTask::LaserDockingTask(SmartACE::SmartComponent *comp) 
:	LaserDockingTaskCore(comp), _driver(new Driver)
{
	std::cout << "constructor LaserDockingTask\n";
}
LaserDockingTask::~LaserDockingTask() 
{
	std::cout << "destructor LaserDockingTask\n";
}



int LaserDockingTask::on_entry()
{
	int beltID = COMP->getGlobalState().getCommRobotinoObjects().getRobotinoDockingParameter().getBELT_ID().getBeltId();
	int numBelts = COMP->getGlobalState().getCommRobotinoObjects().getRobotinoDockingParameter().getNUM_BELTS().getNumBelts();

	std::cout<<"Number of belts at this station:"<<numBelts<<std::endl;
	std::cout<<"Dock to belt number:"<<beltID<<std::endl;

//	_stationDetector->reset();

	_driver->start( beltID ); //dock to belt beltID

	laserDockingTimerId = -1; //reset timer for new Task
	return 0;
}

void LaserDockingTask::getPCLCloudFromScan(const CommBasicObjects::CommMobileLaserScan& scan, pcl::PointCloud<pcl::PointXYZ>::Ptr cloud){
	unsigned int pointcloud_size = scan.get_scan_size();


	cloud->points.resize (pointcloud_size);
	for(unsigned int i=0;i<pointcloud_size;++i){
			double x,y,z;
			scan.get_scan_cartesian_3dpoint_robot(i,x,y,z,1.0);
			cloud->points[i].x = x;
			cloud->points[i].y = y;
			cloud->points[i].z = 0.0;
		}

}


bool LaserDockingTask::detectRobot(const CommBasicObjects::CommMobileLaserScan& scan){

	bool result=true;



	//create pcl pointcloud
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
	getPCLCloudFromScan(scan,cloud);

	//dummy test data
	//	cloud.points.resize (18);
	//
	//	cloud.points[ 0].getVector3fMap () << 3.587751f, -4.190982f, 0.0f;
	//	cloud.points[ 1].getVector3fMap () << 3.808883f, -4.412265f, 0.0f;
	//	cloud.points[ 2].getVector3fMap () << 3.587525f, -5.809143f, 0.0f;
	//	cloud.points[ 3].getVector3fMap () << 2.999913f, -5.999980f, 0.0f;
	//	cloud.points[ 4].getVector3fMap () << 2.412224f, -5.809090f, 0.0f;
	//	cloud.points[ 5].getVector3fMap () << 2.191080f, -5.587682f, 0.0f;
	//	cloud.points[ 6].getVector3fMap () << 2.048941f, -5.309003f, 0.0f;
	//	cloud.points[ 7].getVector3fMap () << 2.000397f, -4.999944f, 0.0f;
	//	cloud.points[ 8].getVector3fMap () << 2.999953f, -6.000056f, 0.0f;
	//	cloud.points[ 9].getVector3fMap () << 2.691127f, -5.951136f, 0.0f;
	//	cloud.points[10].getVector3fMap () << 2.190892f, -5.587838f, 0.0f;
	//	cloud.points[11].getVector3fMap () << 2.048874f, -5.309052f, 0.0f;
	//	cloud.points[12].getVector3fMap () << 1.999990f, -5.000147f, 0.0f;
	//	cloud.points[13].getVector3fMap () << 2.049026f, -4.690918f, 0.0f;
	//	cloud.points[14].getVector3fMap () << 2.190956f, -4.412162f, 0.0f;
	//	cloud.points[15].getVector3fMap () << 2.412231f, -4.190918f, 0.0f;
	//	cloud.points[16].getVector3fMap () << 2.691027f, -4.049060f, 0.0f;
	//	cloud.points[17].getVector3fMap () << 2.000000f, -3.000000f, 0.0f;


	COMP->visTask->showPointCloud(cloud, "cloud");


	//filter away due to workspace!!
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered (new pcl::PointCloud<pcl::PointXYZ>);

	pcl::PassThrough<pcl::PointXYZ> pass;
	pass.setInputCloud (cloud);
	pass.setFilterFieldName ("x");
	pass.setFilterLimits (0.0, 2.0);
	pass.filter (*cloud_filtered);

	pass.setInputCloud (cloud_filtered);
	pass.setFilterFieldName ("y");
	pass.setFilterLimits (-1.0, 1.0);
	pass.filter (*cloud_filtered);

	COMP->visTask->showPointCloud(cloud_filtered, "filtered_cloud", 0,0,255);

	//filter away due to workspace!!
	// point cloud instance for the result
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_cleaned(new pcl::PointCloud<pcl::PointXYZ>);

	// create the radius outlier removal filter
	pcl::RadiusOutlierRemoval<pcl::PointXYZ> radius_outlier_removal;

	// set input cloud
	radius_outlier_removal.setInputCloud (cloud_filtered);

	// set radius for neighbor search
	radius_outlier_removal.setRadiusSearch (0.10);

	// set threshold for minimum required neighbors neighbors
	radius_outlier_removal.setMinNeighborsInRadius (5);
	// do filtering
	radius_outlier_removal.filter (*cloud_cleaned);

	COMP->visTask->showPointCloud(cloud_cleaned, "cloud_cleaned", 0,255,0);


	if(cloud_cleaned->size()>10){


		// Create a shared 2d circle model pointer directly
		pcl::SampleConsensusModelCircle2D<pcl::PointXYZ>::Ptr model (new pcl::SampleConsensusModelCircle2D<pcl::PointXYZ> (cloud_filtered));

		model->setRadiusLimits(0.10,0.35);


		// Create the RANSAC object
		pcl::RandomSampleConsensus<pcl::PointXYZ> sac (model, 0.03);



		// Algorithm tests
		result = sac.computeModel ();
//		std::cout<<"Result: "<<result<<std::endl;

		std::vector<int> sample;
		sac.getModel (sample);
//		std::cout<<"Sample: "<<sample.size()<<std::endl;

		std::vector<int> inliers;
		sac.getInliers (inliers);
//		std::cout<<"inliers: "<<inliers.size()<<std::endl;

		Eigen::VectorXf coeff;
		sac.getModelCoefficients (coeff);
//		std::cout<<"coeff: "<<coeff.size()<<std::endl;
//		std::cout<<"coeff[0]: "<<coeff[0]<<std::endl;
//		std::cout<<"coeff[1]: "<<coeff[1]<<std::endl;
//		std::cout<<"coeff[2]: "<<coeff[2]<<std::endl;

		Eigen::VectorXf coeff_refined;
		model->optimizeModelCoefficients (inliers, coeff, coeff_refined);
//		std::cout<<"coeff_refined: "<<coeff_refined.size()<<std::endl;
//		std::cout<<"coeff_refined[0]: "<<coeff_refined[0]<<std::endl;
//		std::cout<<"coeff_refined[1]: "<<coeff_refined[1]<<std::endl;
//		std::cout<<"coeff_refined[2]: "<<coeff_refined[2]<<std::endl;

		//convert from Eigen to pcl ModelCoefficients (std::vector)
		pcl::ModelCoefficients finalCoeffs;

		finalCoeffs.values.resize(coeff_refined.size());
		finalCoeffs.values[0] = coeff_refined[0];
		finalCoeffs.values[1] = coeff_refined[1];
		finalCoeffs.values[2] = coeff_refined[2];
		COMP->visTask->showCircle(finalCoeffs,"coeff_refined");
		result = true;

		SmartACE::SmartGuard g(goalLock);
		trackingGoal.clear();
		trackingGoal.push_back(finalCoeffs.values[0]);
		trackingGoal.push_back(finalCoeffs.values[1]);

	} else {
		std::cout<<"To few points to search for Circle!"<<std::endl;
		result = false;
	}



	return result;
}

int LaserDockingTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;

	CommRobotinoObjects::RobotinoDockingEventState goalEventState;
		// ----------------------------------------------------------
		// wait for activation
		// ("LaserDocking")
		// ----------------------------------------------------------
		status = COMP->stateSlave->acquire("LaserDocking");
		if (status == Smart::SMART_OK)
		{

	//TEST RUN stand alone!
	//		{
	//			CommBasicObjects::CommMobileLaserScan    laserScan;
	//			detectRobot(laserScan);
	//
	//		}

			CommBasicObjects::CommBaseState baseState;
			status = COMP->baseStatePushClient->getUpdateWait(baseState);
			if (status == Smart::SMART_OK) {

				double base_x = baseState.get_base_raw_position().get_x(1); //in m
				double base_y = baseState.get_base_raw_position().get_y(1); //in m
				double base_a = baseState.get_base_raw_position().get_base_azimuth(); //in rad

				CommBasicObjects::CommMobileLaserScan    laserScan;


				// dont wait for scan (PushNewest)
				status = COMP->laserClient->getUpdate( laserScan );
				if (status != Smart::SMART_OK)
				{
					if(status == Smart::SMART_UNSUBSCRIBED)
					{
						status = COMP->laserClient->subscribe();
						std::cout << "laserClient was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << Smart::StatusCodeConversion(status) << std::endl;
					} else {
						std::cout << "getUpdate for laserScan wait status " << Smart::StatusCodeConversion(status) << " not ok => retry ..." << std::endl;
					}
				}
				else
				{

	//				std::cout<<"[LaserDockingTask:] GOT LASER SCAN - size: "<<laserScan.get_scan_size()<<std::endl;

	//				_stationDetector->update( laserScan );
					detectRobot(laserScan);
				}

				if( trackingGoal.empty())
				{
					//we need some timeout here. If station is invisible for more than x seconds, we abort this task
					//COMP->ini.laser.noStationVisibleTimeout
					if(laserDockingTimerId == -1){

						std::chrono::milliseconds msec(0);
						std::chrono::seconds sec(10);

						std::cout << "[LaserDockingTask::on_execute()]  scheduleTimer relative time: " << 10 << " : " << 0 << std::endl;
						laserDockingTimerId = COMP->getComponentImpl()->getTimerManager()->scheduleTimer(this,NULL, sec+msec);
					}

					std::cout<<"[LaserDockingTask::on_execute()] Warning no Station visible!"<<std::endl;
					status = COMP->stateSlave->release("LaserDocking");
					return 0;
				}

				double vx,vy,omega;
				goalLock.lock();
				bool driver_res = _driver->update( vx, vy, omega, base_x, base_y, base_a, trackingGoal );
				goalLock.release();

				if( driver_res == true )
				{
					if(laserDockingTimerId != -1)
					{
						std::cout << "[LaserDockingTask::on_execute()]  cancelTimer!"<< std::endl;
						COMP->getComponentImpl()->getTimerManager()->cancelTimer(laserDockingTimerId);
						laserDockingTimerId = -1;
					}
				}
				else
				{
					if(laserDockingTimerId == -1){
						std::chrono::milliseconds msec(0);
						std::chrono::seconds sec(10);
						std::cout << "[LaserDockingTask::on_execute()]  scheduleTimer relative time: " << sec.count() << " : " << msec.count() << std::endl;
						laserDockingTimerId = COMP->getComponentImpl()->getTimerManager()->scheduleTimer(this,NULL, sec+msec);
					}
				}

				CommBasicObjects::CommNavigationVelocity vel;
				vel.set_vX( vx, 1 ); //in m
				vel.set_vY( vy, 1 ); // in m
				vel.set_omega( omega ); // in rad
				COMP->navVelSendClient->send(vel);


				if( _driver->isFinished() )
				{
					vel.set_vX( 0 ); //in m
					vel.set_vY( 0 ); // in m
					vel.set_omega( 0 ); // in rad
					COMP->navVelSendClient->send(vel);

					//finished
					goalEventState.set(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_DONE);
					COMP->dockingEventServer->put(goalEventState);
					std::cout<<"GOALD EVENT LASER_DOCKING_DONE FIRED!"<<std::endl;
					status = COMP->stateSlave->release("LaserDocking");
					return 1;
				}

			}
			else
			{
				std::cerr << "[LaserDockingTask] WARNING: failed to get current base state ("
					<< Smart::StatusCodeConversion(status) << ")" << std::endl;
				ACE_OS::sleep(ACE_Time_Value(0,500000));
			}
		}

		status = COMP->stateSlave->release("LaserDocking");



	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int LaserDockingTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

void LaserDockingTask::timerExpired(const Smart::TimePoint &abs_time, const void * arg)
{
			std::cout<<"[LaserDockingTask:timerExpired] ERROR TIMEOUT NO DOCKING station not visible!"<<std::endl;
			CommRobotinoObjects::RobotinoDockingEventState goalEventState;
                        goalEventState.set(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_ERROR);
                        COMP->dockingEventServer->put(goalEventState);
			this->stop(); //now stop the task

}

