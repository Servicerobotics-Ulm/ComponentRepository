//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "DemonstrationTask.hh"
#include "SmartOpenRave.hh"

#include <iostream>

DemonstrationTask::DemonstrationTask(SmartACE::SmartComponent *comp) 
:	DemonstrationTaskCore(comp)
{
	std::cout << "constructor DemonstrationTask\n";
}
DemonstrationTask::~DemonstrationTask() 
{
	std::cout << "destructor DemonstrationTask\n";
}

int DemonstrationTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	this->pose_synced = false;

	return 0;
}
int DemonstrationTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;

	//COMP->stateServer->acquire("demonstration");
	//COMP->stateServer->release("demonstration");

	COMP->stateSlave->acquire("demonstration");
	COMP->stateSlave->release("demonstration");

	if (!COMP->getGlobalState().getPortParameter().getWithManipulator())
	{
		MessageHandler::handleMessage("[DemonstrationTask] No real manipulator is attached. Demonstration Modus not possible.",
				MessageHandler::WARNING);

		sleep(1);
	}
	else {

		if (!pose_synced)
		{
			OPENRAVE->syncManipulator();
			pose_synced = true;
		}

		// TODO: Which variant ?
		this->mobileManipulatorStateServiceInGetUpdate(manipulatorState);
		//status = COMP->mobileManipulatorStateServiceIn->getUpdateWait(manipulatorState);

		if (status != Smart::SMART_OK)
		{
			MessageHandler::handleMessage("[DemonstrationTask] Timed update of ManipulatorState could not be get.", MessageHandler::WARNING);
		}

		double x, y, z, phi, theta, psi;
		manipulatorState.get_manipulator_state().get_pose_TCP_robot(x, y, z, phi, theta, psi);
		cout << "[DemonstrationTask] (x, y, z, phi, theta, psi): " << x << ", " << y
				<< ", " << z << ", " << phi << ", " << theta << ", " << psi << std::endl;

		std::vector<double> manipulatorAngles;

		// Get all Angles from the real Manipulator
		for (u_int32_t i = 0; i < manipulatorState.get_manipulator_state().get_joint_count(); ++i)
		{
			manipulatorAngles.push_back(manipulatorState.get_manipulator_state().get_joint_angle(i));
		}

		// Get gripper angles

		if (COMP->getGlobalState().getPortParameter().getWithGripper())
		{
			CommManipulatorObjects::CommGripperState gripperState;

			// TODO: Which variant ?
			this->gripperStateServiceInGetUpdate(gripperState);
			//status = COMP->gripperStateServiceIn->getUpdateWait(gripperState);

			if (status != Smart::SMART_OK)
			{
				MessageHandler::handleMessage("[DemonstrationTask] Timed update of GripperState could not be get.", MessageHandler::WARNING);
			}

			cout << "[DemonstrationTask] gripper: ";
			for (uint32_t i = 0; i < gripperState.get_size(); ++ i)
			{
				manipulatorAngles.push_back(gripperState.get_pos(i));
				cout << gripperState.get_pos(i) << ", ";
			}
			cout << "\n";
		}

		// Move the robot arm in OpenRave to the same position of real robot arm
		OPENRAVE->setJoints(manipulatorAngles);
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int DemonstrationTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
