//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include "TriggerHandler.hh"

#include "SmartOpenRave.hh"

// trigger user methods
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_CONSTRAINED_PATH(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_CLEAR()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_LOAD_FILE(const int &fileID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_LOAD_OBJECTRECOGNITION(const int &envID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_ENV_SAVE_FILE()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_CENTERED(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_NONE()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_GRASPING_SIMPLE(const double &fromHeight, const double &toHeight, const double &fromDepth, const double &toDepth, const double &fromSide, const double &toSide, const double &fromAzimuth, const double &toAzimuth, const double &fromElevation, const double &toElevation, const double &fromRoll, const double &toRoll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_NORMAL_PATH()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_ADD(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_COMPUTEGRASPTABLE(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_DELETE(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OBJ_MOVE(const int &objectID, const double &x, const double &y, const double &z, const double &yaw, const double &pitch, const double &roll)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OPENRAVE_GRASPOBJ(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_OPENRAVE_RELEASEOBJ(const int &objectID)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_SIMULATION_PLAN_ALL()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommManipulationPlannerObjects_ManipulationPlannerParameter_SIMULATION_TEST_IK_ONLY()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
