//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "PathPlanning.hh"
#include "SmartOpenRave.hh"

#include <iostream>

PathPlanning::PathPlanning(SmartACE::SmartComponent *comp) 
:	PathPlanningCore(comp)
{
	std::cout << "constructor Planning\n";
}
PathPlanning::~PathPlanning() 
{
	std::cout << "destructor Planning\n";
}

void PathPlanning::on_SendTrajectoryServiceIn(const CommManipulatorObjects::CommManipulatorTrajectory &input)
{
	// upcall triggered from InputPort SendTrajectoryServiceIn
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort SendTrajectoryServiceIn
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method sendTrajectoryServiceInGetUpdate(input) to get a copy of the input object
}

int PathPlanning::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int PathPlanning::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;
	CommManipulatorObjects::CommManipulatorTrajectory sendTrajectoryServiceInObject;
	status = this->pathPlanningRequestInGetUpdate(sendTrajectoryServiceInObject);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
		// return 0;
	} else {
		std::cout << "received: " << sendTrajectoryServiceInObject << std::endl;
	}

	std::cout << "Planning::on_execute() " << std::endl;

	try {
		// ------------------------------------------------
		// check if activated. If not, do nothing with the
		// trajectory otherwise perform it.
		// ------------------------------------------------
		if (COMP->stateSlave->tryAcquire("nonneutral") == Smart::SMART_OK)
		{
			// release trajectory state so a state change can happen
			COMP->stateSlave->release("nonneutral");

			COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			//TODO: parameterTask
			//COMP->parameterTask.waitQueueEmpty(); // wait until all parameters are applied

			MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Called and state NONNEUTRAL", MessageHandler::INFO,
					COMP->getGlobalState().getOpenRave().getDebugSend());

			SmartACE::EventId eventId;
			CommManipulatorObjects::CommManipulatorEventParameter katanaEventParameter;

			if (COMP->getGlobalState().getPortParameter().getWithManipulator())
			{
				// Set event to "Goal_not_reached" of the Manipulator so that every other event is recognized
				katanaEventParameter.setEvent(CommManipulatorObjects::ManipulatorEvent::GOAL_NOT_REACHED);

				Smart::StatusCode status = COMP->manipulatorEventServiceIn->activate(Smart::continuous, katanaEventParameter, eventId);
				if (status != Smart::SMART_OK)
				{
					throw MessageHandler::ErrorException(
						"[PathPlanningSendHandler::handleSend] Could not activate EventClient of Manipulator.",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
				}
			}
			else {
				COMP->manipulatorMode = COMP->SEND_TRAJECTORY;
			}

			OPENRAVE->syncManipulator();
			/////////////////////////////////////////////////////////////////
			std::vector<ORUtil::TrajectoryPoint> openraveTrajectory;

			// JOINT_ANGLES in the incoming trajectory
			if (sendTrajectoryServiceInObject.get_valid_values() == CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES)
			{
				handleJointAngles(sendTrajectoryServiceInObject, openraveTrajectory);
			}

			// POSES in the incoming trajectory
			else if (sendTrajectoryServiceInObject.get_valid_values() == CommManipulatorObjects::ManipulatorTrajectoryFlag::POSE_TCP)
			{
				handlePoses(sendTrajectoryServiceInObject, openraveTrajectory);
			}

			// Set default parameters into the trajectory which will be sent to the Manipulator
			CommManipulatorObjects::CommManipulatorTrajectory manipulatorTrajectory;
			manipulatorTrajectory.set_valid_values(CommManipulatorObjects::ManipulatorTrajectoryFlag::JOINT_ANGLES);
			manipulatorTrajectory.set_trajectory_size(openraveTrajectory.size());

			if (openraveTrajectory.size() == 0)
			{
				manipulatorTrajectory.set_joint_count(0);
			} else
			{
				manipulatorTrajectory.set_joint_count(openraveTrajectory[0].jointValues.size());
			}

			std::vector<double> angles;
			angles.resize(manipulatorTrajectory.get_joint_count());

			/*
			 * Iterate over the trajectory calculated by OpenRave and
			 * convert the angles into the real manipulator angles and
			 * set the converted angles into the trajectory sent to the manipulator
			 */
			for (size_t j = 0; j < openraveTrajectory.size(); ++j)
			{
				manipulatorTrajectory.set_joint_time(j, openraveTrajectory[j].time);
				for (size_t k = 0; k < angles.size(); ++k)
				{
					manipulatorTrajectory.set_joint_angle(j, k, openraveTrajectory[j].jointValues[k]);
				}
			}

			// If i == 0 the while-loop will not work this is because the first trajectory is sent
				// because we assume the arm is stationary at that point.
				/*
				 * At this point the component waits till the manipulator has finished its trajectory
				 * which has been sent before.
				 *
				 * If i == 0 the trajectory is sent directly because we assume the arm is stationary.
				 *
				 * Otherwise it tries to look what the  Manipulator Mode is set to.
				 * If it is set to SEND_TRAJECTORY the trajectory will be sent.
				 * Otherwise it tests if a FAILURE has occurred within the manipulator and
				 * exits properly.
				 */
				//CHS::SmartGuard guard(COMP->ManipulatorModeMutex);
				while (COMP->manipulatorMode != COMP->SEND_TRAJECTORY)
				{
					if (COMP->manipulatorMode == COMP->FAILURE)
					{
						throw MessageHandler::ErrorException("[PathPlanningSendHandler::handleSend] Something wrong with the Manipulator.",
								CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);

					}
					//guard.release();
					COMP->ManipulatorWaitSem.acquire();
					//guard.acquire();
				}
				//guard.release();

				// Send calculated Trajectory to the Manipulator
				Smart::StatusCode status = COMP->stateSlave->tryAcquire("trajectory");
				if (status == Smart::SMART_OK)
				{
					COMP->stateSlave->release("trajectory");

					if (COMP->getGlobalState().getPortParameter().getWithManipulator())
					{
						std::cout << "[PathPlanningSendHandler] Send trajectory to manipulator ...\n";
						status = this->sendPathTrajectoryOutPut(manipulatorTrajectory);

						if (status != Smart::SMART_OK)
						{
							throw MessageHandler::ErrorException(
									"[PathPlanningSendHandler] Send of trajectory to manipulator component failed. [handleSend in PathPlanningSendHandler]",
									CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
						}
					} else
					{
						std::cout << "[PathPlanningSendHandler] Component is in state TRAJECTORY, but withManipulator is false \n";
					}
				} else
				{
					std::cout << "[PathPlanningSendHandler] " << Smart::StatusCodeConversion(status) << "\n";
				}

				// If all points or joint angles in the incoming trajectory has been processed we send the event PATH_FOUND.
				MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Path Planning successful.",
						CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, MessageHandler::INFO,
						COMP->getGlobalState().getOpenRave().getDebugSend());

			} else
			{
				MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Component in \"neutral\" state.\n",
						MessageHandler::WARNING);
			}

			std::cout << "[PathPlanningSendHandler] FINISHED \n\n";
	}

	catch (MessageHandler::ErrorException& e)
	{
		MessageHandler::handleMessage(e.getMessage(), e.getEvent(), MessageHandler::ERROR);
	} catch (...)
	{
		MessageHandler::handleMessage("[PathPlanningSendHandler::handleSend] Unknown Error",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN, MessageHandler::ERROR);
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int PathPlanning::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

//void PathPlanning::performPreGripperAction(CommManipulatorObjects::ManipulatorGripperAction action)
//{
//	if (action == CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE || action
//			== CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER)
//	{
//		OPENRAVE->openGripper();
//	} else if (action == CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE || action
//			== CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE_OPEN_AFTER)
//	{
//		OPENRAVE->closeGripper();
//	}
//}
//
//void PathPlanning::performPostGripperAction(CommManipulatorObjects::ManipulatorGripperAction action)
//{
//	if (action == CommManipulatorObjects::ManipulatorGripperAction::OPEN_BEFORE_CLOSE_AFTER)
//	{
//		OPENRAVE->closeGripper();
//	} else if (action == CommManipulatorObjects::ManipulatorGripperAction::CLOSE_BEFORE_OPEN_AFTER)
//	{
//		OPENRAVE->openGripper();
//	}
//}

void PathPlanning::handleJointAngles(const CommManipulatorObjects::CommManipulatorTrajectory &r,
		std::vector<ORUtil::TrajectoryPoint>& openraveTrajectory)
{
	MessageHandler::handleMessage("[PathPlanningSendHandler::handleJointAngles] Planning Path.",
			CommManipulationPlannerObjects::ManipulationPlannerEvent::PLANNING_PATH, MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugSend());

	std::vector<double> angles;

	for (uint32_t j = 0; j < r.get_joint_count(); ++j)
	{
		angles.push_back(r.get_joint_angle(0, j));
	}

	if (OPENRAVE->getParameter().simulation_test_ik_only && (COMP->stateSlave->tryAcquire("simulation") == Smart::SMART_OK))
	{
		COMP->stateSlave->release("simulation");
		MessageHandler::handleMessage(
				"[PathPlanningSendHandler::handleJointAngles] IK Solution Found with SIMULATION_TEST_IK_ONLY parameter.",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::PATH_FOUND, MessageHandler::INFO, COMP->getGlobalState().getOpenRave().getDebugSend());
	}

	else if (!OPENRAVE->planPath(angles, openraveTrajectory))
	{
		throw MessageHandler::ErrorException("[PathPlanningSendHandler::handleJointAngles] Path planning failed.",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);
	}

}

void PathPlanning::handlePoses(const CommManipulatorObjects::CommManipulatorTrajectory &r,
		std::vector<ORUtil::TrajectoryPoint>& openraveTrajectory)
{
	try
	{
		std::vector<double> angles;
		double x, y, z, azimuth, elevation, roll;

		// Get TCP Pose in robot coordinate frame
		r.get_pose_TCP_robot(x, y, z, azimuth, elevation, roll, 1);

		/*cout << "[PathPlanningSendHandler::handlePoses] r.get_pose_TCP_robot(x, y, z, azimuth, elevation, roll): " << x << ", " << y
				<< ", " << z << ", " << azimuth << ", " << elevation << ", " << roll << std::endl;*/
		CommBasicObjects::CommPose3d resultPoseAfterIteration;

		if (!OPENRAVE->iterateToGetGraspingIKSolution(x, y, z, azimuth, elevation, roll, angles, resultPoseAfterIteration))
		{
			throw MessageHandler::ErrorException(
					"[PathPlanningSendHandler::handlePoses] Iteration exceeded to find grasping IK solution using.",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_IK_SOLUTION_FOUND);
		}

		// found IK solution for simple grasping
		// Send PLANNING_PATH event with final TCP pose where the path is planned to
		MessageHandler::handleMessage("[PathPlanningSendHandler::handlePoses] Planning Path.",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::PLANNING_PATH, resultPoseAfterIteration, MessageHandler::INFO,
				COMP->getGlobalState().getOpenRave().getDebugSend());

		if (!OPENRAVE->planPath(angles, openraveTrajectory))
		{
			throw MessageHandler::ErrorException("[PathPlanningSendHandler::handlePoses] Path planning failed.",
					CommManipulationPlannerObjects::ManipulationPlannerEvent::NO_PATH_FOUND);
		}
	} catch (MessageHandler::ErrorException ex)
	{
		throw ex;
	} catch (...)
	{
		throw MessageHandler::ErrorException("[PathPlanningSendHandler::handlePoses] Unknown error.",
				CommManipulationPlannerObjects::ManipulationPlannerEvent::UNKNOWN);
	}
}
