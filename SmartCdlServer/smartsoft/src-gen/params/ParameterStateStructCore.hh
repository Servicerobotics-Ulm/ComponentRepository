//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// Please do not modify this file. It will be re-generated
// running the code generator.
//--------------------------------------------------------------------------
#ifndef _PARAMETERSTATESTRUCTCORE_HH
#define _PARAMETERSTATESTRUCTCORE_HH

#include "aceSmartSoft.hh"

#include "nlohmann/json.hpp"

#include <list>
#include <iostream>

// forward declaration (in order to define validateCOMMIT(ParameterStateStruct) which is implemented in derived class)
class ParameterStateStruct;

class ParameterStateStructCore
{
	friend class ParamUpdateHandler;
public:
	
		///////////////////////////////////////////
		// Internal params
		///////////////////////////////////////////
		
		/**
		 * Definition of Parameter PathNav
		 */
		class PathNavType 
		{
			friend class ParamUpdateHandler;
		protected:
			/**
			 * here are the member definitions
			 */
			double pathNavPredictedGoalPose_controll1_dist;
			double pathNavPredictedGoalPose_controll1_speed;
			double pathNavPredictedGoalPose_controll2_dist;
			double pathNavPredictedGoalPose_controll2_speed;
			double pathNavPredictedGoalPose_controll3_dist;
			double pathNavPredictedGoalPose_controll3_speed;
			double pathNavPredictedGoalPose_minDist;
			double pathNavRecover_max_dist;
			unsigned short robotBlocked_event_timeout;
		
		public:
			// default constructor
			PathNavType() {
				pathNavPredictedGoalPose_controll1_dist = 200.0;
				pathNavPredictedGoalPose_controll1_speed = 100.0;
				pathNavPredictedGoalPose_controll2_dist = 300.0;
				pathNavPredictedGoalPose_controll2_speed = 250.0;
				pathNavPredictedGoalPose_controll3_dist = 600.0;
				pathNavPredictedGoalPose_controll3_speed = 600.0;
				pathNavPredictedGoalPose_minDist = 200;
				pathNavRecover_max_dist = 2000;
				robotBlocked_event_timeout = 15;
			}
		
			/**
			 * here are the public getters
			 */
			inline double getPathNavPredictedGoalPose_controll1_dist() const { return pathNavPredictedGoalPose_controll1_dist; }
			inline double getPathNavPredictedGoalPose_controll1_speed() const { return pathNavPredictedGoalPose_controll1_speed; }
			inline double getPathNavPredictedGoalPose_controll2_dist() const { return pathNavPredictedGoalPose_controll2_dist; }
			inline double getPathNavPredictedGoalPose_controll2_speed() const { return pathNavPredictedGoalPose_controll2_speed; }
			inline double getPathNavPredictedGoalPose_controll3_dist() const { return pathNavPredictedGoalPose_controll3_dist; }
			inline double getPathNavPredictedGoalPose_controll3_speed() const { return pathNavPredictedGoalPose_controll3_speed; }
			inline double getPathNavPredictedGoalPose_minDist() const { return pathNavPredictedGoalPose_minDist; }
			inline double getPathNavRecover_max_dist() const { return pathNavRecover_max_dist; }
			inline unsigned short getRobotBlocked_event_timeout() const { return robotBlocked_event_timeout; }
			
			void to_ostream(std::ostream &os = std::cout) const
			{
				os << "PathNav(";
				os << "pathNavPredictedGoalPose_controll1_dist = " << pathNavPredictedGoalPose_controll1_dist; os << ", ";
				os << "pathNavPredictedGoalPose_controll1_speed = " << pathNavPredictedGoalPose_controll1_speed; os << ", ";
				os << "pathNavPredictedGoalPose_controll2_dist = " << pathNavPredictedGoalPose_controll2_dist; os << ", ";
				os << "pathNavPredictedGoalPose_controll2_speed = " << pathNavPredictedGoalPose_controll2_speed; os << ", ";
				os << "pathNavPredictedGoalPose_controll3_dist = " << pathNavPredictedGoalPose_controll3_dist; os << ", ";
				os << "pathNavPredictedGoalPose_controll3_speed = " << pathNavPredictedGoalPose_controll3_speed; os << ", ";
				os << "pathNavPredictedGoalPose_minDist = " << pathNavPredictedGoalPose_minDist; os << ", ";
				os << "pathNavRecover_max_dist = " << pathNavRecover_max_dist; os << ", ";
				os << "robotBlocked_event_timeout = " << robotBlocked_event_timeout;
				os << ")\n";
			}
			
		}; // end class PathNavType
		
		/**
		 * Definition of Parameter Cdl
		 */
		class CdlType 
		{
			friend class ParamUpdateHandler;
		protected:
			/**
			 * here are the member definitions
			 */
			std::string accel_default_file;
			std::string accel_second_file;
			std::string contour_default_file;
			std::string contour_second_file;
			std::string curvature_default_file;
			std::string curvature_second_file;
			std::string dataDir;
			double delta_t_calc;
			double delta_t_trigger;
			bool followHysteresis;
			double freeBehaviorDist;
			double freeBehaviorDist_second;
			std::string lookup_default_file;
			bool lookup_default_file_compressed;
			std::string lookup_second_file;
			bool lookup_second_file_compressed;
			double rotation_acc;
			double translation_acc;
			bool use_obstacle_history;
		
		public:
			// default constructor
			CdlType() {
				accel_default_file = "CDLacc_P3DX.dat";
				accel_second_file = "CDLacc_P3DX.dat";
				contour_default_file = "CDLcontour_P3DX.dat";
				contour_second_file = "CDLcontour_P3DX.dat";
				curvature_default_file = "CDLindex_P3DX.dat";
				curvature_second_file = "CDLindex_P3DX.dat";
				dataDir = "data/lookup-files/";
				delta_t_calc = 0.35;
				delta_t_trigger = 0.1;
				followHysteresis = false;
				freeBehaviorDist = 350.0;
				freeBehaviorDist_second = 350.0;
				lookup_default_file = "CDLdist_P3DX.dat";
				lookup_default_file_compressed = false;
				lookup_second_file = "CDLdist_P3DX.dat";
				lookup_second_file_compressed = false;
				rotation_acc = 100.0;
				translation_acc = 400.0;
				use_obstacle_history = false;
			}
		
			/**
			 * here are the public getters
			 */
			inline std::string getAccel_default_file() const { return accel_default_file; }
			inline std::string getAccel_second_file() const { return accel_second_file; }
			inline std::string getContour_default_file() const { return contour_default_file; }
			inline std::string getContour_second_file() const { return contour_second_file; }
			inline std::string getCurvature_default_file() const { return curvature_default_file; }
			inline std::string getCurvature_second_file() const { return curvature_second_file; }
			inline std::string getDataDir() const { return dataDir; }
			inline double getDelta_t_calc() const { return delta_t_calc; }
			inline double getDelta_t_trigger() const { return delta_t_trigger; }
			inline bool getFollowHysteresis() const { return followHysteresis; }
			inline double getFreeBehaviorDist() const { return freeBehaviorDist; }
			inline double getFreeBehaviorDist_second() const { return freeBehaviorDist_second; }
			inline std::string getLookup_default_file() const { return lookup_default_file; }
			inline bool getLookup_default_file_compressed() const { return lookup_default_file_compressed; }
			inline std::string getLookup_second_file() const { return lookup_second_file; }
			inline bool getLookup_second_file_compressed() const { return lookup_second_file_compressed; }
			inline double getRotation_acc() const { return rotation_acc; }
			inline double getTranslation_acc() const { return translation_acc; }
			inline bool getUse_obstacle_history() const { return use_obstacle_history; }
			
			void to_ostream(std::ostream &os = std::cout) const
			{
				os << "Cdl(";
				os << "accel_default_file = " << accel_default_file; os << ", ";
				os << "accel_second_file = " << accel_second_file; os << ", ";
				os << "contour_default_file = " << contour_default_file; os << ", ";
				os << "contour_second_file = " << contour_second_file; os << ", ";
				os << "curvature_default_file = " << curvature_default_file; os << ", ";
				os << "curvature_second_file = " << curvature_second_file; os << ", ";
				os << "dataDir = " << dataDir; os << ", ";
				os << "delta_t_calc = " << delta_t_calc; os << ", ";
				os << "delta_t_trigger = " << delta_t_trigger; os << ", ";
				os << "followHysteresis = " << followHysteresis; os << ", ";
				os << "freeBehaviorDist = " << freeBehaviorDist; os << ", ";
				os << "freeBehaviorDist_second = " << freeBehaviorDist_second; os << ", ";
				os << "lookup_default_file = " << lookup_default_file; os << ", ";
				os << "lookup_default_file_compressed = " << lookup_default_file_compressed; os << ", ";
				os << "lookup_second_file = " << lookup_second_file; os << ", ";
				os << "lookup_second_file_compressed = " << lookup_second_file_compressed; os << ", ";
				os << "rotation_acc = " << rotation_acc; os << ", ";
				os << "translation_acc = " << translation_acc; os << ", ";
				os << "use_obstacle_history = " << use_obstacle_history;
				os << ")\n";
			}
			
		}; // end class CdlType
		
		/**
		 * Definition of Parameter CdlRotate
		 */
		class CdlRotateType 
		{
			friend class ParamUpdateHandler;
		protected:
			/**
			 * here are the member definitions
			 */
			double error;
			double rotDev1;
			double rotDev2;
			double rotDev3;
			double rotDev4;
			double rotSpeed1;
			double rotSpeed2;
			double rotSpeed3;
			double rotSpeed4;
		
		public:
			// default constructor
			CdlRotateType() {
				error = 5.0;
				rotDev1 = 1.0;
				rotDev2 = 1.0;
				rotDev3 = 15.0;
				rotDev4 = 45.0;
				rotSpeed1 = 0.0;
				rotSpeed2 = 2.0;
				rotSpeed3 = 10.0;
				rotSpeed4 = 70.0;
			}
		
			/**
			 * here are the public getters
			 */
			inline double getError() const { return error; }
			inline double getRotDev1() const { return rotDev1; }
			inline double getRotDev2() const { return rotDev2; }
			inline double getRotDev3() const { return rotDev3; }
			inline double getRotDev4() const { return rotDev4; }
			inline double getRotSpeed1() const { return rotSpeed1; }
			inline double getRotSpeed2() const { return rotSpeed2; }
			inline double getRotSpeed3() const { return rotSpeed3; }
			inline double getRotSpeed4() const { return rotSpeed4; }
			
			void to_ostream(std::ostream &os = std::cout) const
			{
				os << "CdlRotate(";
				os << "error = " << error; os << ", ";
				os << "rotDev1 = " << rotDev1; os << ", ";
				os << "rotDev2 = " << rotDev2; os << ", ";
				os << "rotDev3 = " << rotDev3; os << ", ";
				os << "rotDev4 = " << rotDev4; os << ", ";
				os << "rotSpeed1 = " << rotSpeed1; os << ", ";
				os << "rotSpeed2 = " << rotSpeed2; os << ", ";
				os << "rotSpeed3 = " << rotSpeed3; os << ", ";
				os << "rotSpeed4 = " << rotSpeed4;
				os << ")\n";
			}
			
		}; // end class CdlRotateType
		
		/**
		 * Definition of Parameter Server
		 */
		class ServerType 
		{
			friend class ParamUpdateHandler;
		protected:
			/**
			 * here are the member definitions
			 */
			bool baseClientInit;
			bool irClientInit;
			bool laserClient2Init;
			bool pathNavInit;
			bool plannerInit;
			bool trackerInit;
		
		public:
			// default constructor
			ServerType() {
				baseClientInit = false;
				irClientInit = false;
				laserClient2Init = false;
				pathNavInit = false;
				plannerInit = true;
				trackerInit = false;
			}
		
			/**
			 * here are the public getters
			 */
			inline bool getBaseClientInit() const { return baseClientInit; }
			inline bool getIrClientInit() const { return irClientInit; }
			inline bool getLaserClient2Init() const { return laserClient2Init; }
			inline bool getPathNavInit() const { return pathNavInit; }
			inline bool getPlannerInit() const { return plannerInit; }
			inline bool getTrackerInit() const { return trackerInit; }
			
			void to_ostream(std::ostream &os = std::cout) const
			{
				os << "Server(";
				os << "baseClientInit = " << baseClientInit; os << ", ";
				os << "irClientInit = " << irClientInit; os << ", ";
				os << "laserClient2Init = " << laserClient2Init; os << ", ";
				os << "pathNavInit = " << pathNavInit; os << ", ";
				os << "plannerInit = " << plannerInit; os << ", ";
				os << "trackerInit = " << trackerInit;
				os << ")\n";
			}
			
		}; // end class ServerType
		
	
		///////////////////////////////////////////
		// External params
		///////////////////////////////////////////
		
	
		///////////////////////////////////////////
		// Instance params
		///////////////////////////////////////////
		
		/**
		 * Definition of instantiated ParameterRepository CommNavigationObjects
		 */
		class CommNavigationObjectsType {
			friend class ParamUpdateHandler;
			public:
			/**
			 * Definition of instantiated ParameterSet CdlParameter
			 */
			class CdlParameterType {
				friend class ParamUpdateHandler;
				public:
				/**
				 * Definition of Parameter APPROACHDIST
				 */
				class APPROACHDISTType {
					friend class ParamUpdateHandler;
				
				protected:
					/**
					 * here are the member definitions
					 */
					double approachDistance;
					
				public:
					// default constructor
					APPROACHDISTType() {
						approachDistance = 100.0;
					}
					
					/**
					 * here are the getter methods
					 */
					inline double getApproachDistance() const { return approachDistance; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tAPPROACHDIST(";
						os << "approachDistance = " << approachDistance;
						os << ")\n";
					}
					
				}; // end of parameter class APPROACHDISTType
				
				/**
				 * Definition of Parameter FREEBEHAVIOR
				 */
				class FREEBEHAVIORType {
					friend class ParamUpdateHandler;
					public:
					/**
					 * Wrapper class for Enum free
					 */
					class freeType {
					public:
						enum ENUM_free {
							ENUM_VALUE_UNDEFINED = 0,
							ACTIVATE = 1,
							DEACTIVATE = 2
						};
						
						// default constructor
						freeType() { 
							value = ENUM_VALUE_UNDEFINED;
						}
						
						// copy constructor for enum type
						freeType(ENUM_free e) {
							value = e;
						}
						
						// copy constructor for String type
						freeType(const std::string &literal) {
							from_string(literal);
						}
						
						// from_string assignment operator
						freeType& operator = (const std::string &literal) {
							from_string(literal);
							return *this;
						}
						
						// ENUM operator
						operator ENUM_free() const {
							return value;
						}
						
						// String operator
						operator std::string() const {
							return to_string();
						}
						
						// compare operator
						bool operator == (const ENUM_free t) const {
							return this->value == t;
						}
						
						std::string to_string() const {
							std::string result = "";
							switch (value) {
								case ACTIVATE:
									result = "ACTIVATE";
									break;
								case DEACTIVATE:
									result = "DEACTIVATE";
									break;
								default:
									result = "ENUM_VALUE_UNDEFINED";
									break;
							};
							return result;
						}
						
						void from_string(const std::string &literal) {
							if(literal == "ACTIVATE") {
								value = ACTIVATE;
							} else if(literal == "DEACTIVATE") {
								value = DEACTIVATE;
							} else {
								value = ENUM_VALUE_UNDEFINED;
							}
						}
						
						// helper method to easily implement output stream
						void to_ostream(std::ostream &os = std::cout) const {
							os << to_string();
						}
					private:
						ENUM_free value;
					};
					
					
				
				protected:
					/**
					 * here are the member definitions
					 */
					FREEBEHAVIORType::freeType free;
					
				public:
					// default constructor
					FREEBEHAVIORType() {
						free = FREEBEHAVIORType::freeType::DEACTIVATE;
					}
					
					/**
					 * here are the getter methods
					 */
					inline FREEBEHAVIORType::freeType getFree() const { return free; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tFREEBEHAVIOR(";
						os << "free = " << free;
						os << ")\n";
					}
					
				}; // end of parameter class FREEBEHAVIORType
				
				/**
				 * Definition of Parameter GOALMODE
				 */
				class GOALMODEType {
					friend class ParamUpdateHandler;
					public:
					/**
					 * Wrapper class for Enum gm
					 */
					class gmType {
					public:
						enum ENUM_gm {
							ENUM_VALUE_UNDEFINED = 0,
							ABSOLUTE = 1,
							PLANNER = 2,
							PERSON = 3,
							SAVED = 4,
							ANGLE_ABSOLUTE = 5,
							ANGLE_RELATIVE = 6,
							NEUTRAL = 7,
							PATH_NAV = 8
						};
						
						// default constructor
						gmType() { 
							value = ENUM_VALUE_UNDEFINED;
						}
						
						// copy constructor for enum type
						gmType(ENUM_gm e) {
							value = e;
						}
						
						// copy constructor for String type
						gmType(const std::string &literal) {
							from_string(literal);
						}
						
						// from_string assignment operator
						gmType& operator = (const std::string &literal) {
							from_string(literal);
							return *this;
						}
						
						// ENUM operator
						operator ENUM_gm() const {
							return value;
						}
						
						// String operator
						operator std::string() const {
							return to_string();
						}
						
						// compare operator
						bool operator == (const ENUM_gm t) const {
							return this->value == t;
						}
						
						std::string to_string() const {
							std::string result = "";
							switch (value) {
								case ABSOLUTE:
									result = "ABSOLUTE";
									break;
								case ANGLE_ABSOLUTE:
									result = "ANGLE_ABSOLUTE";
									break;
								case ANGLE_RELATIVE:
									result = "ANGLE_RELATIVE";
									break;
								case NEUTRAL:
									result = "NEUTRAL";
									break;
								case PATH_NAV:
									result = "PATH_NAV";
									break;
								case PERSON:
									result = "PERSON";
									break;
								case PLANNER:
									result = "PLANNER";
									break;
								case SAVED:
									result = "SAVED";
									break;
								default:
									result = "ENUM_VALUE_UNDEFINED";
									break;
							};
							return result;
						}
						
						void from_string(const std::string &literal) {
							if(literal == "ABSOLUTE") {
								value = ABSOLUTE;
							} else if(literal == "PLANNER") {
								value = PLANNER;
							} else if(literal == "PERSON") {
								value = PERSON;
							} else if(literal == "SAVED") {
								value = SAVED;
							} else if(literal == "ANGLE_ABSOLUTE") {
								value = ANGLE_ABSOLUTE;
							} else if(literal == "ANGLE_RELATIVE") {
								value = ANGLE_RELATIVE;
							} else if(literal == "NEUTRAL") {
								value = NEUTRAL;
							} else if(literal == "PATH_NAV") {
								value = PATH_NAV;
							} else {
								value = ENUM_VALUE_UNDEFINED;
							}
						}
						
						// helper method to easily implement output stream
						void to_ostream(std::ostream &os = std::cout) const {
							os << to_string();
						}
					private:
						ENUM_gm value;
					};
					
					
				
				protected:
					/**
					 * here are the member definitions
					 */
					GOALMODEType::gmType gm;
					
				public:
					// default constructor
					GOALMODEType() {
						gm = GOALMODEType::gmType::NEUTRAL;
					}
					
					/**
					 * here are the getter methods
					 */
					inline GOALMODEType::gmType getGm() const { return gm; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tGOALMODE(";
						os << "gm = " << gm;
						os << ")\n";
					}
					
				}; // end of parameter class GOALMODEType
				
				/**
				 * Definition of Parameter GOALREGION
				 */
				class GOALREGIONType {
					friend class ParamUpdateHandler;
				
				protected:
					/**
					 * here are the member definitions
					 */
					double goalA;
					double goalX;
					double goalY;
					
				public:
					// default constructor
					GOALREGIONType() {
						goalA = 0.0;
						goalX = 0.0;
						goalY = 0.0;
					}
					
					/**
					 * here are the getter methods
					 */
					inline double getGoalA() const { return goalA; }
					inline double getGoalX() const { return goalX; }
					inline double getGoalY() const { return goalY; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tGOALREGION(";
						os << "goalA = " << goalA; os << ", ";
						os << "goalX = " << goalX; os << ", ";
						os << "goalY = " << goalY;
						os << ")\n";
					}
					
				}; // end of parameter class GOALREGIONType
				
				/**
				 * Definition of Parameter ID
				 */
				class IDType {
					friend class ParamUpdateHandler;
				
				protected:
					/**
					 * here are the member definitions
					 */
					int id;
					
				public:
					// default constructor
					IDType() {
						id = 0;
					}
					
					/**
					 * here are the getter methods
					 */
					inline int getId() const { return id; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tID(";
						os << "id = " << id;
						os << ")\n";
					}
					
				}; // end of parameter class IDType
				
				/**
				 * Definition of Parameter LOOKUPTABLE
				 */
				class LOOKUPTABLEType {
					friend class ParamUpdateHandler;
					public:
					/**
					 * Wrapper class for Enum lt
					 */
					class ltType {
					public:
						enum ENUM_lt {
							ENUM_VALUE_UNDEFINED = 0,
							DEFAULT = 1,
							SECOND = 2
						};
						
						// default constructor
						ltType() { 
							value = ENUM_VALUE_UNDEFINED;
						}
						
						// copy constructor for enum type
						ltType(ENUM_lt e) {
							value = e;
						}
						
						// copy constructor for String type
						ltType(const std::string &literal) {
							from_string(literal);
						}
						
						// from_string assignment operator
						ltType& operator = (const std::string &literal) {
							from_string(literal);
							return *this;
						}
						
						// ENUM operator
						operator ENUM_lt() const {
							return value;
						}
						
						// String operator
						operator std::string() const {
							return to_string();
						}
						
						// compare operator
						bool operator == (const ENUM_lt t) const {
							return this->value == t;
						}
						
						std::string to_string() const {
							std::string result = "";
							switch (value) {
								case DEFAULT:
									result = "DEFAULT";
									break;
								case SECOND:
									result = "SECOND";
									break;
								default:
									result = "ENUM_VALUE_UNDEFINED";
									break;
							};
							return result;
						}
						
						void from_string(const std::string &literal) {
							if(literal == "DEFAULT") {
								value = DEFAULT;
							} else if(literal == "SECOND") {
								value = SECOND;
							} else {
								value = ENUM_VALUE_UNDEFINED;
							}
						}
						
						// helper method to easily implement output stream
						void to_ostream(std::ostream &os = std::cout) const {
							os << to_string();
						}
					private:
						ENUM_lt value;
					};
					
					
				
				protected:
					/**
					 * here are the member definitions
					 */
					LOOKUPTABLEType::ltType lt;
					
				public:
					// default constructor
					LOOKUPTABLEType() {
						lt = LOOKUPTABLEType::ltType::DEFAULT;
					}
					
					/**
					 * here are the getter methods
					 */
					inline LOOKUPTABLEType::ltType getLt() const { return lt; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tLOOKUPTABLE(";
						os << "lt = " << lt;
						os << ")\n";
					}
					
				}; // end of parameter class LOOKUPTABLEType
				
				/**
				 * Definition of Parameter PATHNAVFREEBEHAVIOR
				 */
				class PATHNAVFREEBEHAVIORType {
					friend class ParamUpdateHandler;
					public:
					/**
					 * Wrapper class for Enum free
					 */
					class freeType {
					public:
						enum ENUM_free {
							ENUM_VALUE_UNDEFINED = 0,
							ACTIVATE = 1,
							DEACTIVATE = 2
						};
						
						// default constructor
						freeType() { 
							value = ENUM_VALUE_UNDEFINED;
						}
						
						// copy constructor for enum type
						freeType(ENUM_free e) {
							value = e;
						}
						
						// copy constructor for String type
						freeType(const std::string &literal) {
							from_string(literal);
						}
						
						// from_string assignment operator
						freeType& operator = (const std::string &literal) {
							from_string(literal);
							return *this;
						}
						
						// ENUM operator
						operator ENUM_free() const {
							return value;
						}
						
						// String operator
						operator std::string() const {
							return to_string();
						}
						
						// compare operator
						bool operator == (const ENUM_free t) const {
							return this->value == t;
						}
						
						std::string to_string() const {
							std::string result = "";
							switch (value) {
								case ACTIVATE:
									result = "ACTIVATE";
									break;
								case DEACTIVATE:
									result = "DEACTIVATE";
									break;
								default:
									result = "ENUM_VALUE_UNDEFINED";
									break;
							};
							return result;
						}
						
						void from_string(const std::string &literal) {
							if(literal == "ACTIVATE") {
								value = ACTIVATE;
							} else if(literal == "DEACTIVATE") {
								value = DEACTIVATE;
							} else {
								value = ENUM_VALUE_UNDEFINED;
							}
						}
						
						// helper method to easily implement output stream
						void to_ostream(std::ostream &os = std::cout) const {
							os << to_string();
						}
					private:
						ENUM_free value;
					};
					
					
				
				protected:
					/**
					 * here are the member definitions
					 */
					PATHNAVFREEBEHAVIORType::freeType free;
					
				public:
					// default constructor
					PATHNAVFREEBEHAVIORType() {
						free = PATHNAVFREEBEHAVIORType::freeType::DEACTIVATE;
					}
					
					/**
					 * here are the getter methods
					 */
					inline PATHNAVFREEBEHAVIORType::freeType getFree() const { return free; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tPATHNAVFREEBEHAVIOR(";
						os << "free = " << free;
						os << ")\n";
					}
					
				}; // end of parameter class PATHNAVFREEBEHAVIORType
				
				/**
				 * Definition of Parameter ROTVEL
				 */
				class ROTVELType {
					friend class ParamUpdateHandler;
				
				protected:
					/**
					 * here are the member definitions
					 */
					double wmax;
					double wmin;
					
				public:
					// default constructor
					ROTVELType() {
						wmax = 40.0;
						wmin = -40.0;
					}
					
					/**
					 * here are the getter methods
					 */
					inline double getWmax() const { return wmax; }
					inline double getWmin() const { return wmin; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tROTVEL(";
						os << "wmax = " << wmax; os << ", ";
						os << "wmin = " << wmin;
						os << ")\n";
					}
					
				}; // end of parameter class ROTVELType
				
				/**
				 * Definition of Parameter SAFETYCL
				 */
				class SAFETYCLType {
					friend class ParamUpdateHandler;
				
				protected:
					/**
					 * here are the member definitions
					 */
					int safetyClearance;
					
				public:
					// default constructor
					SAFETYCLType() {
						safetyClearance = 200;
					}
					
					/**
					 * here are the getter methods
					 */
					inline int getSafetyClearance() const { return safetyClearance; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tSAFETYCL(";
						os << "safetyClearance = " << safetyClearance;
						os << ")\n";
					}
					
				}; // end of parameter class SAFETYCLType
				
				/**
				 * Definition of Parameter TRANSVEL
				 */
				class TRANSVELType {
					friend class ParamUpdateHandler;
				
				protected:
					/**
					 * here are the member definitions
					 */
					double vmax;
					double vmin;
					
				public:
					// default constructor
					TRANSVELType() {
						vmax = 400.0;
						vmin = 0.0;
					}
					
					/**
					 * here are the getter methods
					 */
					inline double getVmax() const { return vmax; }
					inline double getVmin() const { return vmin; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "\tTRANSVEL(";
						os << "vmax = " << vmax; os << ", ";
						os << "vmin = " << vmin;
						os << ")\n";
					}
					
				}; // end of parameter class TRANSVELType
				
				protected:
					/**
					 * internal members
					 */
					APPROACHDISTType APPROACHDIST;
					FREEBEHAVIORType FREEBEHAVIOR;
					GOALMODEType GOALMODE;
					GOALREGIONType GOALREGION;
					IDType ID;
					LOOKUPTABLEType LOOKUPTABLE;
					PATHNAVFREEBEHAVIORType PATHNAVFREEBEHAVIOR;
					ROTVELType ROTVEL;
					SAFETYCLType SAFETYCL;
					TRANSVELType TRANSVEL;
					
				public:
					/**
					 * public getter methods
					 */
					inline APPROACHDISTType getAPPROACHDIST() const { return APPROACHDIST; }
					inline FREEBEHAVIORType getFREEBEHAVIOR() const { return FREEBEHAVIOR; }
					inline GOALMODEType getGOALMODE() const { return GOALMODE; }
					inline GOALREGIONType getGOALREGION() const { return GOALREGION; }
					inline IDType getID() const { return ID; }
					inline LOOKUPTABLEType getLOOKUPTABLE() const { return LOOKUPTABLE; }
					inline PATHNAVFREEBEHAVIORType getPATHNAVFREEBEHAVIOR() const { return PATHNAVFREEBEHAVIOR; }
					inline ROTVELType getROTVEL() const { return ROTVEL; }
					inline SAFETYCLType getSAFETYCL() const { return SAFETYCL; }
					inline TRANSVELType getTRANSVEL() const { return TRANSVEL; }
					
					void to_ostream(std::ostream &os = std::cout) const
					{
						os << "CdlParameter(\n";
						APPROACHDIST.to_ostream(os);
						FREEBEHAVIOR.to_ostream(os);
						GOALMODE.to_ostream(os);
						GOALREGION.to_ostream(os);
						ID.to_ostream(os);
						LOOKUPTABLE.to_ostream(os);
						PATHNAVFREEBEHAVIOR.to_ostream(os);
						ROTVEL.to_ostream(os);
						SAFETYCL.to_ostream(os);
						TRANSVEL.to_ostream(os);
						os << ")";
					}
			}; // end of parameter-set class CdlParameterType
			
			protected:
				/**
				 * internal members
				 */
				CdlParameterType CdlParameter;
			
			public:
				/**
				 * public getter methods
				 */
				inline CdlParameterType getCdlParameter() const { return CdlParameter; }
				
				void to_ostream(std::ostream &os = std::cout) const
				{
					os << "CommNavigationObjects(\n";
					CdlParameter.to_ostream(os);
					os << ")";
				}
		}; // end of parameter-repository wrapper class CommNavigationObjectsType
	
protected:

	// Internal params
	CdlType Cdl;
	CdlRotateType CdlRotate;
	PathNavType PathNav;
	ServerType Server;
	
	// External params
	
	// Instance params (encapsulated in a wrapper class for each instantiated parameter repository)
	CommNavigationObjectsType CommNavigationObjects;
	

	void setContent(const ParameterStateStructCore &commit) {
		// External params
	
		this->CommNavigationObjects = commit.getCommNavigationObjects();
	}

	// special trigger method (user upcall) called before updating parameter global state
	virtual SmartACE::ParamResponseType handleCOMMIT(const ParameterStateStruct &commitState) = 0;
public:
	ParameterStateStructCore() {  }
	virtual ~ParameterStateStructCore() {  }
	
	// internal param getters
	CdlType getCdl() const {
		return Cdl;
	}
	CdlRotateType getCdlRotate() const {
		return CdlRotate;
	}
	PathNavType getPathNav() const {
		return PathNav;
	}
	ServerType getServer() const {
		return Server;
	}
	
	// external param getters
	
	// repo wrapper class getter(s)
	CommNavigationObjectsType getCommNavigationObjects() const {
		return CommNavigationObjects;
	}
	
	// helper method to easily implement output stream in derived classes
	void to_ostream(std::ostream &os = std::cout) const
	{
		// Internal params
		Cdl.to_ostream(os);
		CdlRotate.to_ostream(os);
		PathNav.to_ostream(os);
		Server.to_ostream(os);
		
		// External params
		
		// Instance params (encapsulated in a wrapper class for each instantiated parameter repository)
		CommNavigationObjects.to_ostream(os);
	}
	
	std::string getAsJSONString() {
		nlohmann::json param;
	
		param["Cdl"] = nlohmann::json {
			{"accel_default_file" , getCdl().getAccel_default_file()},
			{"accel_second_file" , getCdl().getAccel_second_file()},
			{"contour_default_file" , getCdl().getContour_default_file()},
			{"contour_second_file" , getCdl().getContour_second_file()},
			{"curvature_default_file" , getCdl().getCurvature_default_file()},
			{"curvature_second_file" , getCdl().getCurvature_second_file()},
			{"dataDir" , getCdl().getDataDir()},
			{"delta_t_calc" , getCdl().getDelta_t_calc()},
			{"delta_t_trigger" , getCdl().getDelta_t_trigger()},
			{"followHysteresis" , getCdl().getFollowHysteresis()},
			{"freeBehaviorDist" , getCdl().getFreeBehaviorDist()},
			{"freeBehaviorDist_second" , getCdl().getFreeBehaviorDist_second()},
			{"lookup_default_file" , getCdl().getLookup_default_file()},
			{"lookup_default_file_compressed" , getCdl().getLookup_default_file_compressed()},
			{"lookup_second_file" , getCdl().getLookup_second_file()},
			{"lookup_second_file_compressed" , getCdl().getLookup_second_file_compressed()},
			{"rotation_acc" , getCdl().getRotation_acc()},
			{"translation_acc" , getCdl().getTranslation_acc()},
			{"use_obstacle_history" , getCdl().getUse_obstacle_history()}
		};
		param["CdlRotate"] = nlohmann::json {
			{"error" , getCdlRotate().getError()},
			{"rotDev1" , getCdlRotate().getRotDev1()},
			{"rotDev2" , getCdlRotate().getRotDev2()},
			{"rotDev3" , getCdlRotate().getRotDev3()},
			{"rotDev4" , getCdlRotate().getRotDev4()},
			{"rotSpeed1" , getCdlRotate().getRotSpeed1()},
			{"rotSpeed2" , getCdlRotate().getRotSpeed2()},
			{"rotSpeed3" , getCdlRotate().getRotSpeed3()},
			{"rotSpeed4" , getCdlRotate().getRotSpeed4()}
		};
		param["PathNav"] = nlohmann::json {
			{"pathNavPredictedGoalPose_controll1_dist" , getPathNav().getPathNavPredictedGoalPose_controll1_dist()},
			{"pathNavPredictedGoalPose_controll1_speed" , getPathNav().getPathNavPredictedGoalPose_controll1_speed()},
			{"pathNavPredictedGoalPose_controll2_dist" , getPathNav().getPathNavPredictedGoalPose_controll2_dist()},
			{"pathNavPredictedGoalPose_controll2_speed" , getPathNav().getPathNavPredictedGoalPose_controll2_speed()},
			{"pathNavPredictedGoalPose_controll3_dist" , getPathNav().getPathNavPredictedGoalPose_controll3_dist()},
			{"pathNavPredictedGoalPose_controll3_speed" , getPathNav().getPathNavPredictedGoalPose_controll3_speed()},
			{"pathNavPredictedGoalPose_minDist" , getPathNav().getPathNavPredictedGoalPose_minDist()},
			{"pathNavRecover_max_dist" , getPathNav().getPathNavRecover_max_dist()},
			{"robotBlocked_event_timeout" , getPathNav().getRobotBlocked_event_timeout()}
		};
		param["Server"] = nlohmann::json {
			{"baseClientInit" , getServer().getBaseClientInit()},
			{"irClientInit" , getServer().getIrClientInit()},
			{"laserClient2Init" , getServer().getLaserClient2Init()},
			{"pathNavInit" , getServer().getPathNavInit()},
			{"plannerInit" , getServer().getPlannerInit()},
			{"trackerInit" , getServer().getTrackerInit()}
		};
	
		param["CdlParameter"] = nlohmann::json {
			{ "APPROACHDIST", {
				{"approachDistance" , getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()}
			}},
			{ "FREEBEHAVIOR", {
				{"free" , getCommNavigationObjects().getCdlParameter().getFREEBEHAVIOR().getFree()}
			}},
			{ "GOALMODE", {
				{"gm" , getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm()}
			}},
			{ "GOALREGION", {
				{"goalA" , getCommNavigationObjects().getCdlParameter().getGOALREGION().getGoalA()},
				{"goalX" , getCommNavigationObjects().getCdlParameter().getGOALREGION().getGoalX()},
				{"goalY" , getCommNavigationObjects().getCdlParameter().getGOALREGION().getGoalY()}
			}},
			{ "ID", {
				{"id" , getCommNavigationObjects().getCdlParameter().getID().getId()}
			}},
			{ "LOOKUPTABLE", {
				{"lt" , getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt()}
			}},
			{ "PATHNAVFREEBEHAVIOR", {
				{"free" , getCommNavigationObjects().getCdlParameter().getPATHNAVFREEBEHAVIOR().getFree()}
			}},
			{ "ROTVEL", {
				{"wmax" , getCommNavigationObjects().getCdlParameter().getROTVEL().getWmax()},
				{"wmin" , getCommNavigationObjects().getCdlParameter().getROTVEL().getWmin()}
			}},
			{ "SAFETYCL", {
				{"safetyClearance" , getCommNavigationObjects().getCdlParameter().getSAFETYCL().getSafetyClearance()}
			}},
			{ "TRANSVEL", {
				{"vmax" , getCommNavigationObjects().getCdlParameter().getTRANSVEL().getVmax()},
				{"vmin" , getCommNavigationObjects().getCdlParameter().getTRANSVEL().getVmin()}
			}}
		};
		
		return param.dump();
	}
};

#endif
