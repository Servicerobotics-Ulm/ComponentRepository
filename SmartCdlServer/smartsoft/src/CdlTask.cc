//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft CDL component".
//  It provides navigation services based on the CDL
//  Curvature Distance Lookup approach.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "CdlTask.hh"
#include "SmartCdlServer.hh"

#include <iostream>

#include <sys/time.h>

#ifdef WITH_OPENCV_CDL_LOOKUP_DEBUG
	#include "cv.h"
	#include "highgui.h"
#endif

// -------------------------------------------------------------
//
// -------------------------------------------------------------
double angle00(double a)
{
	if (a < -M_PI || a >= M_PI)
	{
		a = a - 2*M_PI * floor(a / (2*M_PI));
		while(a < -M_PI) a += 2*M_PI;
		while(a >= M_PI) a -= 2*M_PI;
	}

	return(a);
}

CdlTask::CdlTask(SmartACE::SmartComponent *comp) 
:	CdlTaskCore(comp)
{
	std::cout << "constructor CdlTask\n";
}
CdlTask::~CdlTask() 
{
	std::cout << "destructor CdlTask\n";
}


void CdlTask::on_LaserClient(const CommBasicObjects::CommMobileLaserScan &input)
{
	// upcall triggered from InputPort LaserClient
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort LaserClient
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method laserClientGetUpdate(input) to get a copy of the input object
}
void CdlTask::on_PlannerClient(const CommNavigationObjects::CommPlannerGoal &input)
{
	// upcall triggered from InputPort PlannerClient
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort PlannerClient
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method plannerClientGetUpdate(input) to get a copy of the input object
}
void CdlTask::on_NavVelSendServer(const CommBasicObjects::CommNavigationVelocity &input)
{
	// upcall triggered from InputPort NavVelSendServer
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort NavVelSendServer
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method navVelSendServerGetUpdate(input) to get a copy of the input object

    int v = input.get_vX();
    double omega = input.get_omega();

    if( COMP->getStrategy() == TriggerHandler::SETSTRATEGYType::stratType::JOYSTICK )
    {
      COMP->cdlLookup->setDesiredTranslationalSpeed(v);
      //std::cout << "NavigationVelocitySendHandler::cdlLookup->setDesiredTranslationalSpeed = " << v << std::endl;
      COMP->cdlLookup->setHeading(omega);
      //std::cout << "NavigationVelocitySendHandler::cdlLookup->setHeading = " << omega << std::endl;
    } else if (COMP->getStrategy() == TriggerHandler::SETSTRATEGYType::stratType::VELCHECK){
    	COMP->setDesiredVelocities(v,omega);
      //COMP->cdlLookup->setDesiredTranslationalSpeed(v);
//	  std::cout << "NavigationVelocitySendHandler::cdlLookup->setDesiredTranslationalSpeed = " << v << std::endl;
	  //COMP->cdlLookup->setDesiredRotationalSpeed(omega);
//	  std::cout << "NavigationVelocitySendHandler::cdlLookup->setHeading = " << omega << std::endl;
    }
}
void CdlTask::on_TrackingClient(const CommTrackingObjects::CommTrackingGoal &input)
{
	// upcall triggered from InputPort TrackingClient
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort TrackingClient
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method trackingClientGetUpdate(input) to get a copy of the input object
}
void CdlTask::on_LaserClient2(const CommBasicObjects::CommMobileLaserScan &input)
{
	// upcall triggered from InputPort LaserClient2
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort LaserClient2
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method laserClient2GetUpdate(input) to get a copy of the input object
}
void CdlTask::on_IRClient(const CommBasicObjects::CommMobileIRScan &input)
{
	// upcall triggered from InputPort IRClient
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort IRClient
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method iRClientGetUpdate(input) to get a copy of the input object
}
void CdlTask::on_PathNavigationGoalClient(const CommRobotinoObjects::CommPathNavigationGoal &input)
{
	// upcall triggered from InputPort PathNavigationGoalClient
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort PathNavigationGoalClient
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method pathNavigationGoalClientGetUpdate(input) to get a copy of the input object
}
void CdlTask::on_BaseStateClient(const CommBasicObjects::CommBaseState &input)
{
	// upcall triggered from InputPort BaseStateClient
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort BaseStateClient
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method baseStateClientGetUpdate(input) to get a copy of the input object
}

int CdlTask::on_entry()
{
#ifdef WITH_OPENCV_CDL_LOOKUP_DEBUG
	cvNamedWindow("cdldebug", CV_WINDOW_AUTOSIZE);
	//cvNamedWindow("cdldebug", CV_WINDOW_NORMAL);
	//cvSetWindowProperty("cdldebug", CV_WND_PROP_FULLSCREEN, CV_WINDOW_FULLSCREEN);
#endif

	evalFunction = CDL_EVAL_STANDARD;

	stalledFlag = 0;
	trick15Flag = false;

	covForwardFlag = true;
	covTurningFlag = false;


	this->previous_strategy = TriggerHandler::SETSTRATEGYType::stratType::REACTIVE;
	//</alexej>


	previous_trackX = 0.0;
	previous_trackY = 0.0;

	old_counter = 0;
	firstPass = true;

	return 0;
}

void transformWorldPointToRobot(double wx, double wy, double wa, double px, double py, double &lx, double &ly) {
					double cos_a = cos(wa);
					double sin_a = sin(wa);
					lx = (px - wx) * cos_a + (py - wy) * sin_a;
					ly =-(px - wx) * sin_a + (py - wy) * cos_a;
}

double CdlTask::linearinterpolation(const std::vector<std::pair<double, double> >& vec, const double x )
{
	std::vector<std::pair<double, double> >::const_iterator iter, end;
	iter = vec.begin();
	end = vec.end();

	double y = 0.0;

	if( iter != end )
	{
		if( x < (*iter).first )
		{
			y = (*iter).second;
		}
		else
		{
			while( end != iter )
			{
				const std::pair<double, double>& p = (*iter);
				++iter;

				if( x >= p.first )
				{
					if( end != iter )
					{
						if( x < (*iter).first )
						{
							const std::pair<double, double>& p2 = (*iter);
							double dx = p2.first - p.first;
							double dy = p2.second - p.second;

							if( 0.0 == dx )
							{
								y = p.second;
							}
							else
							{
								double a = dy / dx;
								y = a * ( x - p.first ) + p.second;
							}
						}
					}
					else
					{
						y = p.second;
					}
				}
			}
		}
	}

	return y;
}


int CdlTask::on_execute()
{
	// ----------------------------------------------------------
	// access the global configuration information
	// ----------------------------------------------------------
	//<alexej>
	// get a local copy of the consistent parameter set as read only (const)
	// this ensures that until the end of this scope the localState keeps consistent
	const ParameterStateStruct localState = COMP->getGlobalState();

	TriggerHandler::SETSTRATEGYType::stratType temp_strategy;
	if(COMP->isStrategyTriggered()) {
		// take the current strategy
		temp_strategy = COMP->getStrategy();
		// also reset the previous strategy to use it in the next iterations
		this->previous_strategy = COMP->getStrategy();
	} else {
		// use the previous strategy, which can be changed by the task itself,
		// as long as no new strategy updates are received in the parameter port
		temp_strategy = this->previous_strategy;
	}
	const TriggerHandler::SETSTRATEGYType::stratType local_strategy = temp_strategy;

	// TODO: this goalId is at the moment one of the most confusing parameter variables in this component
	// imho it definitively needs a redesign (it should not be a read/write but a read only parameter)
	// (it seems to somehow conflict with the parameter goal id)
	long local_goalId = COMP->getGoalId();

	// a coordinate of goal
	double local_goalA = localState.getCommNavigationObjects().getCdlParameter().getGOALREGION().getGoalA() * M_PI/180.0;
	double local_goalX = localState.getCommNavigationObjects().getCdlParameter().getGOALREGION().getGoalX();
	double local_goalY = localState.getCommNavigationObjects().getCdlParameter().getGOALREGION().getGoalY();

	// ----------------------------------------------------------
	// the module has been activated
	// ----------------------------------------------------------

	// select the correct lookup table
	if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
	{
		COMP->cdlLookup = &(COMP->cdlLookupSecond);
	}
	else
	{
		COMP->cdlLookup = &(COMP->cdlLookupDefault);
	}

	// local variables which are moved from global/local state struct to here,
	// since they are only used locally within this class and are only used read-only, they are defined as const
	const double local_rotateError = localState.getCdlRotate().getError() * M_PI/180.0; // angular error to stop rotation in place

	const double local_transAcc = localState.getCdl().getTranslation_acc(); // translational acceleration
	const double local_rotAcc = localState.getCdl().getRotation_acc() * M_PI/180.0; // rotational acceleration
	const double local_ttrigger = localState.getCdl().getDelta_t_trigger(); // time step prediction into future
	const double local_tcalc	= localState.getCdl().getDelta_t_calc(); // time step execution cycle

	const double local_vmin = (localState.getCommNavigationObjects().getCdlParameter().getTRANSVEL().getVmin() < COMP->cdlLookup->getCDL_V_TRA_MIN())? COMP->cdlLookup->getCDL_V_TRA_MIN() : localState.getCommNavigationObjects().getCdlParameter().getTRANSVEL().getVmin();
	const double local_vmax = (localState.getCommNavigationObjects().getCdlParameter().getTRANSVEL().getVmax() > COMP->cdlLookup->getCDL_V_TRA_MAX())? COMP->cdlLookup->getCDL_V_TRA_MAX() : localState.getCommNavigationObjects().getCdlParameter().getTRANSVEL().getVmax();
	double temp_omega = 0.0;
	if(localState.getCommNavigationObjects().getCdlParameter().getROTVEL().getWmin() < COMP->cdlLookup->getCDL_V_ROT_MIN()) {
		temp_omega = COMP->cdlLookup->getCDL_V_ROT_MIN() * M_PI/180.0;
	} else {
		temp_omega = localState.getCommNavigationObjects().getCdlParameter().getROTVEL().getWmin() * M_PI/180.0;
	}
	const double local_wmin = temp_omega; // current run: minimum allowed velocity
	if(localState.getCommNavigationObjects().getCdlParameter().getROTVEL().getWmax() > COMP->cdlLookup->getCDL_V_ROT_MAX()) {
		temp_omega = COMP->cdlLookup->getCDL_V_ROT_MAX() * M_PI/180.0;
	} else {
		temp_omega = localState.getCommNavigationObjects().getCdlParameter().getROTVEL().getWmax() * M_PI/180.0;
	}
	const double local_wmax = temp_omega; // current run: maximum allowed velocity
	temp_omega = 0.0;
	//</alexej>

//		std::cout << "vmin: " << local_vmin << "  vmax: " << local_vmax << std::endl;


	// we have to ask for the current velocities


	//smartBase.getRotateVelocity(w);     ???
	//smartBase.getTranslateVelocity(v);  ???
	//smartBase.getPos(spos);             ???

	// dont wait for scan (PushNewest)
	status = COMP->laserClient->getUpdate( scan );
	if (status != Smart::SMART_OK)
	{
		if(status == Smart::SMART_UNSUBSCRIBED)
		{
			status = COMP->laserClient->subscribe();
			std::cout << "laserClient was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << status << std::endl;
		} else {
			std::cout << "blocking wait status " << status << " not ok => retry ..." << std::endl;
		}
	}
	else
	{
		if(COMP->getGlobalState().getServer().getLaserClient2Init())
		{
			status = COMP->laserClient2->getUpdate( scan2 );
			if (status != Smart::SMART_OK)
			{
				if(status == Smart::SMART_UNSUBSCRIBED)
				{
					status = COMP->laserClient2->subscribe();
					std::cout << "laserClient2 was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << status << std::endl;
				} else {
					std::cout << "blocking wait status " << status << std::endl;
				}
				std::cout << "WARNING: Navigation configured(ini file) with TWO laserClients but only ONE in use!" << std::endl;
			}
		}


		if(COMP->getGlobalState().getServer().getIrClientInit())
		{
			status = COMP->iRClient->getUpdate( irScan );
			if (status != Smart::SMART_OK)
			{
				if(status == Smart::SMART_UNSUBSCRIBED)
				{
					status = COMP->iRClient->subscribe();
					std::cout << "irClient was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << status << std::endl;
				} else {
					std::cout << "blocking wait status " << status << std::endl;
				}
				std::cout << "WARNING: Navigation configured(ini file) with irClient but NOT in use!" << std::endl;
			}
		}

		v = scan.get_base_state().get_base_velocity().get_vX();
		w = scan.get_base_state().get_base_velocity().getWZ();
		x = scan.get_base_state().get_base_position().get_x();
		y = scan.get_base_state().get_base_position().get_y();
		a = scan.get_base_state().get_base_position().get_base_azimuth();

		raw_x = scan.get_base_state().get_base_raw_position().get_x();
		raw_y = scan.get_base_state().get_base_raw_position().get_y();
		raw_a = scan.get_base_state().get_base_raw_position().get_base_azimuth();

		// this method return true only once and only if the trigger SAVEPOS was triggered before
		if(COMP->isSavePosTriggered() == true) {
			//TODO this should better be done in an active parameter handle!
			CommBasicObjects::CommMobileLaserScan    tmpScan;
			status = COMP->laserClient->getUpdateWait( tmpScan );
			this->savedPosX = tmpScan.get_base_state().get_base_position().get_x();
			this->savedPosY = tmpScan.get_base_state().get_base_position().get_y();
			this->savedPosA = tmpScan.get_base_state().get_base_position().get_base_azimuth();
		}

		// --------------------------------------------------------
		// cdl-loop
		// --------------------------------------------------------
		std::cout<<"[CDL-TASK] strategy: "<<local_strategy.to_string()<<std::endl;
		switch(local_strategy)
		{

		/////////////////////////////////////////////////////////////////////////////////////////
		// VELCHECK
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::VELCHECK:
		{
			//in case of velcheck and with slow laser scanners use a more recent baseState
			CommBasicObjects::CommBaseState baseState;
			status = COMP->baseStateClient->getUpdate( baseState );
			if (status != Smart::SMART_OK)
			{
				if(status == Smart::SMART_UNSUBSCRIBED)
				{
					status = COMP->baseStateClient->subscribe(1);
					std::cout << "baseStateClient was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << status << std::endl;
				} else {
					std::cout << "blocking wait status " << status << " not ok => retry ..." << std::endl;
				}
			}

			v = baseState.get_base_velocity().get_vX();
			w = baseState.get_base_velocity().getWZ();
			x = baseState.get_base_position().get_x();
			y = baseState.get_base_position().get_y();
			a = baseState.get_base_position().get_base_azimuth();

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);

			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);
			COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());


			int desiredV;
			double desiredW;
			COMP->getDesiredVelocities(desiredV,desiredW);

			std::cout<<"CDLTASK: vdes|vcur: ("<<desiredV<<" | "<<v<<") Current wdes|w: ("<<desiredW<<" | "<<w<<")"<<std::endl;

			if(desiredV == 0 && desiredW == 0){
				std::cout<<"Robot stop desired!"<<std::endl;
				COMP->cdlLookup->setDesiredTranslationalSpeed(desiredV);
				COMP->cdlLookup->setDesiredRotationalSpeed(desiredW);
				//this is done ONLY for visualization, goal info is not used!
				COMP->cdlLookup->setGoalPosition(0,0);
				COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres, wres, vaccres, waccres);
				stalledFlag = 0;
				} else {
				if(desiredV<=local_vmax && desiredV>=local_vmin &&
					desiredW<=local_wmax && desiredW>=local_wmin){

					COMP->cdlLookup->setDesiredTranslationalSpeed(desiredV);
					COMP->cdlLookup->setDesiredRotationalSpeed(desiredW);
					//this is done ONLY for visualization, goal info is not used!
					COMP->cdlLookup->setGoalPosition(0,0);

					COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres, wres, vaccres, waccres);
				if((desiredV != 0 || desiredW != 0 ) && (vres==0 && wres==0)){
					std::cout<<"[CdlTask] No valid V/W found! --> Stop "<<std::endl;
				}
			} else {
				if(desiredV == 0){
					std::cout<<"WARNING: vels exceed the maximum configured cdl values, but trans == 0!"<<std::endl;
					//if the transV == 0 then the rotV can be limited, without changing the curvature (rotation in place)!
					desiredW = std::min(desiredW,local_wmin);
					desiredW = std::max(desiredW,local_wmax);

						COMP->cdlLookup->setDesiredTranslationalSpeed(desiredV);
						COMP->cdlLookup->setDesiredRotationalSpeed(desiredW);
							COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres, wres, vaccres, waccres);
							if( (desiredV != 0 || desiredW != 0 ) && (vres==0 && wres==0) ){
							std::cout<<"[CdlTask] No valid V/W found! --> Stop "<<std::endl;
						}
					} else {
						std::cout<<"The desired vels exceed the maximum configured cdl values!--> STOP ROBOT!"<<std::endl;
						std::cout<<"Limits are: local_vmax: "<<local_vmax<<" local_vmin: "<<local_vmin<<" local_wmax: "<<local_wmax<< " local_wmin: "<<local_wmin<<std::endl;
						COMP->cdlLookup->setDesiredTranslationalSpeed(0.0);
						COMP->cdlLookup->setDesiredRotationalSpeed(0.0);
						COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres, wres, vaccres, waccres);
					}
				}
			}
			std::cout<<"--------------------------------------------------"<<std::endl;
			break;
		}

		/////////////////////////////////////////////////////////////////////////////////////////
		// PATH_NAV
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::PATH_NAV:
		{

			approachFlag = false;

			std::pair<double, double> pathFinalGoal;

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);
			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);

			double goalXRobot, goalYRobot, startXRobot, startYRobot;
			double goalXWorld, goalYWorld;

			switch(localState.getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm())
			{

				case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::PATH_NAV:
				{
					// goal specification from path-nav component
					// don't use getWait because the cycle time of the cdl process
					// is higher than the planner cycle time.
					//

					CommRobotinoObjects::CommPathNavigationGoal pathNavGoal;
					status =  COMP->pathNavigationGoalClient->getUpdate(pathNavGoal);
					if(status == Smart::SMART_OK){

						std::vector< std::pair<double, double> > pathList;
						std::vector< double > pathWidth;

						CommRobotinoObjects::CommNavigationPaths paths;
						paths = pathNavGoal.getPaths();
						pathWidth = paths.getPathWidthCopy();
						for(unsigned int i=0;i<paths.getNodesSize();i++){
							CommRobotinoObjects::CommPathNode node = paths.getNodesElemAtPos(i);
							double goalX,goalY;
							goalX = node.getX();
							goalY = node.getY();
//								std::cout<<"PathNavGoal: "<<goalX<<" "<<goalY<<std::endl;

							double goalXRobot_tmp, goalYRobot_tmp;
							transformWorldPointToRobot(x/1000.0,y/1000.0,a,goalX,goalY,goalXRobot_tmp,goalYRobot_tmp);

							pathList.push_back(std::make_pair(goalXRobot_tmp*1000.0,goalYRobot_tmp*1000.0));
						}

						if(paths.getNodesSize()>0){
							CommRobotinoObjects::CommPathNode node = paths.getNodesElemAtPos(paths.getNodesSize()-1);
							pathFinalGoal.first = node.getX()*1000;
							pathFinalGoal.second = node.getY()*1000;
						} else {
							std::cout<<"ERROR: PathNav goal invalid, this should not have happend!"<<std::endl;
						}


						std::cout<<"Path Width data: "<<std::endl;
						for(unsigned int i=0;i<pathWidth.size();++i){

						std::cout<<pathWidth[i]<<std::endl;
						}
						//TEST DATA
//							pathList.push_back(std::make_pair(-2000,0000));
//							pathList.push_back(std::make_pair(-1000,-1000));
//							pathList.push_back(std::make_pair(0000,0000));
//							pathList.push_back(std::make_pair(1000,500));

						COMP->cdlLookup->setPathNavPathList(pathList,pathWidth);


						double startX,startY;
						int startID,goalID;
						pathNavGoal.getGoal(startX,startY,startID,goalXWorld,goalYWorld,goalID,1);



						//std::cout<<"Robot pose x:"<<x/1000.0<<" y:"<<y/1000.0 <<" a:"<<a<<std::endl;
						//std::cout<<"Start x:"<<startX<<" y:"<<startY<<" Goal x:"<<goalX<<" y:"<<goalY<<" width:"<<width<<std::endl;

						transformWorldPointToRobot(x/1000.0,y/1000.0,a,goalXWorld,goalYWorld,goalXRobot,goalYRobot);
						transformWorldPointToRobot(x/1000.0,y/1000.0,a,startX,startY,startXRobot,startYRobot);

						//std::cout<<"Start in robot x: "<<startXRobot<<" y:"<<startYRobot<<" Goal in robot x: "<<goalXRobot<<" y:"<<goalYRobot<<std::endl;
						//////////////////////////////

						if(this->pathNavState == PATHNAV_ROTATE){
							// -------------------------------------------------
							// heading is given by absolute position
							// -------------------------------------------------
							COMP->cdlLookup->setGoalPosition(goalXWorld*1000.0,goalYWorld*1000.0);
							heading  = angle00(atan2(goalYWorld*1000.0-y,goalXWorld*1000.0-x)-a);
//								std::cout<<" goalX: "<<goalX*1000.0<<" x: "<<x<<" goalY: "<< goalY*1000.0<<" y: "<<y<<" a: "<<a<<std::endl;

						} else {
							COMP->cdlLookup->setPathNavGoal(startXRobot*1000.0,startYRobot*1000.0,goalXRobot*1000.0,goalYRobot*1000.0);
						}



						approachFlag = true;


					} else {
						std::cout<<"Get update: "<<status<<std::endl;
					}


					break;
				}

				default:
				{
					std::cout<<"Error Goal Mode not configured correctly!"<<std::endl;
					approachFlag = false;
					vmin         = 0.0;
					vmax         = 0.0;
					wmin         = 0.0;
					wmax         = 0.0;
					break;
				} // default

			}//switch(COMP->localState.goalSpec)

			if (approachFlag==false)
			{
				vres = 0.0;
				wres = 0.0;
			}
			else
			{


			switch (this->pathNavState) {
				case PATHNAV_INIT:
				{
					std::cout<<"PATH NAV - INIT - STATE"<<std::endl;
					stalledFlag = 0;
					pathNavState = PATHNAV_ROTATE;
					COMP->cdlLookup->setUsePathBorders(false);
					break;
				}
				case PATHNAV_ROTATE:
				{
					std::cout<<"PATH NAV - ROTATE - STATE"<<std::endl;


					// second case: heading > (-1 * COMP->localState.rotateError)
					if ((heading < local_rotateError) && (heading > (-local_rotateError) ))
					{
						// heading ok, stop turning
//							vres = 0.0;
//							wres = 0.0;
//
						stalledFlag = 0;

						// -------------------------------------------
						// switch to next state
						// -------------------------------------------
//							if(w == 0)
//							{
							std::cout<<"HEADING OK --> DRIVE"<<std::endl;
							pathNavState = PATHNAV_DRIVE;
							COMP->cdlLookup->setUsePathBorders(true);
//							}
					} else {
						COMP->cdlLookup->setRotDevSpeed(localState.getCdlRotate().getRotDev1(), localState.getCdlRotate().getRotSpeed1(),
														localState.getCdlRotate().getRotDev2(), localState.getCdlRotate().getRotSpeed2(),
														localState.getCdlRotate().getRotDev3(), localState.getCdlRotate().getRotSpeed3(),
														localState.getCdlRotate().getRotDev4(), local_wmax*180/M_PI);
						// not inside goal region
						COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());
						COMP->cdlLookup->calculateSpeedValues(v,w,x,y,a,0.0,0.0,
								local_wmin,local_wmax,
								CDL_STRATEGY_11,CDL_EVAL_STANDARD,
								vres,wres,vaccres,waccres);
						std::cout << "Heading NOT OK diff: "<<heading<<" \n";
					}



					break;
				}
				case PATHNAV_DRIVE:
				{
					std::cout<<"PATH NAV - DRIVE - STATE"<<std::endl;

					distance = sqrt((pathFinalGoal.first-x)*(pathFinalGoal.first-x)+(pathFinalGoal.second-y)*(pathFinalGoal.second-y));
					std::cout<<"PATH NAV Distance to Final Goal: "<<distance<<" approachDistance: "<<localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()<<std::endl;
					if (distance < localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance())
					{
						// goal reached, stop robot
						vres = 0.0;
						wres = 0.0;

						// this stop is intended, since the goal has been reached
						stalledFlag = 0;

						// -------------------------------------------
						// put event into object
						// -------------------------------------------
						cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
						COMP->goalEventServer->put(cdlGoalEventState);
						std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

						std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
						std::cout << "             goal   " << pathFinalGoal.first << " " << pathFinalGoal.second << "\n";

					} else  {


						double nextGoalPointDist = std::sqrt( square(goalXRobot)+square(goalYRobot));

						std::cout<<"nextGoalPointDist: "<<nextGoalPointDist<<std::endl;


						if(nextGoalPointDist<(localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance())/1000.0) {
							std::cout<<"nextGoalPointDist<"<<localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()<<" --> STOP - 0"<<std::endl;
							// sub goal reached, stop robot
							vres = 0.0;
							wres = 0.0;
							// this stop is intended, since the sub goal has been reached
							stalledFlag = 0;
							std::cout<<"SUB GOAL REACHED CDL ON WAIT!"<<std::endl;

						} else if(nextGoalPointDist<0.4){
							std::cout<<"nextGoalPointDist<0.4 --> speed down 150"<<std::endl;
							COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
							COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, 150, local_wmin, local_wmax, CDL_STRATEGY_16, evalFunction, vres, wres, vaccres, waccres);
//								std::cout << "vres = " << vres << "; wres = " << wres << std::endl;

						} else {
							//TODO
							if (trick15Flag == true)
							{
//									double trick15Diff;
//									gettimeofday(&currentTime,0);
//									trick15Diff  = (double)(currentTime.tv_usec - beginTrick15Time.tv_usec)/1000000.0;
//									trick15Diff += (double)(currentTime.tv_sec  - beginTrick15Time.tv_sec);
//									if(trick15Diff>5.0)
//									{
//										trick15Flag = false;
//										std::cout<<"END TRICK15"<<std::endl;
//
//									}

								if(trick15GoalX != goalXWorld || trick15GoalY != goalYWorld){
									trick15Flag = false;
									std::cout<<"END TRICK15"<<std::endl;
								}
							}
							if(trick15Flag == false){
								COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
								COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_16, evalFunction, vres, wres, vaccres, waccres);
							} else {
								std::cout<<"MATTHIAS TICK 15"<<std::endl;
								std::cout << "vres = " << vres << "; wres = " << wres << std::endl;
								COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
								COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_15, evalFunction, vres, wres, vaccres, waccres);
							}

							if(vres == 0.0 && wres == 0.0 && v== 0.0 && trick15Flag==false){
								std::cout<<"START TRICK15"<<std::endl;
							trick15Flag = true;
//									gettimeofday(&beginTrick15Time,0);
								//the first occurence of trick 15
								trick15GoalX = goalXWorld;
								trick15GoalY = goalYWorld;

							}
						}


					}

					break;
				} // DRIVE
				default:
				{
					std::cout<<"Error State!"<<std::endl;
					break;
				} // DEFAULT
				} //SWITCH

			}


			break;
		}

		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_ROTATE
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::ROTATE:
		{
			// ----------------------------------------------------
			// head into the given direction and report this by
			// the goal reached event
			// ----------------------------------------------------

			approachFlag = false;

			if (local_goalId == localState.getCommNavigationObjects().getCdlParameter().getID().getId())
			{

				COMP->cdlLookup->setLaserscan(scan);
				COMP->cdlLookup->setSecondLaserscan(scan2);
				COMP->cdlLookup->setIrScan(irScan);
				COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);

				switch(localState.getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm())
				{
				case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::ABSOLUTE:
				{
					// -------------------------------------------------
					// heading is given by absolute position
					// -------------------------------------------------
					COMP->cdlLookup->setGoalPosition(local_goalX,local_goalY);
					heading  = angle00(atan2(local_goalY-y,local_goalX-x)-a);
					std::cout<<" COMP->localState.goalX: "<<local_goalX<<" x: "<<x<<" COMP->localState.goalY: "<< local_goalY<<" y: "<<y<<" a: "<<a<<std::endl;
					approachFlag=true;
					break;
				}

				case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::ANGLE_ABSOLUTE:
				{
					// -------------------------------------------------
					// heading is given by angle (absolut)
					// -------------------------------------------------
					local_goalA = angle00(local_goalA);
					local_goalX = x + cos(local_goalA) * 1000.0;
					local_goalY = y + sin(local_goalA) * 1000.0;

					COMP->cdlLookup->setGoalPosition(local_goalX,local_goalY);
					heading  = angle00(atan2(local_goalY-y,local_goalX-x)-a);
					approachFlag=true;
					break;
				}

				case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::ANGLE_RELATIVE:
				{
					// -------------------------------------------------
					// heading is given by angle (relative) -- goalA
					// -------------------------------------------------
					local_goalA = angle00(local_goalA + this->savedPosA);
					local_goalX = this->savedPosX + cos(local_goalA) * 1000.0;
					local_goalY = this->savedPosY + sin(local_goalA) * 1000.0;

					COMP->cdlLookup->setGoalPosition(local_goalX,local_goalY);
					heading  = angle00(atan2(local_goalY-y,local_goalX-x)-a);
					approachFlag=true;

					std::cout<<"COMP->localState.goalA: "<<local_goalA<<" a: "<<a<<" COMP->localState.goalX: "<<local_goalX<<" x: "<<x<<" COMP->localState.goalY: "<< local_goalY<<" y: "<<y<<std::endl;
					break;
				}

				default:
				{
					std::cout<<"[CDL-TASK]: Error wrong goal mode!"<<std::endl;
					approachFlag=false;
					break;
				}
				}
			} // if (COMP->localState.goalId == COMP->localState.id)
			else {
				std::cout<<"[CDL-TASK]: WARNING invalid goalid!"<<std::endl;
			}


			if (approachFlag==false)
			{
				vres = 0.0;
				wres = 0.0;
			}
			else
			{
				// second case: heading > (-1 * COMP->localState.rotateError)
				if ((heading < local_rotateError) && (heading > (-local_rotateError) ))
				{
					// heading ok, stop turning
					vres = 0.0;
					wres = 0.0;

					stalledFlag = 0;

					std::cout << "Heading OK, stop\n";

					// -------------------------------------------
					// put event into object
					// -------------------------------------------
					//<lutz>
					if(w < 0.01)
					{
						//<lutz>
						cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
						COMP->goalEventServer->put(cdlGoalEventState);
						std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;
					}
				} else {
					COMP->cdlLookup->setRotDevSpeed(localState.getCdlRotate().getRotDev1(), localState.getCdlRotate().getRotSpeed1(),
													localState.getCdlRotate().getRotDev2(), localState.getCdlRotate().getRotSpeed2(),
													localState.getCdlRotate().getRotDev3(), localState.getCdlRotate().getRotSpeed3(),
													localState.getCdlRotate().getRotDev4(), local_wmax*180/M_PI);
					// not inside goal region
					COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());
					COMP->cdlLookup->calculateSpeedValues(v,w,x,y,a,0.0,0.0,
							local_wmin,local_wmax,
							CDL_STRATEGY_11,CDL_EVAL_STANDARD,
							vres,wres,vaccres,waccres);
					std::cout << "Heading NOT OK diff: "<<heading<<" \n";
				}
			}

			break;
		} // case CDL_ROTATE


		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_REACTIVE
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::REACTIVE:
		{
			// ----------------------------------------------------
			// drive into that direction which allows high
			// translational velocity and provides large
			// remaining travel distance
			// ----------------------------------------------------

			std::cout << "reactive \n";

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);

			COMP->cdlLookup->setHeading(0.0);
			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);
			COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());
			COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);

			COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_2, CDL_EVAL_STANDARD, vres, wres, vaccres, waccres);

			break;
		} // case CDL_REACTIVE



		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_JOYSTICK
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::JOYSTICK:
		{

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);

			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);
			COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());

			COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax,
					CDL_STRATEGY_5, CDL_EVAL_STANDARD, vres, wres, vaccres, waccres);


			break;
		} // case CDL_JOYSTICK



		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_TURN
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::TURN:
		{
			COMP->cdlLookup->setRotDevSpeed(localState.getCdlRotate().getRotDev1(), localState.getCdlRotate().getRotSpeed1(),
											localState.getCdlRotate().getRotDev2(), localState.getCdlRotate().getRotSpeed2(),
											localState.getCdlRotate().getRotDev3(), localState.getCdlRotate().getRotSpeed3(),
											localState.getCdlRotate().getRotDev4(), local_wmax*180/M_PI);
			// ----------------------------------------------------

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);

			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);
			COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());
			COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);

			COMP->cdlLookup->calculateSpeedValues( v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax,
					CDL_STRATEGY_11, CDL_EVAL_STANDARD, vres, wres, vaccres, waccres);

			break;
		}



		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_APPROACH_HALT
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::APPROACH_HALT:
		{
			approachFlag = false;

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);
			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);

			switch(localState.getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm())
			{

			case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::ABSOLUTE:
			{
				// goal specified directly in this module

				approachFlag = true;
				evalFunction = CDL_EVAL_STOPPING;
				goalX     = local_goalX;
				goalY     = local_goalY;
				COMP->cdlLookup->setGoalPosition(goalX,goalY);
				COMP->cdlLookup->setEvalStopping(3000.0,2000.0,800.0,200.0,50.0,2000.0);
				vmin = local_vmin;
				vmax = local_vmax;
				wmin = local_wmin;
				wmax = local_wmax;
				break;
			}

			case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::PLANNER:
			{
				// goal specification from planner
				// don't use getWait because the cycle time of the cdl process
				// is higher than the planner cycle time.
				//
				status =  COMP->plannerClient->getUpdate(plannerGoal);
				plannerGoal.get_goal(wayPointX,wayPointY,wayPointA,goalX,goalY,goalA,local_goalId,goalFlag);

				std::cout<<"CDL COMP->localState.id: "<<localState.getCommNavigationObjects().getCdlParameter().getID().getId()<<" goalID: "<<local_goalId<<std::endl;
				if (local_goalId != localState.getCommNavigationObjects().getCdlParameter().getID().getId())
				{
					// received not yet the actual data
					approachFlag=false;
				}
				else if (goalFlag != 0)
				{
					// currently no valid goal available
					approachFlag=false;
                                        std::cout<<"NO VALID GOAL SET"<<std::endl;
				}
				else
				{
					approachFlag=true;
					COMP->cdlLookup->setGoalPosition(wayPointX,wayPointY);
					COMP->cdlLookup->setFinalGoalPosition(goalX,goalY);
				        std::cout<<"GOAL: wayPointX: "<< wayPointX<<" wayPointY: "<< wayPointY<<std::endl;
					distance = sqrt((wayPointX-goalX)*(wayPointX-goalX)
							+(wayPointY-goalY)*(wayPointY-goalY));
					if (distance < localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance())
					{
						//std::cout<<"CDL_EVAL_STOPPING"<<endl;
						// approach final destination
						// the final goal point and the next way point are very close to
						// each other
						evalFunction = CDL_EVAL_STOPPING;
						if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
						{
							COMP->cdlLookup->setEvalStopping(2500.0,1000.0,
									500.0, 200.0,200.0,
									1500.0);
						}
						else
						{
							COMP->cdlLookup->setEvalStopping(1000.0,500.0,
									800.0, 400.0,100.0,
									1500.0);
							//COMP->cdlLookup->setEvalStopping(2500.0,1000.0,
									//                          800.0, 300.0,100.0,
									//                       1500.0);

						}
					}
					else
					{
						// approach intermediate way point
						//std::cout<<"CDL_EVAL_PASSING"<<endl;
						evalFunction = CDL_EVAL_PASSING;
						if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
						{
							COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
									500.0, 500.0,500.0,
									1500.0);
						}
						else
						{
							COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
									800.0, 600.0,600.0,
									1500.0);
							//COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
									//                         800.0, 400.0,200.0,
									//                      1500.0);
						}
					}
				}
				vmin = local_vmin;
				vmax = local_vmax;
				wmin = local_wmin;
				wmax = local_wmax;
				break;
			}

			default:
			{
				std::cout<<"Error wrong goal mode set!"<<std::endl;
				approachFlag = false;
				vmin         = 0.0;
				vmax         = 0.0;
				wmin         = 0.0;
				wmax         = 0.0;
				break;
			} // default

			}//switch(COMP->localState.goalSpec)

			if (approachFlag==false)
			{
				vres = 0.0;
				wres = 0.0;
			}
			else
			{
				distance = sqrt((goalX-x)*(goalX-x)+(goalY-y)*(goalY-y));
				std::cout<<"Distance to Goal: "<<distance<<" approachDistance: "<<localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()<<std::endl;
				if (distance < localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance())
				{
					// goal reached, stop robot
					vres = 0.0;
					wres = 0.0;

					// this stop is intended, since the goal has been reached
					stalledFlag = 0;

					// -------------------------------------------
					// put event into object
					// -------------------------------------------
					cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
					COMP->goalEventServer->put(cdlGoalEventState);
					std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

					std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
					std::cout << "             goal   " << local_goalX << " " << local_goalY << "\n";
					std::cout << "CDL COMP->localState.id: " << localState.getCommNavigationObjects().getCdlParameter().getID().getId() << " goalID: " << local_goalId << "\n";

				}
				else
				{
					//COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_6, evalFunction, vres, wres, vaccres, waccres);
					COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
//						COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_12, evalFunction, vres, wres, vaccres, waccres);
					//TODO THIS SHOULD BE SEPARATED USING PARAMETER (INI) 
					//FOR ROBOTINO AND FACTORY 4 SETTING
                                        COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_14, evalFunction, vres, wres, vaccres, waccres);
					std::cout << "vres = " << vres << "; wres = " << wres << std::endl;
					double gainDist = distance / 750.0;
					if(gainDist>1.0) gainDist=1.0;

					vres *= gainDist;
					if(vres > 20 && vres < 150) vres = 150;
					std::cout << "vres = " << vres << "; wres = " << wres << std::endl;
					std::cout << "---------------------------------------------------------------------------\n\n\n";
				}
			}

			break;
		} //case CommNavigationObjects::CdlTagType::CDL_APPROACH_HALT


		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_APPROACH_COVERAGE
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::APPROACH_COVERAGE:
		{

			approachFlag = false;

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);
			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);

			switch(localState.getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm())
			{

			case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::PLANNER:
			{
				double angle = (2 * M_PI / 180);


				// -------------------------------------------------
				// heading is given by absolute position
				// -------------------------------------------------
				//COMP->cdlLookup->setGoalPosition(COMP->localState.goalX,COMP->localState.goalY);
				//heading  = angle00(atan2(COMP->localState.goalY-y,COMP->localState.goalX-x)-a);
				//std::cout<<" COMP->localState.goalX: "<<COMP->localState.goalX<<" x: "<<x<<" COMP->localState.goalY: "<< COMP->localState.goalY<<" y: "<<y<<" a: "<<a<<std::endl;

				status =  COMP->plannerClient->getUpdate(plannerGoal);
				plannerGoal.get_goal(wayPointX,wayPointY,wayPointA,goalX,goalY,goalA,local_goalId,goalFlag);

				std::cout<<"wayPointX: "<< wayPointX<<" x: "<<x<<" wayPointY: "<< wayPointY<<" y: "<<y<<std::endl;
				std::cout<<"goalX: "<< goalX<<" x: "<<x<<" goalY: "<< goalY<<" y: "<<y<<" a: "<<a<<std::endl;

				COMP->cdlLookup->setGoalPosition(goalX, goalY);

				//distance = sqrt((wayPointX-goalX)*(wayPointX-goalX) +(wayPointY-goalY)*(wayPointY-goalY));
				//heading  = angle00(atan2(wayPointY-goalY,wayPointX-goalX)-a);

				heading  = angle00(atan2(goalY-y,goalX-x)-a);


				if (local_goalId != localState.getCommNavigationObjects().getCdlParameter().getID().getId())
				{
					// received not yet the actual data
					approachFlag=false;

					std::cout<<"received not yet the actual data !"<<std::endl;
				}
				else if (goalFlag != 0)
				{
					// currently no valid goal available
					approachFlag=false;

					std::cout<<"currently no valid goal available !"<<std::endl;
				} else {
					approachFlag=true;
				}




					//COMP->cdlLookup->setGoalPosition(COMP->localState.goalX,COMP->localState.goalY);
					//heading  = angle00(atan2(COMP->localState.goalY-y,COMP->localState.goalX-x)-a);


					// if heading is near defined angle then stop and turn
					/*if ((heading < angle + COMP->localState.rotateError) && (heading > angle + (-COMP->localState.rotateError) ))
					{
						covForwardFlag = false;
						covTurningFlag = true;

						vres = 0.0;
						wres = 0.0;
					}*/

					// if heading is greater than defined angle then stop and turn
					if(fabs(heading) > (angle + local_rotateError) && covTurningFlag == false)
					{
						covForwardFlag = false;
						covTurningFlag = true;

						vres = 0.0;
						wres = 0.0;

						std::cout<<"Turn !"<<std::endl;
					}

					if(covTurningFlag)
					//if(fabs(heading) > angle )
					{
						covForwardFlag = false;

						// if heading is near null then stop turning and drive forward
						if ((heading < local_rotateError) && (heading > (-local_rotateError) ))
						{
							// heading ok, stop turning
							vres = 0.0;
							wres = 0.0;

							stalledFlag = 0;

							covForwardFlag = true;
							covTurningFlag = false;

							std::cout << "Heading OK\n";


							// -------------------------------------------
							// put event into object
							// -------------------------------------------

							/*if(w == 0)
							{

								cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
								COMP->goalEventServer->put(cdlGoalEventState);
								std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;
							}*/
						} else {
							COMP->cdlLookup->setRotDevSpeed(localState.getCdlRotate().getRotDev1(), localState.getCdlRotate().getRotSpeed1(),
															localState.getCdlRotate().getRotDev2(), localState.getCdlRotate().getRotSpeed2(),
															localState.getCdlRotate().getRotDev3(), localState.getCdlRotate().getRotSpeed3(),
															localState.getCdlRotate().getRotDev4(), local_wmax*180/M_PI);
							// not inside goal region
							COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());
							COMP->cdlLookup->calculateSpeedValues(v,w,x,y,a,0.0,0.0,
									local_wmin,local_wmax,
									CDL_STRATEGY_11,CDL_EVAL_STANDARD,
									vres,wres,vaccres,waccres);
							std::cout << "Heading NOT OK diff: "<< heading <<" \n";

							break;
						}
					}

					if(covForwardFlag)
					{
						//status =  COMP->plannerClient->getUpdate(plannerGoal);
						//plannerGoal.get_goal(wayPointX,wayPointY,wayPointA,goalX,goalY,goalA,COMP->localState.goalId,goalFlag);

						//std::cout<<"goalX: "<< goalX<<" x: "<<x<<" goalY: "<< goalY<<" y: "<<y<<" a: "<<a<<std::endl;

						COMP->cdlLookup->setGoalPosition(wayPointX,wayPointY);

						distance = sqrt((x - wayPointX)*(x - wayPointX) +(wayPointY-y)*(wayPointY-y));
						//heading  = angle00(atan2(wayPointY-goalY,wayPointX-goalX)-a);

						//distance = sqrt((wayPointX-goalX)*(wayPointX-goalX)
						//		+(wayPointY-goalY)*(wayPointY-goalY));

						if (distance < 100.0)
						{
							//std::cout<<"CDL_EVAL_STOPPING"<<endl;
							// approach final destination
							// the final goal point and the next way point are very close to
							// each other
							evalFunction = CDL_EVAL_STOPPING;
							if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
							{
								COMP->cdlLookup->setEvalStopping(2500.0,1000.0,
										500.0, 200.0,200.0,
										1500.0);
							}
							else
							{
								COMP->cdlLookup->setEvalStopping(1000.0,500.0,
										800.0, 400.0,100.0,
										1500.0);
								//COMP->cdlLookup->setEvalStopping(2500.0,1000.0,
										//                          800.0, 300.0,100.0,
										//                       1500.0);

							}
						}
						else
						{
							// approach intermediate way point
							//std::cout<<"CDL_EVAL_PASSING"<<endl;
							evalFunction = CDL_EVAL_PASSING;
							if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
							{
								COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
										500.0, 500.0,500.0,
										1500.0);
							}
							else
							{
								COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
										800.0, 600.0,600.0,
										1500.0);
								//COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
										//                         800.0, 400.0,200.0,
										//                      1500.0);
							}
						}
					}
				//}

				/*if (approachFlag==false)
				{
					vres = 0.0;
					wres = 0.0;
				}
				else*/
				{
					distance = sqrt((goalX-x)*(goalX-x)+(goalY-y)*(goalY-y));
					std::cout<<"Distance to Goal: "<<distance<<" approachDistance: "<<localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()<<std::endl;

					if (distance < localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance())
					{
						// goal reached, stop robot
						vres = 0.0;
						wres = 0.0;

						covTurningFlag = false;
						covForwardFlag = true;

						// this stop is intended, since the goal has been reached
						stalledFlag = 0;

						// -------------------------------------------
						// put event into object
						// -------------------------------------------
						cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
						COMP->goalEventServer->put(cdlGoalEventState);
						std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

						std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
						std::cout << "             goal   " << local_goalX << " " << local_goalY << "\n";
						std::cout << "CDL COMP->localState.id: " << localState.getCommNavigationObjects().getCdlParameter().getID().getId() << " goalID: " << local_goalId << "\n";

					}
					else
					{
						COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_6, evalFunction, vres, wres, vaccres, waccres);
						COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
						//COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, COMP->localState.vmin, COMP->localState.vmax, COMP->localState.wmin, COMP->localState.wmax, CDL_STRATEGY_14, evalFunction, vres, wres, vaccres, waccres);
						std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << std::endl;
						double gainDist = distance / 750.0;
						if(gainDist>1.0) gainDist=1.0;

						vres *= gainDist;
						if(vres > 20 && vres < 150) vres = 150;
						std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << std::endl;
						std::cout << "---------------------------------------------------------------------------\n\n\n";
					}
				}

				vmin = local_vmin;
				vmax = local_vmax;
				wmin = local_wmin;
				wmax = local_wmax;

				break;
			}
			default:
			{
				approachFlag = false;
				vmin         = 0.0;
				vmax         = 0.0;
				wmin         = 0.0;
				wmax         = 0.0;
				break;
			} // default

			}//switch(COMP->localState.goalSpec)

			break;
		} //case CommNavigationObjects::CdlTagType::CDL_APPROACH_COVERAGE


		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_APPROACH
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::APPROACH:
		{
			approachFlag = false;

			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);
			COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);

			switch(localState.getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm())
			{

			case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::ABSOLUTE:
			{
				goalX = local_goalX;
				goalY = local_goalY;
				distance = sqrt((goalX-x)*(goalX-x)+
						(goalY-y)*(goalY-y));
				heading  = angle00(atan2(goalY-y,goalX-x)-a);
				approachFlag=true;
				std::cout << "Approach Goal (ABS) dist heading " << distance << " " << heading*180.0/M_PI << "\n";
				break;
			} // CommNavigationObjects::CdlTagType::CDL_ABSOLUTE


			case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::PLANNER:
			{
				// goal specification from planner
				// don't use getWait because the cycle time of the cdl process
				// is higher than the planner cycle time.
				//
				status =  COMP->plannerClient->getUpdate(plannerGoal);
				plannerGoal.get_goal(wayPointX,wayPointY,wayPointA,goalX,goalY,goalA,local_goalId,goalFlag);

				//std::cout<<"CDL COMP->localState.id: "<<COMP->localState.id<<" goalID: "<<goalId<<std::endl;
				if (local_goalId != localState.getCommNavigationObjects().getCdlParameter().getID().getId())
				{
					// received not yet the actual data
					approachFlag=false;
					std::cout << "strategy: PLANNER -- received not yet the actual data (COMP->localState.goalId != COMP->localState.id)\n";
				}
				else if (goalFlag != 0)
				{
					// currently no valid goal available
					approachFlag=false;
					std::cout << "strategy: PLANNER -- currently no valid goal available (goalFlag != 0)\n";
				}
				else
				{
					approachFlag=true;
					COMP->cdlLookup->setGoalPosition(wayPointX,wayPointY);
					distance = sqrt((wayPointX-goalX)*(wayPointX-goalX)
							+(wayPointY-goalY)*(wayPointY-goalY));

					evalFunction = CDL_EVAL_PASSING;
					if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
					{
						COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
								500.0, 500.0,500.0,
								1500.0);
					}
					else
					{
						COMP->cdlLookup->setEvalPassing(2500.0,1000.0,
								800.0, 600.0,600.0,
								1500.0);
					}
				}
				break;
			} // CommNavigationObjects::CdlTagType::CDL_PLANNER


			default:
			{
				approachFlag = false;
				break;
			} // default

			}//switch(COMP->localState.goalSpec)

			if (approachFlag==false)
			{
				vres = 0.0;
				wres = 0.0;
				std::cout << "approachFlag==false\n";
			}
			else
			{
				distance = sqrt((goalX-x)*(goalX-x)+(goalY-y)*(goalY-y));
				std::cout<<"Distance to Goal: "<<distance<<" approachDistance: "<<localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()<<std::endl;
				if (distance < localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance())
				{
					// goal reached, DO NOT STOP robot but switch to
					// reactive bahviour

					//<alexej>
					previous_strategy = TriggerHandler::SETSTRATEGYType::stratType::REACTIVE;
					//</alexej>

					// -------------------------------------------
					// put event into object
					// -------------------------------------------
					cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
					COMP->goalEventServer->put(cdlGoalEventState);
					std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

					std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
					std::cout << "             goal   " << goalX << " " << goalY << "\n";
					std::cout << "CDL COMP->localState.id: " << localState.getCommNavigationObjects().getCdlParameter().getID().getId() << " goalID: " << local_goalId << "\n";
				}
				else
				{
					COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
					COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_12, evalFunction, vres, wres, vaccres, waccres);
					//std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << std::endl;
				}
			}

			break;
		} //case CommNavigationObjects::CdlTagType::CDL_APPROACH



		/////////////////////////////////////////////////////////////////////////////////////////
		// CDL_FOLLOW
		/////////////////////////////////////////////////////////////////////////////////////////
		case TriggerHandler::SETSTRATEGYType::stratType::FOLLOW:
		{
			// ----------------------------------------------------
			// try to drive into the given direction with the
			// given translational velocity
			// ----------------------------------------------------
			COMP->cdlLookup->setLaserscan(scan);
			COMP->cdlLookup->setSecondLaserscan(scan2);
			COMP->cdlLookup->setIrScan(irScan);

			double approach_distance = localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()/1000;
			double minimum_rotation_rad = 3.0/180.0*M_PI;

	        _followDistVXControl.clear();
	        _followDistVXControl.push_back(std::make_pair( 0, 0));
	        _followDistVXControl.push_back(std::make_pair( approach_distance-0.1, 0));
	        _followDistVXControl.push_back(std::make_pair( approach_distance*1.5, local_vmax*0.8));
	        _followDistVXControl.push_back(std::make_pair( approach_distance*2, local_vmax));

	        _followDistVWControl.clear();
	        _followDistVWControl.push_back(std::make_pair( 0, 0));
	        _followDistVWControl.push_back(std::make_pair( minimum_rotation_rad, 0));
	        _followDistVWControl.push_back(std::make_pair( minimum_rotation_rad*10, local_wmax));


		COMP->trackingClient->getUpdate(trackingGoal);
			trackingGoal.get( trackAngle, trackDistance, trackX, trackY, trackFlag);
			unsigned long int currentGoalCounter = trackingGoal.getGoalCount();

			std::cout<<"CurrentGoalCounter: "<<currentGoalCounter<<" old: "<< old_counter<<std::endl;

			// If goal is still the same (because of different cycle rates) or if tracking goal was lost and the previous is used now ...
			if(firstPass == false){

				if(trackFlag == false)
				{
					// Tracking goal lost -> trackX / trackY = 0/0, therefore use previous tracking goal
					std::cout<<"============== PERSON LOST -> old GOAL!"<<std::endl;
					trackX = previous_trackX;
					trackY = previous_trackY;
				}

				if (currentGoalCounter == old_counter || trackFlag==false) {
					// ... Then transform goal point (trackX, trackY) depending on the robot motion since the last cycle

					CommBasicObjects::CommBasePose basePosition = scan.get_base_state().get_base_raw_position();

					arma::mat res_t(3,1);
					arma::mat res_r(3,3);

					arma::mat a_t(3,1);
					a_t(0,0) = basePosition.get_x(1);
					a_t(1,0) = basePosition.get_y(1);
					a_t(2,0) = 0;
					arma::mat a_r(3,3);
					EulerTransformationMatrices::create_zyx_matrix(basePosition.getPose3D().get_orientation().getAzimuth(),0,0,a_r);

					arma::mat b_t(3,1);
					b_t(0,0) = basePosePrevious.get_x(1);
					b_t(1,0) = basePosePrevious.get_y(1);
					b_t(2,0) = 0;
					arma::mat b_r(3,3);
					EulerTransformationMatrices::create_zyx_matrix(basePosePrevious.getPose3D().get_orientation().getAzimuth(),0,0,b_r);

					inverseComposeFrom(b_t,b_r, a_t, a_r, res_t,res_r);


					double yaw, pitch, roll;
					EulerTransformationMatrices::zyx_from_matrix(res_r, yaw, pitch, roll);
					double t_alpha = yaw;

					double t_x = res_t(0,0);
					double t_y = res_t(1,0);

//						std::cout<<"Pose Diff - x:"<<t_x<<" y:"<<t_y<<" t_alpha:"<<t_alpha<<std::endl;


					arma::mat trans(3,3);
					trans(0,0) = cos(t_alpha);
					trans(0,1) = -sin(t_alpha);
					trans(0,2) = t_x;

					trans(1,0) = sin(t_alpha);
					trans(1,1) = cos(t_alpha);
					trans(1,2) = t_y;

					trans(2,0) = 0;
					trans(2,1) = 0;
					trans(2,2) = 1;

					arma::mat trans_i(3,3);
					trans_i = inv(trans);

					arma::mat point(1,3);
					point(0,0) = trackX;
					point(0,1) = trackY;
					point(0,2) = 1;

					point = arma::trans(trans_i * (arma::trans(point)));

					trackX = point(0,0);
					trackY = point(0,1);

//						std::cout<<"Track: X:"<<trackX<<" Y:"<<trackY<<std::endl;

					//show_px_color(trackX, trackY, CV_RGB(0, 0, 255)); // gerasterte alte untransformiert
					//show_px_color(point(0,0), point(0,1), CV_RGB(255, 0, 255)); // alte transformiert = ungerastert/kontinuierliche werte
					trackFlag = true;
				} else {
//						std::cout<<"New Goal!"<<std::endl;
//						std::cout<<"NG: ("<<trackX<<"|"<<trackY<<")"<<std::endl;
				}
			} else {
				std::cout<<"CDLTask - FOLLOW - First run!"<<std::endl;
			}


			old_counter = trackingGoal.getGoalCount();
			basePosePrevious = scan.get_base_state().get_base_raw_position();
			previous_trackX = trackX;
			previous_trackY = trackY;

			CommTrackingObjects::TrackingGoalType tackingGoalType = trackingGoal.getTrackingType();


			if(tackingGoalType == CommTrackingObjects::TrackingGoalType::XY_MAP_RAW){
				trackAngle = angle00(atan2( trackY - raw_y,  trackX- raw_x) - raw_a);
				trackDistance = sqrt( (raw_x-trackX)*(raw_x-trackX) + (raw_y-trackY)*(raw_y-trackY) );
			}else if(tackingGoalType == CommTrackingObjects::TrackingGoalType::XY_MAP){
				trackAngle = angle00(atan2( trackY - y,  trackX- x) - a);
				trackDistance = sqrt( (x-trackX)*(x-trackX) + (y-trackY)*(y-trackY) );
			} else if(tackingGoalType == CommTrackingObjects::TrackingGoalType::XY_ROBOT){
				trackAngle = angle00(atan2( trackY,  trackX));
				trackDistance = sqrt( (trackX)*(trackX) + (trackY)*(trackY) );
			} else if(tackingGoalType == CommTrackingObjects::TrackingGoalType::ANGLE_DIST){
				//trackAngle = trackAngle;
				//trackDistance = trackDistance;
			} else {
				std::cout<<"ERROR invalid tracking goal type set: "<<tackingGoalType<<std::endl;
				trackFlag = false;
			}


			if (trackFlag == false || trackDistance >5.0 )
			{
				// no valid goal information from track server
				std::cout << "no valid goal information; trackDistance: "<<trackDistance<<std::endl;
				COMP->cdlLookup->setHeading(0.0);
				COMP->cdlLookup->setMaxDistance(0.0);
				COMP->cdlLookup->setDesiredTranslationalSpeed(0.0);
				COMP->cdlLookup->calculateSpeedValues(v,w,0.0,0.0,0.0,local_vmin,local_vmax,local_wmin,local_wmax,CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres,wres,vaccres,waccres);
				stalledFlag = 0;

			}
			else
			{

				if( trackDistance < approach_distance && fabs(trackAngle-w) < (minimum_rotation_rad)   )
				{

					std::cout<<"Goal Reached! --> STOP!"<<std::endl;
					COMP->cdlLookup->setHeading(0.0);
					COMP->cdlLookup->setMaxDistance(0.0);
					COMP->cdlLookup->setDesiredTranslationalSpeed(0.0);
					COMP->cdlLookup->calculateSpeedValues(v,w,0.0,0.0,0.0,local_vmin,local_vmax,local_wmin,local_wmax,CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres,wres,vaccres,waccres);

					// this stop is intended, since the goal has been reached
					stalledFlag = 0;
				}
				else
				{

					//this is used to draw the goal into the vis ONLY since CDL_STRATEGY_7 is used!!
					COMP->cdlLookup->setGoalPosition(trackX*1000,trackY*1000);

					COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);
					double desWTrans = linearinterpolation(_followDistVWControl, fabs(trackAngle));
					if(trackAngle<0){
						desWTrans = desWTrans*-1.0;
					}
					COMP->cdlLookup->setDesiredRotationalSpeed(desWTrans);
					COMP->cdlLookup->setHeading(desWTrans);
					COMP->cdlLookup->setMaxDistance(COMP->cdlLookup->getCDL_MAX_DISTANCE());
					double desTrans = linearinterpolation(_followDistVXControl, trackDistance);
					COMP->cdlLookup->setDesiredTranslationalSpeed(desTrans);
					std::cout << "Track x: " << trackX << "; y: " << trackY << "; Angle: " << ((trackAngle*180.0)/M_PI) <<"; desWTrans: "<<desWTrans<< "; dist: " << trackDistance << "  desTrans: "<<desTrans << "; flag: " << trackFlag << "\n";

					if(trackDistance > 2.4){
						COMP->cdlLookup->calculateSpeedValues(v,w,0.0,0.0,0.0,local_vmin,local_vmax,local_wmin,local_wmax,CDL_STRATEGY_1,CDL_EVAL_STANDARD,vres,wres,vaccres,waccres);
					} else {
						COMP->cdlLookup->calculateSpeedValues(v,w,0.0,0.0,0.0,local_vmin,local_vmax,local_wmin,local_wmax,CDL_STRATEGY_7,CDL_EVAL_STANDARD,vres,wres,vaccres,waccres);
					}
//						std::cout << "Res Speed: ("<<vres<<"|"<<wres<<")"<<std::endl;

				}

			}

			firstPass = false;

			break; //case follow
			}


			/////////////////////////////////////////////////////////////////////////////////////////
			// CDL_APPROACH_FLAT_SURF
			/////////////////////////////////////////////////////////////////////////////////////////
			case TriggerHandler::SETSTRATEGYType::stratType::APPROACH_FLAT_SURF:
			{


				// this stop is intended, since the goal has been reached
				stalledFlag = 0;
				COMP->cdlLookup->setLaserscan(scan);
				COMP->cdlLookup->setSecondLaserscan(scan2);
				COMP->cdlLookup->setIrScan(irScan);
				COMP->cdlLookup->setParameterRobot(local_tcalc,local_transAcc,local_rotAcc);


				evalFunction = CDL_EVAL_STOPPING;
				COMP->cdlLookup->setEvalStopping(3000.0,2000.0,800.0,200.0,50.0,2000.0);
				vmin = local_vmin;
				vmax = local_vmax;
				wmin = local_wmin;
				wmax = local_wmax;


				if(COMP->getCounter() > 12) //samples
				{
					// goal reached, stop robot
					vres = 0.0;
					wres = 0.0;

					// -------------------------------------------
					// put event into object
					// -------------------------------------------
					cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
					COMP->goalEventServer->put(cdlGoalEventState);
					std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;
				}
				else
				{
					COMP->cdlLookup->setDesiredTranslationalSpeed(local_vmax);
					COMP->cdlLookup->calculateSpeedValues(v, w, x, y, a, local_vmin, local_vmax, local_wmin, local_wmax, CDL_STRATEGY_13, evalFunction, vres, wres, vaccres, waccres);

					if(vres==0)
					{
						COMP->incrementCounter();
					}
					else
					{
						COMP->resetCounter();
					}

					//std::cout << "vres = " << vres << "; wres = " << wres/M_PI*180.0 << "count: "<<COMP->globalState.count<<std::endl;
					//std::cout << "---------------------------------------------------------------------------\n\n\n";
				}

				break;
			} //case CommNavigationObjects::CdlTagType::CDL_APPROACH_FLAT_SURF



			/////////////////////////////////////////////////////////////////////////////////////////
			// CDL_BACKWARD
			/////////////////////////////////////////////////////////////////////////////////////////

			case TriggerHandler::SETSTRATEGYType::stratType::BACKWARD:
			{
				// ----------------------------------------------------
				// move straight back until distance to goal point is
				// big enough
				//
				// that behavior is in some sense stupid as NO correct
				// CDL takes place !!! The robot just drives backwards
				// towards the specified goal point and stops as soon
				// as the goal circle is reached.
				//    CDL_SAVED
				// ----------------------------------------------------
				approachFlag = false;

				if (local_goalId == localState.getCommNavigationObjects().getCdlParameter().getID().getId())
				{
					switch(localState.getCommNavigationObjects().getCdlParameter().getGOALMODE().getGm())
					{
					case ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::GOALMODEType::gmType::SAVED:
					{
						// -------------------------------------------------
						// heading is given by absolute position
						// -------------------------------------------------
						distance = sqrt((this->savedPosX-x)*(this->savedPosX-x)
								+(this->savedPosY-y)*(this->savedPosY-y));
						if (distance < localState.getCommNavigationObjects().getCdlParameter().getAPPROACHDIST().getApproachDistance()) {
							approachFlag = true;
							vres = -150.0;
							wres =    0.0;
						}
						else
						{
							approachFlag = false;
							stalledFlag = 0;
							// -------------------------------------------
							// put event into object
							// -------------------------------------------
							cdlGoalEventState.set(CommNavigationObjects::CdlGoalEventType::CDL_GOAL_REACHED);
							COMP->goalEventServer->put(cdlGoalEventState);
							std::cout<<"CDL EVENT CDL_GOAL_REACHED FIRED!"<<std::endl;

							std::cout << "GOAL REACHED !!!!!!!! actpos " << x << " " << y << " " << a*180.0/M_PI << "\n";
							std::cout << "             goal   " << local_goalX << " " << local_goalY << "\n";
						}
						break;
					}

					default:
					{
						approachFlag=false;
						break;
					}
					} // switch(COMP->localState.goalSpec)
				} // if (COMP->localState.goalId == COMP->localState.id)

				if (approachFlag==false)
				{
					vres = 0.0;
					wres = 0.0;
				}
				break;
		}



		/////////////////////////////////////////////////////////////////////////////////////////
		// default -> no strategy selected
		/////////////////////////////////////////////////////////////////////////////////////////
		default:
		{
			break;
		} // case default

		} // switch(COMP->localState.strategy)

		// ----------------------------------------------------------
		// now send commands directly to the base
		// ----------------------------------------------------------

		// TODO this is for backward driving with Joystick -> can surely be done better !!
		/*double speed = COMP->cdlLookup->getDesiredTranslationalSpeed();
		if( COMP->localState.strategy == CommNavigationObjects::CdlTagType::CDL_JOYSTICK && speed <= 0 )
		{
			if( speed < COMP->localState.vmin ) speed = COMP->localState.vmin;
			vel.set_v(speed, 0.001);
			double wspeed = COMP->cdlLookup->getHeading();
			if( wspeed < -20.0 ) wspeed = -20.0;
			if( wspeed >  20.0 ) wspeed =  20.0;
			vel.set_omega( wspeed );
		}
		else*/

		if(local_strategy == TriggerHandler::SETSTRATEGYType::stratType::PATH_NAV
				&& localState.getCommNavigationObjects().getCdlParameter().getPATHNAVFREEBEHAVIOR().getFree() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::PATHNAVFREEBEHAVIORType::freeType::ACTIVATE){

			double vX, vY, vW;
			bool done;
			std::cout<<"use Recover"<<std::endl;
			if(COMP->cdlLookup->pathNavRecoverRobotToPathCenter(vX,vY,vW,done) != 0)
			{
				//TODO may be that we need an separate event for that case!?
//					CommNavigationObjects::CommCdlRobotBlockedState robotBlockedState;
//					robotBlockedState.setNewState(CommNavigationObjects::CdlRobotBlockEventType::CDL_ROBOT_BLOCKED);
//					COMP->robotBlockedEventServer->put(robotBlockedState);

			} else {
				vel.set_vX(vX, 0.001);
				vel.set_vY(vY, 0.001);
				vel.set_omega(vW);
				if(done == true){
					//fire event for unblocked!
//						CommNavigationObjects::CommCdlRobotBlockedState robotBlockedState;
//						robotBlockedState.setNewState(CommNavigationObjects::CdlRobotBlockEventType::CDL_ROBOT_UNBLOCKED_PATH);
//						COMP->robotBlockedEventServer->put(robotBlockedState);
				}
			}
		} else
		{
			// normal cdl case (no speed in y direction)
			vel.set_vY(0,0);
			//
			vel.set_vX(vres, 0.001);
			vel.set_omega(wres);
		}

//			//DEBUG
//			vel.setVX(0);
//			vel.setVY(0);
//			vel.set_omega(0);
//			//END

		COMP->navVelSendClient->send(vel);
		std::cout << "send " << vel << " status: "<< status<<std::endl;


		// -----------------------------------------------------------
		// now check whether stalled behaviour occured
		// -----------------------------------------------------------
		if ((vel.getVX() == 0.0) && (vel.getVY() == 0.0) && (vel.getOmega() == 0.0) && (v == 0.0) && (w == 0.0) && approachFlag == true)
		{
			// robot stops and cannot move anymore
			if (stalledFlag == 0)
			{
				std::cout<<"Robot is stalled first time"<<std::endl;
				// first occurence of stalling situation
				stalledFlag = 1;
				::gettimeofday(&beginStalledTime,0);
			}
			else
			{
				// not the first occurence of stalling situation
				::gettimeofday(&currentTime,0);
				timeDiff  = (double)(currentTime.tv_usec - beginStalledTime.tv_usec)/1000000.0;
				timeDiff += (double)(currentTime.tv_sec  - beginStalledTime.tv_sec);

				std::cout<<"Robot is stalled n times, timediff: "<<timeDiff<<std::endl;
				if (timeDiff > localState.getPathNav().getRobotBlocked_event_timeout()){ //2.0
					stalledFlag = 0;
					std::cout<<"Robot is Blocked"<<std::endl;
					CommNavigationObjects::CommCdlRobotBlockedState robotBlockedState;
					if(COMP->cdlLookup->pathNavCheckIFRobotIsInCollisionWithPathBorder() == true)
					{
						robotBlockedState.setNewState(CommNavigationObjects::CdlRobotBlockEventType::CDL_ROBOT_BLOCKED_PATH);
					} else {
						robotBlockedState.setNewState(CommNavigationObjects::CdlRobotBlockEventType::CDL_ROBOT_BLOCKED);
					}
					COMP->robotBlockedEventServer->put(robotBlockedState);
				}

				if (localState.getCommNavigationObjects().getCdlParameter().getFREEBEHAVIOR().getFree() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::FREEBEHAVIORType::freeType::ACTIVATE)
				{
					// if (timeDiff > 2.0)
					if (timeDiff > 0.5)
					{
						stalledFlag = 0;
						if (localState.getCommNavigationObjects().getCdlParameter().getLOOKUPTABLE().getLt() == ParameterStateStruct::CommNavigationObjectsType::CdlParameterType::LOOKUPTABLEType::ltType::SECOND)
						{
							//status = COMP->cdlLookup->freeBehavior(700.0,turnDirection);
							COMP->cdlLookup->freeBehavior(localState.getCdl().getFreeBehaviorDist(),turnDirection);
						}
						else
						{
							//status = COMP->cdlLookup->freeBehavior(500.0,turnDirection);
							COMP->cdlLookup->freeBehavior(localState.getCdl().getFreeBehaviorDist_second(),turnDirection);
						}

						static int lastTurn = 1;

						switch (turnDirection)
						{
						case CDL_FREE_TURN_LEFT:
						{
							std::cout << "STALLED ==> turn left\n";
							wres = 20.0*M_PI/180.0;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							sleep(1);
							//smartBase.setVelocities(0.0,0.0);
							wres = 0.0;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							lastTurn = 1;
							break;
						}

						case CDL_FREE_TURN_RIGHT:
						{
							std::cout << "STALLED ==> turn right\n";
							wres = -20.0*M_PI/180.0;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							sleep(1);
							wres = 0.0;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							lastTurn = -1;
							break;
						}

						case CDL_FREE_NO_TURN:
						{
							//cout << "STALLED ==> no chance to free robot\n";
							std::cout << "STALLED ==> free no turn ?!\n";
							wres = 20.0*M_PI/180.0 * lastTurn;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							sleep(1);
							wres = 0.0;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							break;
						}

						case CDL_FREE_BOTH:
						{
							std::cout << "STALLED ==> both free ?!\n";
							wres = 20.0*M_PI/180.0 * lastTurn;
							vres = 0.0;
							//wres = 0.0;
							//vres = -30.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							sleep(1);
							wres = 0.0;
							vres = 0.0;
							vel.set_vX(vres, 0.001);
							vel.set_vY(0,0);
							vel.set_omega(wres);
							COMP->navVelSendClient->send(vel);
							break;
						}
						} // switch(turnDirection)
					} // if (timeDiff > 2.0)
				} // if (COMP->localState.freeBehavior == CDL_FREE_BEHAVIOR)
			} // if (stalledFlag == 0)
		} // if ((vres == 0.0) && (wres == 0.0) && (v == 0.0) && (w == 0.0))
		else {
			//robot is not blocked --> check if blocked before --> send unblock event
			if (stalledFlag == 1)
			{
				stalledFlag = 0;
				std::cout<<"Robot is no more blocked!"<<std::endl;

				CommNavigationObjects::CommCdlRobotBlockedState robotBlockedState;
				robotBlockedState.setNewState(CommNavigationObjects::CdlRobotBlockEventType::CDL_ROBOT_NOT_BLOCKED);
				COMP->robotBlockedEventServer->put(robotBlockedState);
			}
		}
	} // if (status != Smart::SMART_OK) <<<---- status = laserClient->getUpdate( scan );

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int CdlTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

void CdlTask::initPathNav(){
	pathNavState = PATHNAV_INIT;
}

void CdlTask::resetRobotStalledFlag(){
	stalledFlag = 0;
}

// does semantically the same as MRPT's inverseComposeFrom().
void CdlTask::inverseComposeFrom(arma::mat b_t, arma::mat b_r, arma::mat a_t, arma::mat a_r, arma::mat& out_t, arma::mat& out_r)
{

  out_r.fill(0);
  out_t.fill(0);

  arma::mat R_b_inv(3,3);
  arma::mat t_b_inv(3,1);

  const double tx = -b_t(0,0);
  const double ty = -b_t(1,0);
  const double tz = -b_t(2,0);

  t_b_inv(0,0) = tx*b_r(0,0)+ty*b_r(1,0)+tz*b_r(2,0);
  t_b_inv(1,0) = tx*b_r(0,1)+ty*b_r(1,1)+tz*b_r(2,1);
  t_b_inv(2,0) = tx*b_r(0,2)+ty*b_r(1,2)+tz*b_r(2,2);

  // 3x3 rotation part: transpose
  //out_R = b_r.adjoint();
  R_b_inv = arma::trans(b_r);

  arma::mat m_coords(3,1);
  arma::mat m_ROT(3,3);

  for (int i=0;i<3;i++)
    out_t(i,0) = t_b_inv(i,0) + R_b_inv(i,0)*a_t(0,0)+ R_b_inv(i,1)*a_t(1,0)+ R_b_inv(i,2)*a_t(2,0);

  // Rot part:
  out_r = R_b_inv * a_r;
}
