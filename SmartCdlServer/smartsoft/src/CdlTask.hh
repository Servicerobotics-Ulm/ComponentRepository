//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft CDL component".
//  It provides navigation services based on the CDL
//  Curvature Distance Lookup approach.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//

// --------------------------------------------------------------------------
//TODO cdt plugin bug (needs include before include guards)
#include <vector>

#ifndef _CDLTASK_HH
#define _CDLTASK_HH

#include "CdlTaskCore.hh"
#include "smartCdlDefine.h"


#include "ParameterStateStruct.hh"
#include "TriggerHandler.hh"

	
class CdlTask  : public CdlTaskCore
{
private:
	CommBasicObjects::CommMobileLaserScan    scan;
	CommBasicObjects::CommMobileLaserScan    scan2;
	CommBasicObjects::CommMobileIRScan	irScan;
	CommBasicObjects::CommNavigationVelocity vel;
	Smart::StatusCode               status;

	CommNavigationObjects::CommPlannerGoal        plannerGoal;
	double v,w,vres,wres,vaccres,waccres;
	double vmin,vmax,wmin,wmax;
	double distance,heading;//,transSpeed;
	//double visionSpeed,visionAngle,visionDistance;
	double x, y, a; //z;
	double raw_x, raw_y, raw_a; // raw_z;
	//double alpha1,alpha2,alpha3;
	double goalX,goalY,goalA;
	double wayPointX,wayPointY,wayPointA;
	//long   goalId;

	double trackAngle,trackDistance,trackX,trackY;//,trackA;
	bool trackFlag;
	bool approachFlag;
	CdlEvalFunctionType evalFunction;
	long goalFlag;

	//static int scannumber=0;

	struct timeval beginTrick15Time;
	bool trick15Flag;
	double trick15GoalX,trick15GoalY;

	struct timeval beginStalledTime;
	struct timeval currentTime;
	int            stalledFlag;       // 0 not stalled, 1 stalled
	double         timeDiff;
	int            turnDirection;

	CommTrackingObjects::CommTrackingGoal trackingGoal;
	CommNavigationObjects::CdlGoalEventState cdlGoalEventState;

	bool covForwardFlag;
	bool covTurningFlag;


	double savedPosX;                // position from which backward manoeuver starts
	double savedPosY;
	double savedPosA;

	TriggerHandler::SETSTRATEGYType::stratType previous_strategy;
	//</alexej>

	enum PathNavState {
		PATHNAV_INIT = 0,
		PATHNAV_ROTATE = 1,
		PATHNAV_DRIVE = 2,
	} pathNavState;

	 template<class T>
		  inline T square(const T x)    { return x*x; }

	double previous_trackX, previous_trackY;

	uint64_t old_counter;
	CommBasicObjects::CommBasePose basePosePrevious;
	bool firstPass;

	std::vector<std::pair<double, double> > _followDistVXControl;
	std::vector<std::pair<double, double> > _followDistVWControl;

	void inverseComposeFrom(arma::mat b_t, arma::mat b_r, arma::mat a_t, arma::mat a_r, arma::mat& out_t, arma::mat& out_r);


	virtual void on_LaserClient(const CommBasicObjects::CommMobileLaserScan &input);
	virtual void on_PlannerClient(const CommNavigationObjects::CommPlannerGoal &input);
	virtual void on_NavVelSendServer(const CommBasicObjects::CommNavigationVelocity &input);
	virtual void on_TrackingClient(const CommTrackingObjects::CommTrackingGoal &input);
	virtual void on_LaserClient2(const CommBasicObjects::CommMobileLaserScan &input);
	virtual void on_IRClient(const CommBasicObjects::CommMobileIRScan &input);
	virtual void on_PathNavigationGoalClient(const CommRobotinoObjects::CommPathNavigationGoal &input);
	virtual void on_BaseStateClient(const CommBasicObjects::CommBaseState &input);

public:
	CdlTask(SmartACE::SmartComponent *comp);
	virtual ~CdlTask();
	
	virtual int on_entry();
	virtual int on_execute();
	virtual int on_exit();

	void initPathNav();

	void resetRobotStalledFlag();
	double linearinterpolation(const std::vector<std::pair<double, double> >& vec, const double x );
};

#endif
