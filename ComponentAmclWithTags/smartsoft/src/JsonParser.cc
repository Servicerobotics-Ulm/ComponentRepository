//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2020 Nayabrasul Shaik
//
//        christian.schlegel@thu.de
//        nayabrasul.shaik@thu.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//  This work is based on previous work by the folks from PlayerStage.
//
//--------------------------------------------------------------------------
#include <JsonParser.hh>

#include <iostream>
JsonParser::JsonParser(std::string json_file_name) : input_stream(json_file_name){
	json_string.reserve(2000); //~2k
	json_string.assign((std::istreambuf_iterator<char>(input_stream)),(std::istreambuf_iterator<char>()));
	is_parsed = false;
}

JsonParser::~JsonParser() {
	// TODO Auto-generated destructor stub
}

std::vector<CommTrackingObjects::CommDetectedMarker> JsonParser::get_markers_info() {
	JSONNode node = libjson::parse(json_string);
	if(!is_parsed)
	{
	ParseJSON(node);
	is_parsed = true;
	}
	return marker_list;
}

void JsonParser::ParseJSON(const JSONNode & n){
	JSONNode::const_iterator i = n.begin();
	while (i != n.end()){

		std::string node_name = i -> name();
		if(i->type() == JSON_ARRAY)
		{
			//if (node_name == "tags"){
			ParseJSON(*i);
		}else if (node_name == "info" || node_name == "units"){
			//skip
		} else {

			CommTrackingObjects::CommDetectedMarker current_marker;
			CommBasicObjects::CommPose3d pose;

			std::string node_name = i -> name();
			current_marker.setId(i->at(0).as_int());

			pose.set_x(i->at(1).as_float() * 1000);
			pose.set_y(i->at(2).as_float() * 1000);
			pose.set_z(i->at(3).as_float() * 1000);

			pose.set_azimuth(i->at(4).as_float());
			pose.set_elevation(i->at(5).as_float());
			pose.set_roll(i->at(6).as_float());

			current_marker.setPose(pose);
			//pose.to_ostream(std::cout);
			marker_list.push_back(current_marker);
		}
		//increment the iterator
		++i;
	}
}
