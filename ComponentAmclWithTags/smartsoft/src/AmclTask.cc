//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        lutz@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//  This work is based on previous work by the folks from PlayerStage.
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the amcl algorithm was taken from the
// Playerstage Project, which is distributed under GPL, and you can find at
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------


#include "AmclTask.hh"
#include "ComponentAmclWithTags.hh"

#include <iostream>
#include <fstream>
#include <chrono>
#include <cmath>
// We use SDL_image to load the image from disk
#ifdef WITH_OPENCV_4_2_VERSION
#include <opencv4/opencv2/highgui.hpp>
#include <opencv4/opencv2/core.hpp>
#include <Eigen/Dense>
#else
#include <cxcore.h>
#include <highgui.h>
#endif
#include "EulerTransformationMatrices.hh" // from utility
AmclTask::AmclTask(SmartACE::SmartComponent *comp) 
:	AmclTaskCore(comp)
{
	std::cout << "constructor AmclTask\n";
	COMP->pf_init_ = false;
	ready_for_tag_update_ = false;

}
AmclTask::~AmclTask() 
{
	std::cout << "destructor AmclTask\n";
	COMP->pf_init_ = false;
	map_free(COMP->map_);
	pf_free(COMP->pf_);

	delete COMP->laser_;
	delete COMP->odom_;
	delete COMP->visual_tag_;

}

int AmclTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	std::cout << "YAML file : " << COMP->getGlobalState().getGeneral().getYaml_file() <<std::endl;
	if(0!=init(COMP->getGlobalState().getGeneral().getYaml_file())){
		std::cout<<"ERROR opening default map!"<<std::endl;
		//std::cout<<"Retry..."<<std::endl;
		//usleep(1000000);
		return 0;
	}

	if(COMP->getGlobalState().getGeneral().getEnable_visualization() == true){
		COMP->h.displayMap(COMP->map_);
		COMP->h.initObjects();
	}

	COMP->sensor_to_use = get_sensors_to_use(COMP->getGlobalState().getGeneral().getSensors_to_use());

	return 0;
}
int AmclTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	tag_data_recieved_   = false; //flag to indicate if tags data is available
	laser_data_recieved_ = false; //flag to indicate if laser data is available
	bool moved_enough_for_sensor_update_ = false; //flag to check if the robot traveled enough to consider sensor update
	bool laser_update_ = false; // flag to indicate if to do laser sensor update or not
	bool tag_update_   = false; // flag to indicate if to do visual tag sensor update or not
	bool is_kidnapped  = false; // flag to indicate whether robot is kidnapped or not

	if(COMP->amcl_init == false){
		std::cout<<"[AmclTask] filter not initialized --> skip execution sleep(1)"<<std::endl;
		ACE_OS::sleep(ACE_Time_Value(1,0));
		return 0;
	}

	// receive new data
	CommBasicObjects::CommMobileLaserScan scan;
	CommTrackingObjects::CommDetectedMarkerList dml;

	receive_sensor_data(scan, dml);
	//std::cout<<"[AmclTask] laser_data_recieved_ = "<<laser_data_recieved_
	//		 <<" , tag_data_recieved_ = " <<tag_data_recieved_<<std::endl;

	///////////////////////////////////////////
	// check if the sensor plane is parallel to the x-y plane of the base
	//called only once
	std::call_once(check_laser_mounting, [&]{get_laser_mounting(scan, isPlanar, isPlanarFliped);});

	if (!isPlanar && ! isPlanarFliped)
	{
		std::cerr << "\033[0;31m" << "ERROR - LASER IS NOT PLANAR -- " << scan.get_sensor_pose() << "\n\033[0m";
		usleep(500000);
	}


	if(laser_data_recieved_ && (COMP->getGlobalState().getGeneral().getEnable_visualization() == true)){
		COMP->h.displayBase(scan.get_base_state().get_base_position());
		COMP->h.displayLaserScan(scan);
	}

	{
		SmartACE::SmartRecursiveGuard pfGuard(COMP->PFMutex);
		pf_vector_t pose;
		pf_vector_t raw_pose;
		pf_vector_t delta = pf_vector_zero();
		CommBasicObjects::CommBasePose previous_base_pose;

		get_odometry_and_prevous_pose(scan, dml, raw_pose, pose, previous_base_pose);

		////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////

		if (COMP->pf_init_) {
			// Compute change in pose
			delta = raw_pose - pf_odom_pose_;

			// See if we should update the filter
			moved_enough_for_sensor_update_ = fabs(delta.v[0]) > COMP->getGlobalState().getFilter().getUpdate_min_d() ||
					fabs(delta.v[1]) > COMP->getGlobalState().getFilter().getUpdate_min_d() ||
					fabs(delta.v[2]) > COMP->getGlobalState().getFilter().getUpdate_min_alpha();


			if(moved_enough_for_sensor_update_ && laser_data_recieved_)
			{
				laser_update_ =  true;
			}

			if(moved_enough_for_sensor_update_) // moved enough but we might have not seen tags in the current cycle
			{
				ready_for_tag_update_ = true;
			}

			if(ready_for_tag_update_ && tag_data_recieved_)
			{
				//tag update only when
				//1. either number of clusters is more
				//2. or sum of Eigen values id more
				//tag_update_ = (1 || 2)

				tag_update_ =(COMP->pf_->sets[COMP->pf_->current_set].cluster_count > COMP->getGlobalState().getGeneral().getLostEventMaxHypothese())
								                    ||((max_hypo_clusters_eigens_sum) > COMP->getGlobalState().getGeneral().getLostEventMaxEigValueSum());

				ready_for_tag_update_ = false;
			}

			if(tag_data_recieved_) // check if the robot is kidnapped
			{
				//std::cout << __LINE__ <<std::endl;
				is_kidnapped = is_robot_kidnapped(scan, dml);
				is_kidnapped = false;

			}

			if(COMP->getGlobalState().getGeneral().getVerbose() == true){
				std::cout<<"[AmclTask::on_execute()] Scan points: "<<scan.get_scan_size()<<std::endl;
				std::cout<<"[AmclTask::on_execute()] Scan max points : "<<scan.get_max_scan_size()<<std::endl;
				std::cout<<"[AmclTask::on_execute()] Scan res: "<<scan.get_scan_resolution()<<std::endl;

				std::cout<<std::setw(20)<<" pf_odom_pose_: "<< pf_odom_pose_<<std::endl;
				std::cout<<std::setw(20)<<" raw_pose     : "<< raw_pose<<std::endl;
				std::cout<<std::setw(20)<<" delta        : "<< delta<<std::endl;
				if(laser_update_ == true){
					std::cout<<"Above delta --> update filter!"<<std::endl;
				} else {
					std::cout<<"Below delta"<<std::endl;
				}
			}
		}

		bool force_publication = false;
		if (!COMP->pf_init_) {
			// Pose at last filter update
			pf_odom_pose_ = raw_pose;
			std::cout<<"Init pf_odom_pose_: "<< pf_odom_pose_<<std::endl;

			// Filter is now initialized
			COMP->pf_init_ = true;

			//laser_update_ = true;
			force_publication = true;
			resample_count_ = 0;
			ready_for_tag_update_ = true; // sensor update with first tag detected after pf is initialized
		}

		// If the robot has moved, update the filter
		// update also when robot is kidnapped
		else if (COMP->pf_init_ && (laser_update_ || tag_update_ || is_kidnapped)) {
			//printf("pose\n");
			//pf_vector_fprintf(pose, stdout, "%.3f");

			AMCLOdomData odata;
			odata.pose = raw_pose;
			// HACK
			// Modify the delta in the action data so the filter gets
			// updated correctly
			odata.delta = delta;
			if(COMP->getGlobalState().getGeneral().getVerbose() == true){
				std::cout << "Odometry: "<< odata.pose;
				std::cout << "Delta   : "<< odata.delta;
			}

			//					////// DEBUG ///////////
			//					 std::stringstream sFileNamePose;
			//					 sFileNamePose << "input_pose.txt";
			//
			//					 std::ofstream fileStreamPose((sFileNamePose.str()).c_str(),std::ios::app);
			//					 if(fileStreamPose)
			//					 {
			//								std::cout<<"file opened\n";
			//								fileStreamPose<<"pose: "<<odata.pose.v[0]<<" "<<odata.pose.v[1]<<" "<<odata.pose.v[2]<<" delta: "<< odata.delta.v[0]<<" " << odata.delta.v[1]<<" "<< odata.delta.v[2]<<std::endl;
			//					 }
			//					 else
			//					 {
			//					   std::cout<<"error: opening file\n";
			//					 }
			//					 fileStreamPose.close();
			//					 ////// END DEBUG ///////


			// Use the action data to update the filter
			COMP->odom_->UpdateAction(COMP->pf_, (AMCLSensorData*) &odata);
			std::cout <<" [AMCL] : Motion Update ,"
					  <<" laser_update_ = "<<laser_update_
					  <<" tag_update_   = "<<tag_update_
					  <<" is_kidnapped  = "<<is_kidnapped<< std::endl;

			// Pose at last filter update
			//this->pf_odom_pose = pose;
		}

		////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////
		bool laser_resampled = false;
		bool tag_resampled = false;



		//reset the filter to location estimates from visualtags
		if(is_kidnapped)
		{
			CommBasicObjects::CommPose3d tag_estimated_pose = estimateMeanRobotPoseFromTags(dml, marker_list);

			// Initialize the filter
			pf_vector_t pf_init_pose_mean = pf_vector_zero();
			pf_init_pose_mean.v[0] = tag_estimated_pose.get_x(1.0);
			pf_init_pose_mean.v[1] = tag_estimated_pose.get_y(1.0);
			pf_init_pose_mean.v[2] = tag_estimated_pose.get_azimuth();
			pf_matrix_t pf_init_pose_cov = pf_matrix_zero();
			pf_init_pose_cov.m[0][0] = COMP->getGlobalState().getGeneral().getInitial_cov_xx();
			pf_init_pose_cov.m[1][1] = COMP->getGlobalState().getGeneral().getInitial_cov_yy();
			pf_init_pose_cov.m[2][2] = COMP->getGlobalState().getGeneral().getInitial_cov_aa();
			pf_init(COMP->pf_, pf_init_pose_mean, pf_init_pose_cov);

			std::cout << "Resetting Particle filter to (x, y, theta) = ("<<pf_init_pose_mean.v[0]<<", "<<pf_init_pose_mean.v[1]<<", "<<pf_init_pose_mean.v[2]<<")" << std::endl;
		}


		//update particle filter with visualtag info
		//conditions to check
		//1. tag is received and robot moved minimum distance (i.e tag_update_ = true)
		//2. Robot is not kidnapped (this handled below)
		//condition = ((1 && (2 || 3)) || (4))

		else if(tag_update_ &&!is_kidnapped)
		{
			AMCLTagData tdata;
			//std::cout << __LINE__ <<std::endl;
			tdata.robot_pose_from_tags = estimateMeanRobotPoseFromTags(dml, marker_list);
			tdata.distance_variance 	= COMP->getGlobalState().getVisualTag().getDistance_variance();
			tdata.orientation_variance 	= COMP->getGlobalState().getVisualTag().getOrientation_variance();

			std::cout << "Robot Pose estimated from Tag: " << tdata.robot_pose_from_tags <<std::endl;
			COMP->visual_tag_->UpdateSensor(COMP->pf_, (AMCLSensorData*) &tdata);

			std::cout << "[AMCL] : Sensor Update VisualTag" << std::endl;

			if (!(++resample_count_ % resample_interval_)) {
				std::cout << "[AMCL] : Tag Resample"
						<<" tag_update_   = "<<tag_update_
						<<" is_kidnapped  = "<<is_kidnapped<< std::endl;
				pf_update_resample(COMP->pf_);
				tag_resampled = true;
			}

		}


        //update particle filter with laser info
		else if(laser_update_ && !is_kidnapped)
        {
        	AMCLLaserData ldata;
        	set_laser_data(ldata, scan, COMP->laser_);

        	COMP->laser_->UpdateSensor(COMP->pf_, (AMCLSensorData*) &ldata);
        	std::cout << "[AMCL] : Sensor Update Laser" << std::endl;

        	if (!(++resample_count_ % resample_interval_)) {
        		std::cout << "[AMCL] : Laser Resample" << std::endl;
        		pf_update_resample(COMP->pf_);
        		laser_resampled = true;
        	}
        }

		if(laser_update_ || tag_update_ || force_publication || is_kidnapped)
		{
			pf_odom_pose_ = raw_pose;
			if(COMP->getGlobalState().getGeneral().getEnable_visualization() == true){
				// display particles
				COMP->h.displayParticles(COMP->pf_->sets+COMP->pf_->current_set);
			}
		}
		//		bool resampled = false;
		// Resample the particles
		//		if(laser_update_ || tag_update_)
		//		{
		//			if (!(++resample_count_ % resample_interval_)) {
		//				std::cout << "[AMCL] : Resample" << std::endl;
		//				pf_update_resample(COMP->pf_);
		//				resampled = true;
		//			}
		//
		//			pf_odom_pose_ = raw_pose;
		//			if(COMP->getGlobalState().getGeneral().getEnable_visualization() == true){
		//				// display particles
		//				COMP->h.displayParticles(COMP->pf_->sets+COMP->pf_->current_set);
		//			}
		//		}

		////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////

		//if (resampled || force_publication) {
		if (laser_resampled || tag_resampled || force_publication || is_kidnapped) {

			amcl_hyp_t best_hypothesis = find_hypothesis_with_max_weight(COMP->pf_);

			if (best_hypothesis.weight > 0.0) {

				CommLocalizationObjects::LocalizationEventState state;
				state.set(verify_localization_status(COMP->pf_, best_hypothesis));
				COMP->localizationEventServiceOut->put(state);

				CommBasicObjects::CommBasePositionUpdate positionUpdate = hypothesis_to_position_update(best_hypothesis, previous_base_pose);
				COMP->localizationUpdateServiceOut->send(positionUpdate);

				double e1, e2;
				get_eigen_values(best_hypothesis.pf_pose_cov.m, e1, e2);

				max_hypo_clusters_eigens_sum = e1 + e2;

				logger.write_baseUpdate(positionUpdate, COMP->pf_->sets[COMP->pf_->current_set].cluster_count, best_hypothesis.pf_pose_cov.m, e1, e2,
						laser_resampled, tag_resampled, force_publication, is_kidnapped);
			} else {
				std::cerr << "No pose!\n";
			}
		}

	} //pfGuard.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int AmclTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}


/////////////////////////////////////////////
//
//			private methods
//
/////////////////////////////////////////////

int AmclTask::init(const std::string& mapFilename) {


	//	 //DEBUG//
	//	 std::stringstream sFileNameLaser;
	//	 sFileNameLaser << "input_laser.txt";
	//	 std::stringstream sFileNamePose;
	//	 sFileNamePose << "input_pose.txt";
	//
	//	 std::ofstream fileStreamLaser((sFileNameLaser.str()).c_str(),std::ios::trunc);
	//	 std::ofstream fileStreamPose((sFileNamePose.str()).c_str(),std::ios::trunc);
	//	 fileStreamLaser.close();
	//	 fileStreamPose.close();
	//	 //END DEBUG//

	std::cout << "[AMCL] loading map ...\n";

	resample_interval_ = COMP->getGlobalState().getFilter().getResample_interval();

	//get map info from yaml file
	amcl_map_info_t map_info;
	int map_info_status = get_map_info(mapFilename, map_info);
	if(map_info_status !=0)
		return map_info_status;



	SmartACE::SmartRecursiveGuard pfGuard(COMP->PFMutex);
	{
		if(COMP->amcl_init == true){
			std::cout << "WARNING [AMCL] initializing filter --> filter already initialized ... DO NOTHING\n";
			return 0;
		}

		std::cout << "[AMCL] loading map from file ...\n";
		// load map
		COMP->map_ = loadMapFromFile(map_info);

		std::cout << "[AMCL] initializing filter ...\n";
		ParameterStateStruct localState = COMP->getGlobalState();

		// Create the particle filter
		COMP->pf_ = pf_alloc(localState.getFilter().getMin_particles(), localState.getFilter().getMax_particles(),
				localState.getFilter().getRecovery_alpha_slow(), localState.getFilter().getRecovery_alpha_fast(),
				(pf_init_model_fn_t) ComponentAmclWithTagsCore::uniformPoseGenerator, (void *) COMP->map_);

		COMP->pf_->pop_err = localState.getFilter().getKld_err();
		COMP->pf_->pop_z = localState.getFilter().getKld_z();


		if(localState.getGeneral().getInitalizationType() == ParameterStateStruct::GeneralType::initalizationTypeType::INI_POSE){
			// Initialize the filter
			pf_vector_t pf_init_pose_mean = pf_vector_zero();
			pf_init_pose_mean.v[0] = localState.getGeneral().getInitial_x();
			pf_init_pose_mean.v[1] = localState.getGeneral().getInitial_y();
			pf_init_pose_mean.v[2] = localState.getGeneral().getInitial_a();
			pf_matrix_t pf_init_pose_cov = pf_matrix_zero();
			pf_init_pose_cov.m[0][0] = localState.getGeneral().getInitial_cov_xx();
			pf_init_pose_cov.m[1][1] = localState.getGeneral().getInitial_cov_yy();
			pf_init_pose_cov.m[2][2] = localState.getGeneral().getInitial_cov_aa();
			pf_init(COMP->pf_, pf_init_pose_mean, pf_init_pose_cov);

		} else if (localState.getGeneral().getInitalizationType() == ParameterStateStruct::GeneralType::initalizationTypeType::GLOBAL){
			pf_init_model(COMP->pf_,(pf_init_model_fn_t) ComponentAmclWithTagsCore::uniformPoseGenerator, (void *) COMP->map_);

		} else if (localState.getGeneral().getInitalizationType() == ParameterStateStruct::GeneralType::initalizationTypeType::FILE_POSE){

			ifstream file (localState.getGeneral().getInitPoseFileName().c_str());
			if (file.is_open())
			{
				std::string line;
				getline (file,line);

				std::cout<<"line: "<<line<<std::endl;
				std::stringstream ss(line);
				std::stringstream tmp;
				std::string token;
				double x,y,a;

				tmp.clear();
				std::getline(ss, token, ';');
				tmp.str(token);
				tmp>>x;

				tmp.clear();
				std::getline(ss, token, ';');
				tmp.str(token);
				tmp>>y;

				tmp.clear();
				std::getline(ss, token, ';');
				tmp.str(token);
				tmp>>a;

				std::cout<<"Pose from file x:"<<x<<" y:"<<y<<" a:"<<a<<std::endl;

				pf_vector_t pf_init_pose_mean = pf_vector_zero();
				pf_init_pose_mean.v[0] = x;
				pf_init_pose_mean.v[1] = y;
				pf_init_pose_mean.v[2] = a;
				pf_matrix_t pf_init_pose_cov = pf_matrix_zero();
				pf_init_pose_cov.m[0][0] = localState.getGeneral().getInitial_cov_xx();
				pf_init_pose_cov.m[1][1] = localState.getGeneral().getInitial_cov_yy();
				pf_init_pose_cov.m[2][2] = localState.getGeneral().getInitial_cov_aa();
				pf_init(COMP->pf_, pf_init_pose_mean, pf_init_pose_cov);

			} else {
				std::cout<<"Error opening file: "<<localState.getGeneral().getInitPoseFileName()<<std::endl;
				std::cout<<"USE GLOBAL LOCLIZATION"<<std::endl;
				pf_init_model(COMP->pf_,(pf_init_model_fn_t) ComponentAmclWithTagsCore::uniformPoseGenerator, (void *) COMP->map_);
			}
		}

		//pf_init_model(pf_, (pf_init_model_fn_t) AmclTask::uniformPoseGenerator, (void *) map_);
		COMP->pf_init_ = false;

		// Instantiate the sensor objects
		// Odometry
		odom_model_t odom_model_type;
		if(localState.getOdometry().getOdom_model_type() == "diff"){
			odom_model_type = ODOM_MODEL_DIFF;
		}else if (localState.getOdometry().getOdom_model_type() == "omni"){
			odom_model_type = ODOM_MODEL_OMNI;
		}else{
			std::cout<<"Unkown odom model type "<<localState.getOdometry().getOdom_model_type()<< " defaulting to diff model"<<std::endl;
			odom_model_type = ODOM_MODEL_DIFF;

		}

		COMP->odom_ = new AMCLOdom();
		if(odom_model_type == ODOM_MODEL_OMNI){
			COMP->odom_->SetModelOmni(localState.getOdometry().getAlpha1(), localState.getOdometry().getAlpha2(), localState.getOdometry().getAlpha3(),
					localState.getOdometry().getAlpha4(), localState.getOdometry().getAlpha5());
		}else {
			COMP->odom_->SetModelDiff(localState.getOdometry().getAlpha1(), localState.getOdometry().getAlpha2(), localState.getOdometry().getAlpha3(),
					localState.getOdometry().getAlpha4());
		}

		// Laser
		laser_model_t laser_model_type;
		if(localState.getLaser().getLaser_model_type() == "beam"){
			laser_model_type = LASER_MODEL_BEAM;
		}else if(localState.getLaser().getLaser_model_type() == "likelihood_field"){
			laser_model_type = LASER_MODEL_LIKELIHOOD_FIELD;
		}else{
			std::cout<<"Unkown laser model type "<<localState.getLaser().getLaser_model_type()<< " defaulting to likelihood_field model"<<std::endl;
			laser_model_type = LASER_MODEL_LIKELIHOOD_FIELD;
		}


		COMP->laser_ = new AMCLLaser(localState.getLaser().getMax_beams(), COMP->map_);
		if(laser_model_type == LASER_MODEL_BEAM){
			COMP->laser_->SetModelBeam(localState.getLaser().getZ_hit(), localState.getLaser().getZ_short(), localState.getLaser().getZ_max(),
					localState.getLaser().getZ_rand(), localState.getLaser().getSigma_hit(), localState.getLaser().getLambda_short(), 0.0);
		}else{
			COMP->laser_->SetModelLikelihoodField(localState.getLaser().getZ_hit(), localState.getLaser().getZ_rand(), localState.getLaser().getSigma_hit(),
					localState.getLaser().getLaser_likelihood_max_dist());
		}

		//visual tag
		COMP->visual_tag_ = new AMCLVisualTag();
		JsonParser jason_parser(localState.getGeneral().getTag_file());
		marker_list = jason_parser.get_markers_info();
		std::cout << "[AMCL] tags size = " <<marker_list.size() <<std::endl;

	}
	COMP->amcl_init = true;
	pfGuard.release();

	std::cout << "[AMCL] init finished!\n";
	return 0;
}

#ifdef WITH_OPENCV_4_2_VERSION
map_t* AmclTask::loadMapFromFile(amcl_map_info_t& map_info) {

	unsigned char* pixels;
	unsigned char* p;
	int rowstride, n_channels;
	int i, j;
	int k;
	double occ;
	int color_sum;
	double color_avg;

	map_t* map = map_alloc();
	cv::Mat img;




	// Load the image using SDL.  If we get NULL back, the image load failed.
	img = cv::imread(map_info.mapfname.c_str(), cv::IMREAD_UNCHANGED);
	if (img.empty()){
		std::string errmsg = std::string("failed to open image file \"") +map_info.mapfname + std::string("\"");
		throw std::runtime_error(errmsg);
	}

	map->size_x = img.cols;
	map->size_y = img.rows;
	map->scale = map_info.resolution;
	std::cout<<" origin[0]"<<map_info.origin.v[0]<<std::endl;
	std::cout<<" origin[1]"<<map_info.origin.v[1]<<std::endl;
	map->origin_x = map_info.origin.v[0] + (map->size_x / 2.0) * map->scale;
	map->origin_y = map_info.origin.v[1] + (map->size_y / 2.0) * map->scale;
	map->cells = (map_cell_t*) malloc(sizeof(map_cell_t) * map->size_x * map->size_y);

	// Get values that we'll need to iterate through the pixels
	rowstride = img.channels()*img.cols;
	n_channels = img.channels();

	// Copy pixel data into the map structure
	pixels = (unsigned char*) (img.data);

	for (j = 0; j < img.rows; j++) {
		for (i = 0; i < img.cols; i++) {

			// Compute mean of RGB for this pixel
			p = pixels + j * rowstride + i * n_channels;
			color_sum = 0;
			for (k = 0; k < n_channels; k++) {
				color_sum += *(p + (k));
			}
			color_avg = color_sum / (double) n_channels;

			// If negate is true, we consider blacker pixels free, and whiter
			// pixels free.  Otherwise, it's vice versa.
			if (map_info.negate) {
				occ = color_avg / 255.0;
			} else {
				occ = (255 - color_avg) / 255.0;
			}

			// Apply thresholds to RGB means to determine occupancy values for
			// map.  Note that we invert the graphics-ordering of the pixels to
			// produce a map with cell (0,0) in the lower-left corner.
			if (occ > map_info.occ_threshold) {
				map->cells[MAP_IDX(img.cols, i, img.rows - j - 1)].occ_state = +1;
			} else if (occ < map_info.free_threshold) {
				map->cells[MAP_IDX(img.cols, i, img.rows - j - 1)].occ_state = -1;
			} else {
				map->cells[MAP_IDX(img.cols, i, img.rows - j - 1)].occ_state = 0;
			}
		}
	}

	return map;
}
#else
map_t* AmclTask::loadMapFromFile(amcl_map_info_t& map_info) {

	unsigned char* pixels;
	unsigned char* p;
	int rowstride, n_channels;
	int i, j;
	int k;
	double occ;
	int color_sum;
	double color_avg;

	map_t* map = map_alloc();
	IplImage* img = NULL;




	// Load the image using SDL.  If we get NULL back, the image load failed.
	if (!(img = cvLoadImage(map_info.mapfname.c_str(), CV_LOAD_IMAGE_UNCHANGED))) {
		std::string errmsg = std::string("failed to open image file \"") +map_info.mapfname + std::string("\"");
		throw std::runtime_error(errmsg);
	}

	map->size_x = img->width;
	map->size_y = img->height;
	map->scale = map_info.resolution;
	std::cout<<" origin[0]"<<map_info.origin.v[0]<<std::endl;
	std::cout<<" origin[1]"<<map_info.origin.v[1]<<std::endl;
	map->origin_x = map_info.origin.v[0] + (map->size_x / 2.0) * map->scale;
	map->origin_y = map_info.origin.v[1] + (map->size_y / 2.0) * map->scale;
	map->cells = (map_cell_t*) malloc(sizeof(map_cell_t) * map->size_x * map->size_y);

	// Get values that we'll need to iterate through the pixels
	rowstride = img->widthStep;
	n_channels = img->nChannels;

	// Copy pixel data into the map structure
	pixels = (unsigned char*) (img->imageData);

	for (j = 0; j < img->height; j++) {
		for (i = 0; i < img->width; i++) {

			// Compute mean of RGB for this pixel
			p = pixels + j * rowstride + i * n_channels;
			color_sum = 0;
			for (k = 0; k < n_channels; k++) {
				color_sum += *(p + (k));
			}
			color_avg = color_sum / (double) n_channels;

			// If negate is true, we consider blacker pixels free, and whiter
			// pixels free.  Otherwise, it's vice versa.
			if (map_info.negate) {
				occ = color_avg / 255.0;
			} else {
				occ = (255 - color_avg) / 255.0;
			}

			// Apply thresholds to RGB means to determine occupancy values for
			// map.  Note that we invert the graphics-ordering of the pixels to
			// produce a map with cell (0,0) in the lower-left corner.
			if (occ > map_info.occ_threshold) {
				map->cells[MAP_IDX(img->width, i, img->height - j - 1)].occ_state = +1;
			} else if (occ < map_info.free_threshold) {
				map->cells[MAP_IDX(img->width, i, img->height - j - 1)].occ_state = -1;
			} else {
				map->cells[MAP_IDX(img->width, i, img->height - j - 1)].occ_state = 0;
			}
		}
	}
	cvReleaseImage(&img);

	return map;
}
#endif

CommBasicObjects::CommPose3d AmclTask::estimateWeightedRobotPoseFromTags(const CommTrackingObjects::CommDetectedMarkerList& markers_detected,
					                                             const std::vector<CommTrackingObjects::CommDetectedMarker>& markers_from_map)
{
	double mean_x =0.0;
	double mean_y =0.0;
	double mean_z =0.0;

	double mean_roll =0.0;
	double mean_pitch =0.0;
	double mean_yaw =0.0;

	std::vector<CommBasicObjects::CommBasePose> robot_poses;
	size_t num_tags = markers_detected.getMarkersSize();
	assert(num_tags >0);
	//	std::cout << "num_tags : " << num_tags<<std::endl;


	double sum_x =0.0;
	double sum_y =0.0;
	double sum_z =0.0;

	double sum_roll =0.0;
	double sum_pitch =0.0;
	double sum_yaw =0.0;


	//Ref: https://gsyc.urjc.es/jmplaza/papers/jornadasautomatica2016-pnp.pdf
	//Accuracy analysis of marker-based 3D visual localization

	double total_weight = 0.0;
	std::vector<double> marker_weights(num_tags, 0.0);

	std::vector<double> wolrd2robot_x(num_tags, 0.0);
	std::vector<double> wolrd2robot_y(num_tags, 0.0);
	std::vector<double> wolrd2robot_z(num_tags, 0.0);

	std::vector<double> wolrd2robot_azimuth(num_tags, 0.0);
	std::vector<double> wolrd2robot_elevation(num_tags, 0.0);
	std::vector<double> wolrd2robot_roll(num_tags, 0.0);

	for(size_t index = 0; index < num_tags; ++index)
	{
		CommTrackingObjects::CommDetectedMarker currentMarker = markers_detected.getMarkersElemAtPos(index);

		unsigned int tag_id = currentMarker.getId();

		CommBasicObjects::CommPose3d markerPoseInRobotFrame = markers_detected.get_tag_pose_in_robot_frame_by_index(index);
		CommBasicObjects::CommPose3d markerPoseInWorldFrame = get_tag_pose_by_id(markers_from_map, tag_id);

		mrpt::poses::CPose3D robot_to_marker(markerPoseInRobotFrame.get_x(1), markerPoseInRobotFrame.get_y(1), markerPoseInRobotFrame.get_z(1),
				markerPoseInRobotFrame.get_azimuth(),
				markerPoseInRobotFrame.get_elevation(),
				markerPoseInRobotFrame.get_roll());

		mrpt::poses::CPose3D world_to_marker(markerPoseInWorldFrame.get_x(1), markerPoseInWorldFrame.get_y(1), markerPoseInWorldFrame.get_z(1),
				markerPoseInWorldFrame.get_azimuth(),
				markerPoseInWorldFrame.get_elevation(),
				markerPoseInWorldFrame.get_roll());

		arma::mat m_world_to_marker = markerPoseInWorldFrame.getHomogeneousMatrix(1.0);
		arma::mat m_robot_to_marker = markerPoseInRobotFrame.getHomogeneousMatrix(1.0);
		arma::mat m_world_to_robot  = m_world_to_marker * arma::inv(m_robot_to_marker);


		CommBasicObjects::CommPose3d world_robot(m_world_to_robot,1.0);

		//x,y,z azimuth elevation roll
		wolrd2robot_x[index] = world_robot.get_x(1.0);
		wolrd2robot_y[index] = world_robot.get_y(1.0);
		wolrd2robot_z[index] = world_robot.get_z(1.0);

		wolrd2robot_azimuth[index]   = world_robot.get_azimuth();
		wolrd2robot_elevation[index] = world_robot.get_elevation();
		wolrd2robot_roll[index]      = world_robot.get_roll();


		double marker_x = currentMarker.getPose().get_x(1.0);
		double marker_y = currentMarker.getPose().get_y(1.0);
		double marker_z = currentMarker.getPose().get_z(1.0);

		double current_weight = std::sqrt(marker_x*marker_x+marker_y*marker_y+marker_z*marker_z);
		marker_weights[index] = current_weight;
		total_weight += current_weight;
	}


	double sum_sin_yaw = 0.0;
	double sum_cos_yaw = 0.0;

	double sum_sin_ele = 0.0;
	double sum_cos_ele = 0.0;


	double sum_sin_roll = 0.0;
	double sum_cos_roll = 0.0;



	for(size_t index = 0; index < num_tags; ++index)
	{
		double current_ratio = marker_weights[index] / total_weight;
		std::cout << "current _ration = " <<current_ratio <<std::endl;

		mean_x += wolrd2robot_x[index] *  current_ratio;
		mean_y += wolrd2robot_y[index] *  current_ratio;
		mean_z += wolrd2robot_z[index] *  current_ratio;

		sum_sin_yaw += std::sin(wolrd2robot_azimuth[index]) * current_ratio;
		sum_cos_yaw += std::cos(wolrd2robot_azimuth[index]) * current_ratio;

		sum_sin_ele += std::sin(wolrd2robot_elevation[index]) * current_ratio;
		sum_cos_ele += std::cos(wolrd2robot_elevation[index]) * current_ratio;

		sum_sin_roll += std::sin(wolrd2robot_roll[index]) * current_ratio;
		sum_cos_roll += std::cos(wolrd2robot_roll[index]) * current_ratio;
	}

	mean_yaw   = atan(sum_sin_yaw/sum_cos_yaw);
	mean_pitch = atan(sum_sin_ele/sum_cos_ele);
	mean_roll  = atan(sum_sin_roll/sum_cos_roll);

	return CommBasicObjects::CommPose3d(mean_x, mean_y, mean_z, mean_yaw, mean_pitch, mean_roll, 1.0);
}

CommBasicObjects::CommPose3d AmclTask::estimateMeanRobotPoseFromTags(const CommTrackingObjects::CommDetectedMarkerList& markers_detected,
					                                             const std::vector<CommTrackingObjects::CommDetectedMarker>& markers_from_map)
{
	double mean_x =0.0;
	double mean_y =0.0;
	double mean_z =0.0;

	double mean_roll =0.0;
	double mean_pitch =0.0;
	double mean_yaw =0.0;

	std::vector<CommBasicObjects::CommBasePose> robot_poses;
	size_t num_tags = markers_detected.getMarkersSize();
	assert(num_tags >0);
	//	std::cout << "num_tags : " << num_tags<<std::endl;


	for(size_t index = 0; index < num_tags; ++index)
	{
		CommTrackingObjects::CommDetectedMarker currentMarker = markers_detected.getMarkersElemAtPos(index);

		unsigned int tag_id = currentMarker.getId();

		CommBasicObjects::CommPose3d markerPoseInRobotFrame = markers_detected.get_tag_pose_in_robot_frame_by_index(index);
		CommBasicObjects::CommPose3d markerPoseInWorldFrame = get_tag_pose_by_id(markers_from_map, tag_id);

		mrpt::poses::CPose3D robot_to_marker(markerPoseInRobotFrame.get_x(1), markerPoseInRobotFrame.get_y(1), markerPoseInRobotFrame.get_z(1),
				markerPoseInRobotFrame.get_azimuth(),
				markerPoseInRobotFrame.get_elevation(),
				markerPoseInRobotFrame.get_roll());

		mrpt::poses::CPose3D world_to_marker(markerPoseInWorldFrame.get_x(1), markerPoseInWorldFrame.get_y(1), markerPoseInWorldFrame.get_z(1),
				markerPoseInWorldFrame.get_azimuth(),
				markerPoseInWorldFrame.get_elevation(),
				markerPoseInWorldFrame.get_roll());

		arma::mat m_world_to_marker = markerPoseInWorldFrame.getHomogeneousMatrix(1.0);
		arma::mat m_robot_to_marker = markerPoseInRobotFrame.getHomogeneousMatrix(1.0);
		arma::mat m_world_to_robot  = m_world_to_marker * arma::inv(m_robot_to_marker);


		CommBasicObjects::CommPose3d world_robot(m_world_to_robot,1.0);

		//x,y,z azimuth elevation roll
		mean_x = world_robot.get_x(1.0)/(float)num_tags;
		mean_y = world_robot.get_y(1.0)/(float)num_tags;
		mean_z = world_robot.get_z(1.0)/(float)num_tags;

		mean_yaw   = world_robot.get_azimuth()/(float)num_tags;
		mean_pitch = world_robot.get_elevation()/(float)num_tags;
		mean_roll  = world_robot.get_roll()/(float)num_tags;
	}

	return CommBasicObjects::CommPose3d(mean_x, mean_y, mean_z, mean_yaw, mean_pitch, mean_roll, 1.0);
}

CommBasicObjects::CommPose3d AmclTask::get_tag_pose_by_id(const std::vector<CommTrackingObjects::CommDetectedMarker>& markers, size_t tag_id)
{
	auto marker_itr = std::find_if(markers.begin(), markers.end(),
																	[&tag_id](const CommTrackingObjects::CommDetectedMarker& currentMarker)
																	{return currentMarker.getId() == tag_id;});

	return (*marker_itr).getPose();
}

void AmclTask::set_laser_data(AMCLLaserData& ldata, const CommBasicObjects::CommMobileLaserScan& scan, const AMCLLaser* laser)
{
	ldata.sensor = COMP->laser_;
	ldata.range_count = scan.get_scan_size();

	// Apply range min/max thresholds, if the user supplied them
	double range_min;
	// TODO check max range use
	//ldata.range_max = 2.0;
	ldata.range_max = scan.get_max_distance(1.0);
	range_min = scan.get_min_distance(1.0);

	// The AMCLLaserData destructor will free this memory
	ldata.ranges = new double[ldata.range_count][2];
	double factor = (isPlanarFliped) ? -1 : 1;
	int rIndex = 0;

	for (int i = 0; i < ldata.range_count; i++) {

		if (isPlanarFliped)
			rIndex = ldata.range_count - i - 1;
		else
			rIndex = i;

		// amcl doesn't (yet) have a concept of min range.
		// So we'll map short readings to max range.
		if (scan.get_scan_distance(i, 1.0) <= range_min) {
			ldata.ranges[rIndex][0] = ldata.range_max;
		} else {
			ldata.ranges[rIndex][0] = scan.get_scan_distance(i, 1.0);
		}

		// Compute bearing
		ldata.ranges[rIndex][1] = pi_to_pi(scan.get_scan_angle(i)) * factor;
		if(COMP->getGlobalState().getGeneral().getVerbose() == true){
			printf("laser %d; dist = %.3f; angle = %.3f\n",rIndex,ldata.ranges[rIndex][0],ldata.ranges[rIndex][1]);
		}

	}
}

amcl_hyp_t AmclTask::find_hypothesis_with_max_weight(pf_t *pf_)
{
	amcl_hyp_t best_hypothesis;
	double max_weight = 0.0;
	std::vector<amcl_hyp_t> hyps;
	hyps.resize(pf_->sets[pf_->current_set].cluster_count);

	for (int hyp_count = 0; hyp_count < pf_->sets[pf_->current_set].cluster_count; hyp_count++) {
		double weight;
		pf_vector_t pose_mean;
		pf_matrix_t pose_cov;

		if (!pf_get_cluster_stats(pf_, hyp_count, &weight, &pose_mean, &pose_cov)) {
			std::cerr << "Couldn't get stats on cluster " << hyp_count << "\n";
			break;
		}

		hyps[hyp_count].weight = weight;
		hyps[hyp_count].pf_pose_mean = pose_mean;
		hyps[hyp_count].pf_pose_cov = pose_cov;

		if (hyps[hyp_count].weight > max_weight) {
			max_weight = hyps[hyp_count].weight;
			best_hypothesis = hyps[hyp_count];
		}
	}

	if(COMP->getGlobalState().getGeneral().getEnable_visualization() == true){
		COMP->h.displayHypotheses(hyps);
	}

	return best_hypothesis;
}

CommLocalizationObjects::LocalizationEventType AmclTask::verify_localization_status(const pf_t *pf_, const amcl_hyp_t& best_hypothesis)
{

//	Eigen::Matrix3d X = Eigen::Map<Eigen::Matrix3d>(const_cast<double *>(&best_hypothesis.pf_pose_cov.m[0][0]));
//	//Eigen::Matrix3d X = Eigen::Map<Eigen::Matrix3d>(&hyps[max_weight_hyp].pf_pose_cov.m[0][0]);
//	Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> es;
//	es.compute(X);
//	Eigen::Vector3d eigenvalues = es.eigenvalues();
//	double lamda_sum = eigenvalues.sum();
    double covariance_matrix[3][3];
    memcpy(&covariance_matrix[0][0], &best_hypothesis.pf_pose_cov.m[0][0], 9 * sizeof(double));

    double e1, e2;
	get_eigen_values(covariance_matrix, e1, e2);
	double lamda_sum = e1+e2;

	if(COMP->getGlobalState().getGeneral().getVerbose() == true){
	std::cout<<"The sum of the EigenValues is: "<<lamda_sum<<std::endl;
	//std::cout<<"EigenValues: "<<es.eigenvalues()<<std::endl;
	}

	CommLocalizationObjects::LocalizationEventState state;
	if(pf_->sets[pf_->current_set].cluster_count >COMP->getGlobalState().getGeneral().getLostEventMaxHypothese() || lamda_sum > COMP->getGlobalState().getGeneral().getLostEventMaxEigValueSum())
	{
		std::cout<<"LOCALIZATION LOST!"<<std::endl;
		return CommLocalizationObjects::LocalizationEventType::LOCALIZATION_LOST;
	}
	else
	{
		std::cout<<"LOCALIZATION OK!"<<std::endl;
		return CommLocalizationObjects::LocalizationEventType::LOCALIZATION_OK;
	}
}

void AmclTask::get_laser_mounting(const CommBasicObjects::CommMobileLaserScan& scan, bool& is_planar, bool& is_planar_flipped)
{
	arma::vec zAxis(4);
	zAxis(0) = zAxis(1) = 0;
	zAxis(2) = zAxis(3) = 1.0;

	arma::mat sensor_mat = scan.get_sensor_pose().getHomogeneousMatrix(1.0);
	sensor_mat(0, 3) = sensor_mat(1, 3) = sensor_mat(2, 3) = 0; // remove translation from matrix
	zAxis = sensor_mat * zAxis;

	// laser is planar and mounted upside
	is_planar = (zAxis(2) > 0 && fabs(zAxis(0)) < 0.0001 && fabs(zAxis(1)) < 0.0001);

	// laser is planar but mounted upside down
	is_planar_flipped  = (zAxis(2) < 0 && fabs(zAxis(0)) < 0.0001 && fabs(zAxis(1)) < 0.0001);
}

CommBasicObjects::CommBasePositionUpdate AmclTask::hypothesis_to_position_update(const amcl_hyp_t& best_hypothesis, const CommBasicObjects::CommBasePose& previousPose)
{
	CommBasicObjects::CommBasePositionUpdate position_update;
	// set base position when the filter was applied
	position_update.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
	position_update.set_old_position(previousPose);

	// calculate the corrected base position
	CommBasicObjects::CommBasePose correctedPos;
	correctedPos.set_x(best_hypothesis.pf_pose_mean.v[0], 1.0);
	correctedPos.set_y(best_hypothesis.pf_pose_mean.v[1], 1.0);
	correctedPos.set_z(previousPose.get_z()); // use the z value from the old pos because we do not know better
	correctedPos.set_base_azimuth(best_hypothesis.pf_pose_mean.v[2]);

	// Copy in the covariance
	// TODO check covariance matrix
	//	pf_sample_set_t* set = COMP->pf_->sets + COMP->pf_->current_set;
	//	for (int i = 0; i < 2; i++) {
	//		for (int j = 0; j < 2; j++) {
	//			correctedPos.set_cov(i, j, set->cov.m[i][j]);
	//		}
	//	}
	//	correctedPos.set_cov(2, 2, set->cov.m[2][2]);

	for (int i = 0; i < 2; i++) {
		for (int j = 0; j < 2; j++) {
			correctedPos.set_cov(i, j, best_hypothesis.pf_pose_cov.m[i][j]);
		}
	}
	correctedPos.set_cov(2, 2, best_hypothesis.pf_pose_cov.m[2][2]);

	// send the position update
	position_update.set_corrected_position(correctedPos);
	return position_update;
}

void AmclTask::receive_sensor_data(CommBasicObjects::CommMobileLaserScan& laser_scan, CommTrackingObjects::CommDetectedMarkerList& tag_list)
{

	Smart::StatusCode status;
	if(COMP->sensor_to_use == amcl_sensor_to_use::LASER_ONLY || COMP->sensor_to_use == amcl_sensor_to_use::LASER_PLUS_VISUAL_TAGS)
	{
		Smart::StatusCode status = COMP->laserServiceIn->getUpdateWait(laser_scan);
		laser_data_recieved_ = true;

		if (status != Smart::SMART_OK) {
			std::cerr << "[AMCL] laser client " << Smart::StatusCodeConversion(status) << "\n";
			ACE_OS::sleep(ACE_Time_Value(0,250000));
			laser_data_recieved_ = false;
		}
		if(laser_scan.get_scan_size()<2){
			std::cout<<"[AmclTask]: scan size <2 --> do not use scan!"<<std::endl;
			laser_data_recieved_ = false;
		}

	}

	if(COMP->sensor_to_use == amcl_sensor_to_use::VISUAL_TAGS_ONLY || COMP->sensor_to_use == amcl_sensor_to_use::LASER_PLUS_VISUAL_TAGS)
	{
		status = COMP->markerListDetectionServiceIn->getUpdateWait(tag_list, std::chrono::milliseconds(20));
		if (status != Smart::SMART_OK) {
			std::cerr << "[AMCL] tags list client " << Smart::StatusCodeConversion(status)<< "\n";
			tag_data_recieved_ = false;
		}else if(tag_list.getMarkersSize()>0)
		{
			tag_data_recieved_ = true;
			//estimateRobotPoseFromTags(tag_list, marker_list);
		}
	}
}

void AmclTask::get_odometry_and_prevous_pose(const CommBasicObjects::CommMobileLaserScan& laser_scan, const CommTrackingObjects::CommDetectedMarkerList& tag_list,
			pf_vector_t& odom, pf_vector_t& pose, CommBasicObjects::CommBasePose& previous_base_pose)
{

	CommBasicObjects::CommBasePose basePos;
	CommBasicObjects::CommBasePose rawBasePos;

	if(COMP->sensor_to_use == amcl_sensor_to_use::VISUAL_TAGS_ONLY || COMP->sensor_to_use == amcl_sensor_to_use::LASER_PLUS_VISUAL_TAGS)
	{
		// get the current base pose out of the laser scan
		basePos = tag_list.getBase_state().get_base_position();

		// get the current raw base pose out of the laser scan
		rawBasePos = tag_list.getBase_state().get_base_raw_position();
	}
	if(COMP->sensor_to_use == amcl_sensor_to_use::LASER_ONLY || COMP->sensor_to_use == amcl_sensor_to_use::LASER_PLUS_VISUAL_TAGS)
	{
		// get the current base pose out of the laser scan
		basePos = laser_scan.get_base_state().get_base_position();

		// get the current raw base pose out of the laser scan
		rawBasePos = laser_scan.get_base_state().get_base_raw_position();

		// get the laser pose on the robot
		CommBasicObjects::CommPose3d sensorPose = laser_scan.get_sensor_pose();
		pf_vector_t laser_pose_v;

		laser_pose_v.v[0] = sensorPose.get_x(1.0);
		laser_pose_v.v[1] = sensorPose.get_y(1.0);
		laser_pose_v.v[2] = pi_to_pi(sensorPose.get_azimuth());
		COMP->laser_->SetLaserPose(laser_pose_v);

	}

	pose.v[0] = basePos.get_x(1.0);
	pose.v[1] = basePos.get_y(1.0);
	pose.v[2] = pi_to_pi(basePos.get_base_azimuth());


	odom.v[0] = rawBasePos.get_x(1.0);
	odom.v[1] = rawBasePos.get_y(1.0);
	odom.v[2] = pi_to_pi(rawBasePos.get_base_azimuth());

	previous_base_pose = basePos;
}
void AmclTask::get_eigen_values(double covariance_matrix[3][3], double& e1, double& e2)
{
	Eigen::Matrix3d X = Eigen::Map<Eigen::Matrix3d>(const_cast<double *>(&covariance_matrix[0][0]));
	Eigen::SelfAdjointEigenSolver<Eigen::Matrix3d> es;
	es.compute(X);
	Eigen::Vector3d eigenvalues = es.eigenvalues();
	e1 = eigenvalues(0);
	e2 = eigenvalues(1);
}

bool AmclTask::is_robot_kidnapped(const CommBasicObjects::CommMobileLaserScan& scan, const CommTrackingObjects::CommDetectedMarkerList& markers_detected)
{
	bool is_kidnapped = false;

	assert(tag_data_recieved_ == true);

	//pose estimation from amcl
	CommBasicObjects::CommPose3d amcl_estimated_pose = scan.getBase_state().getBasePose().get_base_pose3d();

	//pose estimation from visualtags
	CommBasicObjects::CommPose3d tag_estimated_pose = estimateMeanRobotPoseFromTags(markers_detected, marker_list);


	double delta_x = amcl_estimated_pose.get_x(1.0) - tag_estimated_pose.get_x(1.0);
	double delta_y = amcl_estimated_pose.get_y(1.0) - tag_estimated_pose.get_y(1.0);
	double delta_yaw = amcl_estimated_pose.get_azimuth() - tag_estimated_pose.get_azimuth();

	//is_kidnapped = (sqrt(delta_x*delta_x + delta_y*delta_y)>1.0) || (abs(delta_yaw) > M_PI);
	is_kidnapped = (sqrt(delta_x*delta_x + delta_y*delta_y)>1.0);

	if(is_kidnapped){
//		std::cout << "\n##################  Robot is Kidnapped     ##################   \n";
//		std::cout << " delta_x = "<<delta_x<< ", delta_y = "<<delta_y<< ", delta_yaw = "<<delta_yaw<<"\n";
//		std::cout << "laser scan Id = " << scan.get_scan_update_count() << std::endl;
//		std::cout << "\ntag_estimated_pose : ";
//		tag_estimated_pose.to_ostream(std::cout);
//		std::cout << "\namcl_estimated_pose : ";
//		amcl_estimated_pose.to_ostream(std::cout);
	}else
	{
		//std::cout << "\nRobot is not Kidnapped "<< ", delta_x = "<<delta_x<< ", delta_y = "<<delta_y<< ", delta_yaw = "<<delta_yaw<<std::endl;
	}

	return is_kidnapped;
}
