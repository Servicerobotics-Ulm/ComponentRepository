//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//------------------------------------------------------------------------
//
//  Copyright (C) 2010;2013 Manuel Wopfner; Matthias Lutz
//
//        lutz@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------
#include "PtuTask.hh"
#include "ComponentPTUServer.hh"

#include <EulerTransformationMatrices.hh>
#include <iostream>

#include "ParameterStateStruct.hh"

PtuTask::PtuTask(SmartACE::SmartComponent *comp)
:	PtuTaskCore(comp)
{
	std::cout << "constructor PtuTask\n";
}
PtuTask::~PtuTask() 
{
	std::cout << "destructor PtuTask\n";
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	ptu.close();
	guard.release();
}


int PtuTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int PtuTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	

	std::cout<<"waiting on CV"<<std::endl;
	this->newGoalCV.wait();
	this->newGoalCV.reset();


	//wait until a new Goal is set
	std::cout<<"moving to goal"<<std::endl;

	DomainPTU::PTUGoalEventState eventState;
	DomainPTU::CommPTUMoveResponse answer;
	DomainPTU::CommPTUMoveRequest request;

	SmartACE::SmartGuard guard(this->goalBufferMutex);
	request = this->oneElementGoalBuffer;
	guard.release();

	this->move(request,answer);

	COMP->newPtuPos.release();

	if(Smart::SMART_OK == COMP->stateSlave->tryAcquire("move")) {
		eventState.set_state(answer.get_status());
		COMP->goalEventServer->put(eventState);

		COMP->stateSlave->release("move");
	}


	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int PtuTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

bool PtuTask::init(const std::string& device)
{
	bool success = false;

	// calculate transformation matrix for robot offset
	ParameterStateStruct::DomainPTUType::PTUParameterType::SENSOR_OFFSETType offset = COMP->getGlobalState().getDomainPTU().getPTUParameter().getSENSOR_OFFSET();

	EulerTransformationMatrices::create_zyx_matrix(offset.getX(), offset.getY(), offset.getZ(),
			offset.getAzimuth(), offset.getElevation(), offset.getRoll(), ptuRobotOffset);

	default_base_position.set_x(COMP->getGlobalState().getBase().getX());
	default_base_position.set_y(COMP->getGlobalState().getBase().getY());
	default_base_position.set_z(COMP->getGlobalState().getBase().getZ());
	default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());
	default_base_position.set_base_elevation(COMP->getGlobalState().getBase().getSteer_a());
	default_base_position.set_base_roll(COMP->getGlobalState().getBase().getTurret_a());

	zero_velocity.set_vX(0);
	zero_velocity.set_vY(0);
	zero_velocity.set_vZ(0);
	zero_velocity.setWX(0);
	zero_velocity.setWY(0);
	zero_velocity.setWZ(0);

	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		while (!success)
		{
			std::cout << "[PTUWrapper] init ptu ...\n";
			success = ptu.init(device);
			if (success)
			{
				success = ptu.inmediateExecution(true);
				ptu.clearErrors();
				ptu.save();
			}
			else {
				sleep(1);
			}
		}

		std::cout << "[PTUWrapper] ptu init done!\n";
	}
	guard.release();

	SmartACE::SmartGuard paramGuard(COMP->paramMutex);
	{// pan parameters
//		std::cout << "setting pan parameters\n";
//		globalParam.speed_pan = COMP->getGlobalState().getHardware().getMin_speed_pan();
//		globalParam.start_up_speed_pan = COMP->getGlobalState().getHardware().getStart_up_speed_pan();
//		globalParam.min_speed_pan = COMP->getGlobalState().getHardware().getMin_speed_pan();
//		globalParam.max_speed_pan = COMP->getGlobalState().getHardware().getMax_speed_pan();
//		globalParam.acceleration_pan = COMP->getGlobalState().getHardware().getAcceleration_pan();
//
//		// tilt parameters
//		std::cout << "setting tilt parameters\n";
//		globalParam.speed_tilt = COMP->getGlobalState().getHardware().getSpeed_tilt();
//		globalParam.start_up_speed_tilt = COMP->getGlobalState().getHardware().getStart_up_speed_tilt();
//		globalParam.min_speed_tilt = COMP->getGlobalState().getHardware().getMin_speed_tilt();
//		globalParam.max_speed_tilt = COMP->getGlobalState().getHardware().getMax_speed_tilt();
//		globalParam.acceleration_tilt = COMP->getGlobalState().getHardware().getAcceleration_tilt();

		COMP->globalParam_modified = true;
	}
	paramGuard.release();

	// get current position;
	double pan, tilt;
	getPos(pan, tilt);

	SmartACE::SmartGuard posGuard(COMP->ptuMutex);
	{
		this->commandedPan = pan;
		this->commandedTilt = tilt;
	}
	posGuard.release();

	startPTU();
	posChanged = true;
	return success;
}

void PtuTask::setGoal(const DomainPTU::CommPTUMoveRequest& request)
{
	SmartACE::SmartGuard guard(goalBufferMutex);

	std::cout<<"<<<<<<<<<<<<<Added new Goal"<<std::endl;
	this->oneElementGoalBuffer = request;
	this->newGoalCV.signal();

	guard.release();
}

/*-----------------------------------------------------------------
 move
 ----------------------------------------------------------------*/
void PtuTask::move(const DomainPTU::CommPTUMoveRequest& request, DomainPTU::CommPTUMoveResponse& answer)
{
	PTUStatus status = PTUStatus::GOAL_REACHED;

	if (ptuActive)
	{

		/////////////////////////////
		// apply parameters
		/////////////////////////////

		SmartACE::SmartGuard paramGuard(COMP->paramMutex);
		if (COMP->globalParam_modified)
		{
			localParam = COMP->getGlobalState();
			COMP->globalParam_modified = false;

			if (COMP->getGlobalState().getPTU().getVerbose())
			{
				std::cout << "Setting new parameters to PTU ...\n";
			}

			SmartACE::SmartGuard guard(COMP->ptuMutex);
			if (localParam.getDomainPTU().getPTUParameter().getRESET().getReset())
			{
				ptu.reset();
			}


			// pan parameters
			ptu.baseSpeed(CPtuDPerception::Pan, localParam.getDomainPTU().getPTUParameter().getSTART_UP_SPEED_PAN().getSpeed());
			ptu.lowerSpeed(CPtuDPerception::Pan, localParam.getDomainPTU().getPTUParameter().getSPEED_LIMIT_PAN().getMin());
			ptu.upperSpeed(CPtuDPerception::Pan, localParam.getDomainPTU().getPTUParameter().getSPEED_LIMIT_PAN().getMax());
			ptu.speed(CPtuDPerception::Pan, localParam.getDomainPTU().getPTUParameter().getSPEED_PAN().getSpeed());
			ptu.aceleration(CPtuDPerception::Pan, localParam.getDomainPTU().getPTUParameter().getACCELERATION_PAN().getAcc());

			// tilt parameters
			ptu.baseSpeed(CPtuDPerception::Tilt, localParam.getDomainPTU().getPTUParameter().getSTART_UP_SPEED_TILT().getSpeed());
			ptu.lowerSpeed(CPtuDPerception::Tilt, localParam.getDomainPTU().getPTUParameter().getSPEED_LIMIT_TILT().getMin());
			ptu.upperSpeed(CPtuDPerception::Tilt, localParam.getDomainPTU().getPTUParameter().getSPEED_LIMIT_TILT().getMax());
			ptu.speed(CPtuDPerception::Tilt, localParam.getDomainPTU().getPTUParameter().getSPEED_TILT().getSpeed());
			ptu.aceleration(CPtuDPerception::Tilt, localParam.getDomainPTU().getPTUParameter().getACCELERATION_TILT().getAcc());
			guard.release();

			if (COMP->getGlobalState().getPTU().getVerbose())
			{
				std::cout << "New parameters were set to PTU\n";
			}
		}
		paramGuard.release();

		/////////////////////////////
		// select move mode
		/////////////////////////////


		SmartACE::SmartGuard guard(COMP->ptuMutex);
		{
			ptu.powerMode(true, 'H');

			char mode;
			ptu.powerModeQ(true, mode);
			std::cout << "mode: " << mode << "\n";
		}
		guard.release();

		switch (request.get_move_mode())
		{

		case DomainPTU::PTUMoveFlag::PAN_ABSOLUTE:
			status = movePanAbs(request.get_pan());
			break;

		case DomainPTU::PTUMoveFlag::PAN_RELATIVE:
			status = movePanOff(request.get_pan());
			break;

		case DomainPTU::PTUMoveFlag::TILT_ABSOLUTE:
			status = moveTiltAbs(request.get_tilt());
			break;

		case DomainPTU::PTUMoveFlag::TILT_RELATIVE:
			status = moveTiltOff(request.get_tilt());
			break;

		case DomainPTU::PTUMoveFlag::PAN_TILT_ABSOLUTE:
			status = moveToAbsPos(request.get_pan(), request.get_tilt());
			break;

		case DomainPTU::PTUMoveFlag::PAN_TILT_RELATIVE:
			status = moveToOffPos(request.get_pan(), request.get_tilt());
			break;

		case DomainPTU::PTUMoveFlag::POSITION_ROBOT:
			status = lookPointRobot(request);
			break;

		case DomainPTU::PTUMoveFlag::POSITION_WORLD:
			status = lookPointWorld(request);
			break;

		}
		answer.set_status(status);
	} else
	{
		answer.set_status(DomainPTU::PTUMoveStatus::FAILURE);
	}

	posChanged = true;
}

PtuTask::PTUStatus PtuTask::lookPointRobot(const DomainPTU::CommPTUMoveRequest& request)
{
	arma::mat offset;
	arma::vec point(4);
	point[3] = 1;

	offset = COMP->sensorOffset.getHomogeneousMatrix();
	request.get_position(point[0], point[1], point[2]);
	point = inv(ptuRobotOffset) * inv(offset) * point;

	double radius = sqrt(pow(point[0], 2) + pow(point[1], 2) + pow(point[2], 2));
	double pan = atan2(point[1], point[0]);
	double tilt = -1* (acos (point[2] / radius) - M_PI_2);

	return moveToAbsPos(pan, tilt);
}

PtuTask::PTUStatus PtuTask::lookPointWorld(const DomainPTU::CommPTUMoveRequest& request)
{
	CommBasicObjects::CommVoid voidRequest;
	CommBasicObjects::CommBaseState baseState;

	Smart::StatusCode statusCode;
	arma::mat offset;
	arma::mat robotPose;
	arma::vec point(4);
	point[3] = 1;

	if (COMP->getGlobalState().getBase().getOn_base())
	{
		statusCode = COMP->baseStateQueryClient->query(voidRequest, baseState);
		if (statusCode != Smart::SMART_OK)
		{
			std::cerr << "ERROR during base get update state: " << Smart::StatusCodeConversion(statusCode) << "\n";
			return DomainPTU::PTUMoveStatus::FAILURE;
		}
		robotPose = baseState.get_base_position().get_base_pose3d().getHomogeneousMatrix();
	} else
	{
		robotPose = default_base_position.get_base_pose3d().getHomogeneousMatrix();
	}

	std::cout << "robot Pose: " << robotPose << std::endl;

	offset = COMP->sensorOffset.getHomogeneousMatrix();
	request.get_position(point[0], point[1], point[2]);
	point = inv(robotPose) * inv(ptuRobotOffset) * inv(offset) * point;

	double radius = sqrt(pow(point[0], 2) + pow(point[1], 2) + pow(point[2], 2));
	double pan = atan2(point[1], point[0]);
	double tilt = -1* (acos (point[2] / radius) - M_PI_2);

	return moveToAbsPos(pan, tilt);
}

void PtuTask::getPos(double& pan, double& tilt)
{

	if (posChanged)
	{
		SmartACE::SmartGuard guard(COMP->ptuMutex);
		ptu.absPosQ(CPtuDPerception::Pan, currentPan);
		ptu.absPosQ(CPtuDPerception::Tilt, currentTilt);
		guard.release();
		posChanged = false;
	}

	pan = currentPan;
	tilt = currentTilt;
}

void PtuTask::startPTU()
{
	ptuActive = true;
}

void PtuTask::stopPTU()
{
	ptuActive = false;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	ptu.haltAll();
	guard.release();

	if (COMP->getGlobalState().getPTU().getVerbose())
	{
		std::cout << ">> PTU halted\n";
	}
}

PtuTask::PTUStatus PtuTask::movePanAbs(double pan)
{
	std::cout << "[absolute] pan: " << pan << "\n";

	PTUStatus status = PTUStatus::GOAL_REACHED;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		// check if angle is in limits
		ptu.clearErrors();
		if (!ptu.moveToAbsPos(CPtuDPerception::Pan, pan))
		{
			checkForErros(status, PAN);
			return status;
		}
		this->commandedPan = pan;
		waitTillPosReached(status);

	}
	guard.release();
	return status;
}

PtuTask::PTUStatus PtuTask::movePanOff(double pan)
{
	std::cout << "[relative] pan: " << pan << "\n";

	PTUStatus status = PTUStatus::GOAL_REACHED;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		// check if angle is in limits
		if (!ptu.moveToOffPos(CPtuDPerception::Pan, pan))
		{
			checkForErros(status, PAN);
			return status;
		}
		this->commandedPan += pan;
		waitTillPosReached(status);

	}
	guard.release();

	return status;
}

PtuTask::PTUStatus PtuTask::moveTiltAbs(double tilt)
{
	std::cout << "[absolute] tilt: " << tilt << "\n";

	PTUStatus status = PTUStatus::GOAL_REACHED;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		// check if angle is in limits
		if (!ptu.moveToAbsPos(CPtuDPerception::Tilt, tilt))
		{
			checkForErros(status, TILT);
			return status;
		}
		this->commandedTilt = tilt;
		waitTillPosReached(status);

	}
	guard.release();

	return status;
}

PtuTask::PTUStatus PtuTask::moveTiltOff(double tilt)
{
	std::cout << "[relative] tilt: " << tilt << "\n";

	PTUStatus status = PTUStatus::GOAL_REACHED;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		// check if angle is in limits

		if (!ptu.moveToOffPos(CPtuDPerception::Tilt, tilt))
		{
			checkForErros(status, TILT);
			return status;
		}
		this->commandedTilt += tilt;
		waitTillPosReached(status);

	}
	guard.release();

	return status;
}

PtuTask::PTUStatus PtuTask::moveToAbsPos(double pan, double tilt)
{
	std::cout << "[absolute] pan: " << pan << ", tilt: " << tilt << "\n";

	PTUStatus status = PTUStatus::GOAL_REACHED;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		// check if angle is in limits


		if (!ptu.moveToAbsPos(CPtuDPerception::Pan, pan))
		{
			checkForErros(status, PAN);
			return status;
		}
		if (!ptu.moveToAbsPos(CPtuDPerception::Tilt, tilt))
		{
			checkForErros(status, TILT);
			return status;
		}
		this->commandedPan = pan;
		this->commandedTilt = tilt;
		waitTillPosReached(status);

	}
	guard.release();
        std::cout<<"[absolute done]"<<std::endl;

	return status;
}

PtuTask::PTUStatus PtuTask::moveToOffPos(double pan, double tilt)
{
	std::cout << "[relative] pan: " << pan << ", tilt: " << tilt << "\n";

	PTUStatus status = PTUStatus::GOAL_REACHED;
	SmartACE::SmartGuard guard(COMP->ptuMutex);
	{
		// check if angle is in limits


		if (!ptu.moveToOffPos(CPtuDPerception::Pan, pan))
		{
			checkForErros(status, PAN);
			return status;
		}
		if (!ptu.moveToOffPos(CPtuDPerception::Tilt, tilt))
		{
			checkForErros(status, TILT);
			return status;
		}
		this->commandedPan += pan;
		this->commandedTilt += tilt;
		waitTillPosReached(status);

	}
	guard.release();

	return status;
}

void PtuTask::waitTillPosReached(PTUStatus& status)
{

   if(Smart::SMART_OK == COMP->stateSlave->tryAcquire("move")) {

	uint32_t tries = 0;
	while (ptuActive && tries < waitTries)
	{
		ptu.clearErrors();
		ptu.aWait();

		if (!ptu.timeoutError())
		{
			checkForErros(status, NONE);
			COMP->stateSlave->release("move");
			return;
		}
		tries++;
	}

	checkForErros(status, NONE);

	COMP->stateSlave->release("move");
   }

}

void PtuTask::checkForErros(PTUStatus& status, PTUAxis axis)
{

	// check if there is an error
	if (!ptu.noError() || !ptuActive)
	{

		if (ptu.maxLimitError() || ptu.minLimitError() || ptu.outOfRange())
		{
			if (status == PTUStatus::GOAL_REACHED && axis == PAN)
			{
				status = PTUStatus::PAN_OUT_OF_RANGE;
			} else if (status == PTUStatus::GOAL_REACHED && axis == TILT)
			{
				status = PTUStatus::TILT_OUT_OF_RANGE;
			} else if (status == PTUStatus::TILT_OUT_OF_RANGE && axis == PAN)
			{
				status = PTUStatus::PAN_TILT_OUT_OF_RANGE;
			} else if (status == PTUStatus::PAN_OUT_OF_RANGE && axis == TILT)
			{
				status = PTUStatus::PAN_TILT_OUT_OF_RANGE;
			}
		} else if (!ptuActive)
		{
			ptu.haltAll();
			status = PTUStatus::HALTED;
		} else
		{
			status = PTUStatus::FAILURE;
		}

		if (COMP->getGlobalState().getPTU().getVerbose())
		{
			// check if errors occurred during movement
			std::cout << ">> PTU Error: " << ptu.checkErrors() << "\n";
		}

		// clear all errors
		ptu.clearErrors();
	}
}
