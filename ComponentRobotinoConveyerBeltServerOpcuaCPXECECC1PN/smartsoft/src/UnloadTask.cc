//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2014 Matthias Lutz
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "UnloadTask.hh"
#include "ComponentRobotinoConveyerBeltServerOpcuaCPXECECC1PN.hh"

#include <iostream>

#include <future>
#include <thread>
#include <chrono>
UnloadTask::UnloadTask(SmartACE::SmartComponent *comp) 
:	UnloadTaskCore(comp)
{
	std::cout << "constructor UnLoadTask\n";
	box_present_bit = 0;
	unload_signal_bit = 0;
	if(COMP->getGlobalState().getRobot().getSignal_unloading_dout()>=0){
		unload_signal_bit = COMP->getGlobalState().getRobot().getSignal_unloading_dout();
	}


}
UnloadTask::~UnloadTask() 
{
	std::cout << "destructor UnloadTask\n";
}



int UnloadTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	box_present_bit = COMP->getGlobalState().getRobot().getBox_present_din();
	return 0;
}

void UnloadTask::resetAbortFlag() {
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	abortFlag = false;
}

bool UnloadTask::getAbortFlag() {
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	return abortFlag;
}

void UnloadTask::setAbortFlag() {
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	abortFlag = true;
}


int UnloadTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;
	OPCUA::StatusCode opcuaStatus;
	CommRobotinoObjects::RobotinoConveyerBeltEventState eventState;


	status = COMP->stateSlave->acquire("unload");
	COMP->stateSlave->release("unload");

	std::cout<<"[UnLoadTask]: start..."<<std::endl;



	if (status == Smart::SMART_OK)
	{
		COMP->triggerUnLoad.acquire();


		ParameterStateStruct localState = COMP->getGlobalState();
		float unloadDirection = localState.getRobot().getUnload_motor_direction();
		bool signalUnLoading = (localState.getRobot().getSignal_unloading_dout()>=0);
		int station_id = localState.getSetStationID().getId();
		std::string station_addr;
		bool passiveStation = false;

		std::list<std::string> stationsList = localState.getOPCUAstatic().getServer_address();
		std::vector<std::string> stationsVector{ std::begin(stationsList), std::end(stationsList)};

		if(station_id >= 0 && station_id < stationsVector.size()){
			station_addr = stationsVector.at(station_id);
			std::cout<<"[UnLoadTask] station id: "<<station_id<<" station_addr: "<<station_addr<<std::endl;

			//deal with passive drop of stations
			if(localState.getRobot().getIgnore_station_communication() ==true){
				passiveStation = true;
			} else if (station_addr.compare("PASSIVE_STATION") == 0)
			{
				passiveStation = true;
			} else
			{
				passiveStation = false;
			}
		} else
		{
			std::cout<<"ERROR invalid station id: "<<station_id<<" - stationsVector size: "<<stationsVector.size()<<std::endl;
			station_addr = "opc.tcp://0.0.0.0:4840";
		}

		if(this->getAbortFlag() == true){
			return 0;
		}


		if (queryDigitalInput(box_present_bit)!=true)
		{
			eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_ERROR_NO_BOX);
			COMP->loadEventServer->put(eventState);
			std::cout<<"[UnLoadTask] ERROR: unloading triggered - no box on the belt!"<<std::endl;
			COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));
		}
		else
		{

			std::cout<<__LINE__<<std::endl;
			//1. Connect to Station
			opcuaStatus = this->beltClient.connect(station_addr,localState.getOPCUAstatic().getRootObjectPath());
			std::cout<<"[UnLoadTask] connect: "<<opcuaStatus<<std::endl;
			//TODO
			//this sleep might help the OPC server to sort things
			ACE_OS::sleep(ACE_Time_Value(1,0));

			if (passiveStation == true || opcuaStatus == OPCUA::StatusCode::ALL_OK)//Trans_ready is the signal from Transport Station
			{
				std::cout<<"[UnLoadTask] unloading"<<std::endl;//assuming the programm cycle time is 1ms
				if(passiveStation == true)
				{
					//no station case
					for(unsigned int i=0;i<localState.getRobot().getIgnore_station_communication_unload_time_sec()*4;++i)
					{
						if(signalUnLoading == true){
							queryDigitalOutput(unload_signal_bit,true);
						}
						std::cout<<"[UnLoadTask] Still in the loop"<<std::endl;
						//sleep till the box is loaded
						COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(50.0*unloadDirection));
						ACE_OS::sleep(ACE_Time_Value(0,250000));

						if(getAbortFlag() == true) {
							std::cout<<"[UnLoadTask] Abort Loop!"<<std::endl;
							break;
						}
					}
				}
				else
				{
					//normal case (communication with station)

					std::cout<<__LINE__<<std::endl;
					//4. Command Station to receive the Box
					std::string callResult;

					//TODO THE status code will be ERROR_COMMUNICATION FOR WHAT EVER REASON?
					//std::cout<<"[UnLoadTask] Calling loadbox async..."<<std::endl;
//					auto future = std::async(std::launch::async, &OPCUA::ProductionStation::callLoadbox, &beltClient,10,std::ref(callResult));


					this->beltClient.setMotor_timeout(10);
					this->beltClient.setLoadbox(true);
					bool unloadingstatus = this->beltClient.getLoadbox();
					std::cout<<"unloadingstatus = "<<unloadingstatus<<std::endl;

					//loop till the station send done
					bool stations_done = false;

					//auto status = future.wait_for(std::chrono::microseconds(0));
                    long int counter =0;
					while(beltClient.getMethod_result() != "SUCCESS")//(this->beltClient.getLoadbox())
					{
						std::cout<<"beltClient.getLoadbox() = "<<beltClient.getLoadbox()<<std::endl;
						if(signalUnLoading == true){
							queryDigitalOutput(unload_signal_bit,true);
						}
						std::cout<<"[UnLoadTask] Still in the loop"<<std::endl;
						//sleep till the box is loaded
						COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(50.0*unloadDirection));
						ACE_OS::sleep(ACE_Time_Value(0,250000));

						if(getAbortFlag() == true)
						{
							std::cout<<"[UnLoadTask] Abort Loop!"<<std::endl;
							break;
						}

						//if (productionStation->getMethod_result().compare("Success")) break;
						//if (beltClient.getMethod_result().compare("Error")) break;

                      ++counter;


						//status = future.wait_for(std::chrono::microseconds(0));
					}

					//auto result = future.get();
					//std::cout<<"[UnLoadTask] loadbox call result: "<<beltClient.getMethod_result()<<" value: "<<callResult<<std::endl;
				}
				COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));
				if(signalUnLoading == true){
					queryDigitalOutput(unload_signal_bit,false);
				}
				std::cout<<"[UnLoadTask] Loop done"<<std::endl;


				if (queryDigitalInput(box_present_bit)!=true){
					eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_DONE);
					COMP->loadEventServer->put(eventState);
					std::cout<<"[UnLoadTask] Load EVENT CONVEYER_BELT_UNLOAD_DONE FIRED!"<<std::endl;
				} else {
					eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_ERROR_BOX_STILL_PRESENT);
					COMP->loadEventServer->put(eventState);
					std::cout<<"[UnLoadTask] ERROR BOX UNLOADED FAILED!"<<std::endl;
				}
			}else {
				eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_ERROR_NO_RESPONSE_FROM_STATION);
				COMP->loadEventServer->put(eventState);
				std::cout<<"[unloadTask] ERROR: No trans ready from Station!"<<std::endl;
				COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));

			}

			//5. Disconnect from Station
			beltClient.disconnect();
		}

	}// if (status == CHS::SMART_OK) <<<---- status = state->acquire("moverobot");

	std::cout<<"[UnLoadTask]: ...stop"<<std::endl;

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int UnloadTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

bool UnloadTask::queryDigitalInput(const unsigned int & bit){

	CommRobotinoObjects::CommRobotinoIOValues inputQuery;
	CommRobotinoObjects::CommRobotinoIOValues inputQueryResult;


	Smart::StatusCode status;
	status = COMP->iOQueryClient->query(inputQuery,inputQueryResult);
	if(status != Smart::SMART_OK){
		std::cout<<__FUNCTION__<<"[UnLoadTask] ERROR: query digital IO"<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
		return false;
	}
	if(bit>inputQueryResult.getDigitalInputValuesSize()){
		std::cout<<__FUNCTION__<<"[UnLoadTask] ERROR: query bit: "<<bit<<" digital IO size: "<<inputQueryResult.getDigitalInputValuesSize()<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
		return false;
	}
	return inputQueryResult.getDigitalInputValuesElemAtPos(bit);

}

void UnloadTask::queryDigitalOutput(const unsigned int & bit, const bool & value){

	CommRobotinoObjects::CommRobotinoIOValues outputQuery;
	CommRobotinoObjects::CommRobotinoIOValues dummy;
	outputQuery.resizeDigitalOutputValues(1);

	Smart::StatusCode status;
	CommRobotinoObjects::CommDigitalOutputRequest digitalOutputRequest(bit,value);

	outputQuery.setDigitalOutputValuesElemAtPos(0,digitalOutputRequest);

	status = COMP->iOQueryClient->query(outputQuery,dummy);
	if(status != Smart::SMART_OK){
		std::cout<<__FUNCTION__<<"[UnLoadTask] ERROR: query digital IO"<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
	}

}
