//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2014 Matthias Lutz
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "LoadTask.hh"
#include "ComponentRobotinoConveyerBeltServerOpcuaCPXECECC1PN.hh"
#include "CommRobotinoObjects/CommRobotinoIOValues.hh"

#include <iostream>

LoadTask::LoadTask(SmartACE::SmartComponent *comp) 
:	LoadTaskCore(comp)
{
	std::cout << "constructor LoadTask\n";
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	abortFlag = false;
	box_present_bit = 0;
	load_signal_bit = 0;


}
LoadTask::~LoadTask() 
{
	std::cout << "destructor LoadTask\n";
}



int LoadTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	box_present_bit = COMP->getGlobalState().getRobot().getBox_present_din();
	if(COMP->getGlobalState().getRobot().getSignal_unloading_dout()>=0){
		load_signal_bit = COMP->getGlobalState().getRobot().getSignal_loading_dout();
	}

	return 0;
}

void LoadTask::resetAbortFlag()
{
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	abortFlag = false;
}

bool LoadTask::getAbortFlag ()
{
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	return abortFlag;
}

void LoadTask::setAbortFlag ()
{
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	abortFlag = true;
}

int LoadTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	// to get the incoming data, use this methods:
	Smart::StatusCode status;
	OPCUA::StatusCode opcuaStatus;
	CommRobotinoObjects::RobotinoConveyerBeltEventState eventState;

	status = COMP->stateSlave->acquire("load");
	COMP->stateSlave->release("load");

	std::cout<<"[LoadTask]: start..."<<std::endl;

	if (status == Smart::SMART_OK)
	{
		COMP->triggerLoad.acquire();

		ParameterStateStruct localState = COMP->getGlobalState();
		float loadDirection = localState.getRobot().getLoad_motor_direction();
		bool signalLoading = (localState.getRobot().getSignal_loading_dout()>=0);
		int station_id = localState.getSetStationID().getId();
		std::string station_addr;

		std::list<std::string> stationsList = localState.getOPCUAstatic().getServer_address();
		std::vector<std::string> stationsVector{ std::begin(stationsList), std::end(stationsList)};

		if(station_id >= 0 && station_id < stationsVector.size()){
			station_addr = stationsVector.at(station_id);
			std::cout<<"[LoadTask] station id: "<<station_id<<" station_addr: "<<station_addr<<std::endl;
		}
		else
		{
			std::cout<<"ERROR invalid station id: "<<station_id<<" - stationsVector size: "<<stationsVector.size()<<std::endl;
			station_addr = "opc.tcp://0.0.0.0:4840";
		}

		if (queryDigitalInput(box_present_bit)==true)
		{
			std::cout << "station_addr = " << station_addr <<std::endl;
			eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_BOX_ADREADY_PRSESENT);
			COMP->loadEventServer->put(eventState);
			std::cout<<"[LoadTask] ERROR: loading triggered - box already on the belt!"<<std::endl;
			COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0));
		}
		else
		{
			//1. Connect to Station
			std::cout<<"station_addr: "<<station_addr <<std::endl;
			std::cout<<"localState.getOPCUAstatic().getObject_name(): "<<localState.getOPCUAstatic().getObject_name() <<std::endl;
			//OPCUA::StatusCode StatusCode = this->ProductionStation.connect(station_addr, localState.getOPCUAstatic().getObject_name(), 1);
			OPCUA::StatusCode StatusCode = this->ProductionStation.connect(station_addr, localState.getOPCUAstatic().getRootObjectPath(), 1);

			std::cout<<"connect: "<<StatusCode <<std::endl;

			//TODO
			//this sleep might help the OPC server to sort things
			ACE_OS::sleep(ACE_Time_Value(1,0));
			//TODO
			//2. Check if Station is ready?

			if (localState.getRobot().getIgnore_station_communication() )//Trans_ready is the signal from Transport Station
			{
				std::cout<<"[LoadTask] loading status code is "<< StatusCode <<std::endl;//assuming the programm cycle time is 1ms
				//3. Command Station to send the Box
				std::string callResult;
				//auto opc_statusCode = this->ProductionStation->callStart_unloading(10,callResult);

				//if()
				{
					std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
					eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_RESPONSE_FROM_STATION);
					COMP->loadEventServer->put(eventState);
					COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));

				}
				//std::cout<<"[loadTask] beltClient.callStart_unloading - status: "<<opc_statusCode<<" callresult:  "<<callResult<<std::endl;
				//if(opc_statusCode != OPCUA::StatusCode::ALL_OK || callResult != "UNLOADING_STARTED"){
				//	std::cout<<"[loadTask] OPC CALL failed or returned error --> call stop and break."<<std::endl;
				//this->ProductionStation->callStop_unloading(1,callResult);

			}
			else
			{
				//the normal case
				std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
				if(signalLoading == true)
				{
					queryDigitalOutput(load_signal_bit,true);
				}

				this->ProductionStation.setMotor_timeout(10);
				this->ProductionStation.setStart_unloading(true);
				bool unloadingstatus = this->ProductionStation.getStart_unloading();
				std::cout<<"unloadingstatus: "<<unloadingstatus <<std::endl;


				while(counter <(localState.getRobot().getBelt_time_out_sec()*10))
				{
					std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
					//sleep till the box is loaded
					COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(-50.0*loadDirection));
					ACE_OS::sleep(ACE_Time_Value(0,100000));
					counter++;

					if(queryDigitalInput(box_present_bit)==true){
						unsigned int counter2 = 0;
						std::cout<<"[LoadTask] Box found"<<std::endl;
						while(counter2<10)
						{
							COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(-50.0*loadDirection));
							ACE_OS::sleep(ACE_Time_Value(0,100000));
							counter2++;
						}
						std::cout<<"[LoadTask] Box found --> break"<<std::endl;
						break;
					}
					std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;

					if(getAbortFlag() == true){
						std::cout<<"[LoadTask] Abort Loop!"<<std::endl;
						break;
					}
				}

				COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));
				if(signalLoading == true){
					queryDigitalOutput(load_signal_bit,false);
				}
				std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
				//4. Send Station box received
				//opc_statusCode = this->ProductionStation->callStop_unloading(1,callResult);


				this->ProductionStation.setStop_unloading(true);
				std::string str =   (std::string)this->ProductionStation.getMethod_result();

				std::cout<<"[loadTask] beltClient.callStop_unloading - status: "<< StatusCode <<std::endl;

				if (queryDigitalInput(box_present_bit)==true){
					std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
					eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_DONE);
					COMP->loadEventServer->put(eventState);
					std::cout<<"[LoadTask] Load EVENT CONVEYER_BELT_LOAD_DONE FIRED!"<<std::endl;
				}
				else {
					std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
					eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_BOX_LOADED);
					COMP->loadEventServer->put(eventState);
					std::cout<<"[LoadTask] ERROR BOX LOADED FAILED!"<<std::endl;
				}
			}
			std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;

			eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_RESPONSE_FROM_STATION);
			COMP->loadEventServer->put(eventState);

			std::cout<<"[loadTask] ERROR: No trans ready from Station!"<<std::endl;
			COMP->powerOutPutSendClient->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));

			//5. Disconnect from Station
			this->ProductionStation.disconnect();
		}
		std::cout<<__FUNCTION__<<" : "<<__LINE__ <<std::endl;
	std::cout<<"[LoadTask]: ...stop"<<std::endl;
	}
	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}


int LoadTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

bool LoadTask::queryDigitalInput(const unsigned int & bit){

	CommRobotinoObjects::CommRobotinoIOValues inputQuery;
	CommRobotinoObjects::CommRobotinoIOValues inputQueryResult;


	Smart::StatusCode status;
	status = COMP->iOQueryClient->query(inputQuery,inputQueryResult);

	if(status != Smart::SMART_OK){
		std::cout<<__FUNCTION__<<"[LoadTask] ERROR: query digital IO"<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
		return false;
	}
	if(bit>inputQueryResult.getDigitalInputValuesSize()){
		std::cout<<__FUNCTION__<<"[LoadTask] ERROR: query bit: "<<bit<<" digital IO size: "<<inputQueryResult.getDigitalInputValuesSize()<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
		return false;
	}
	return inputQueryResult.getDigitalInputValuesElemAtPos(bit);

}

void LoadTask::queryDigitalOutput(const unsigned int & bit, const bool & value){

	CommRobotinoObjects::CommRobotinoIOValues outputQuery;
	CommRobotinoObjects::CommRobotinoIOValues dummy;
	outputQuery.resizeDigitalOutputValues(1);

	Smart::StatusCode status;
	CommRobotinoObjects::CommDigitalOutputRequest digitalOutputRequest(bit,value);

	outputQuery.setDigitalOutputValuesElemAtPos(0,digitalOutputRequest);

	status = COMP->iOQueryClient->query(outputQuery,dummy);
	if(status != Smart::SMART_OK){
		std::cout<<__FUNCTION__<<"[LoadTask] ERROR: query digital IO"<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
	}

}
