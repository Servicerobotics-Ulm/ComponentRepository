//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain Version 0.10.3
// The SmartSoft Toolchain has been developed by:
//
// ZAFH Servicerobotic Ulm
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// smart-robotics.sourceforge.net
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//BSD 3-Clause License
//
//  Copyright (C) Servicerobotics Ulm
//  University of Applied Sciences Ulm
//  Prittwitzstr. 10
//  89075 Ulm
//  Germany
//  All rights reserved.
//
//  Author: Nayabrasul Shaik
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//
//* Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//
//* Redistributions in binary form must reproduce the above copyright notice,
//  this list of conditions and the following disclaimer in the documentation
//  and/or other materials provided with the distribution.
//
//* Neither the name of the copyright holder nor the names of its
//  contributors may be used to endorse or promote products derived from
//  this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "VisualizationHelper.hh"

#include <sstream>

#include "msg_conversion.hh"
#ifdef WITH_OLD_MRPT_VERSION
#elif WITH_MRPT_2_0_VERSION
#include <mrpt/img/CImage.h>
#include <mrpt/obs/CObservation2DRangeScan.h>
#include <mrpt/opengl/CPlanarLaserScan.h>
#include <mrpt/opengl/CCylinder.h>
#else
#include <mrpt/opengl/CPlanarLaserScan.h>
#endif

#ifdef WITH_OPENCV_4_2_VERSION
#include <Eigen/Dense>
#else
#endif

VisualizationHelper::VisualizationHelper() {
}

void VisualizationHelper::initializeVisualization(){
	grid3D = new CDisplayWindow3D();
	grid3D->setWindowTitle("Cartographer");
	grid3D->resize(800, 600);
}
#ifdef WITH_MRPT_2_0_VERSION
void VisualizationHelper::initObjects() {

	mrpt::opengl::COpenGLScene::Ptr ptrScene = grid3D->get3DSceneAndLock();
	{
		opengl::CAxis::Ptr axis = opengl::CAxis::Create(-10, -10, 0, 10, 10, 1,
				1, 1, true);
		axis->setName("axis");
		axis->setColor(0, 0, 0);
		ptrScene->insert(axis);

		opengl::CCylinder::Ptr cylinder = std::make_shared<opengl::CCylinder>(0.2f, 0.2f, 0.4f, 10);
		cylinder->setName("robot");
		cylinder->setColor(0, 0, 1);
		ptrScene->insert(cylinder);

		//		opengl::CArrowPtr robotArrow = opengl::CArrow::Create(0, 0, 0, 0.2, 0, 0);
		//		robotArrow->setColor(0, 0, 1);
		//		robotArrow->setName("robotOrientation");
		//		ptrScene->insert(robotArrow);

		opengl::CPlanarLaserScan::Ptr scan = opengl::CPlanarLaserScan::Create();
		scan->setName("scan");
		ptrScene->insert(scan);

		opengl::CPointCloudColoured::Ptr particles =
				opengl::CPointCloudColoured::Create();
		particles->setName("particles");
		particles->setPointSize(3);
		ptrScene->insert(particles);

		opengl::CSetOfLines::Ptr particleLines = opengl::CSetOfLines::Create();
		particleLines->setName("particleLines");
		ptrScene->insert(particleLines);

		opengl::CPointCloudColoured::Ptr hypotheses =
				opengl::CPointCloudColoured::Create();
		hypotheses->setName("hypotheses");
		hypotheses->setPointSize(10);
		ptrScene->insert(hypotheses);

		opengl::CText::Ptr robotText = opengl::CText::Create();
		robotText->setName("robotLabel");
		robotText->setColor(0, 0, 0);
		ptrScene->insert(robotText);

	}
	grid3D->unlockAccess3DScene();
	grid3D->forceRepaint();
}
#else
void VisualizationHelper::initObjects() {

	opengl::COpenGLScenePtr &ptrScene = grid3D->get3DSceneAndLock();
	{
		opengl::CAxisPtr axis = opengl::CAxis::Create(-10, -10, 0, 10, 10, 1,
				1, 1, true);
		axis->setName("axis");
		axis->setColor(0, 0, 0);
		ptrScene->insert(axis);

		opengl::CCylinderPtr cylinder = opengl::CCylinder::Create(0.2, 0.2, 0.4, 10, 10);
		cylinder->setName("robot");
		cylinder->setColor(0, 0, 1);
		ptrScene->insert(cylinder);

		//		opengl::CArrowPtr robotArrow = opengl::CArrow::Create(0, 0, 0, 0.2, 0, 0);
		//		robotArrow->setColor(0, 0, 1);
		//		robotArrow->setName("robotOrientation");
		//		ptrScene->insert(robotArrow);

		opengl::CPlanarLaserScanPtr scan = opengl::CPlanarLaserScan::Create();
		scan->setName("scan");
		ptrScene->insert(scan);

		opengl::CPointCloudColouredPtr particles =
				opengl::CPointCloudColoured::Create();
		particles->setName("particles");
		particles->setPointSize(3);
		ptrScene->insert(particles);

		opengl::CSetOfLinesPtr particleLines = opengl::CSetOfLines::Create();
		particleLines->setName("particleLines");
		ptrScene->insert(particleLines);

		opengl::CPointCloudColouredPtr hypotheses =
				opengl::CPointCloudColoured::Create();
		hypotheses->setName("hypotheses");
		hypotheses->setPointSize(10);
		ptrScene->insert(hypotheses);

		opengl::CTextPtr robotText = opengl::CText::Create();
		robotText->setName("robotLabel");
		robotText->setColor(0, 0, 0);
		ptrScene->insert(robotText);

	}
	grid3D->unlockAccess3DScene();
	grid3D->forceRepaint();
}
#endif

VisualizationHelper::~VisualizationHelper() {
	std::cout<<"Destructor VisualizationHelper..."<<std::endl;
	try{
		if(grid3D != NULL){
			std::cout<<"delete grid3D"<<std::endl;
			delete grid3D;
		}
	}
	catch (std::exception &e)
	{
			std::cerr << e.what() << std::endl << "Program finished for an exception!!" << std::endl;
	}
	catch (...)
	{
			std::cerr << "Untyped exception!!" << std::endl;
	}
	std::cout<<"Destructor VisualizationHelper.DONE"<<std::endl;
}

void VisualizationHelper::clear() {
#ifdef WITH_MRPT_2_0_VERSION
	opengl::COpenGLScene::Ptr &ptrScene = grid3D->get3DSceneAndLock();
#else
	opengl::COpenGLScenePtr &ptrScene = grid3D->get3DSceneAndLock();
#endif
	{
		ptrScene->clear();
	}
	grid3D->unlockAccess3DScene();
	grid3D->forceRepaint();
}



void VisualizationHelper::displayLaserScan(
		const CommBasicObjects::CommMobileLaserScan& scan) {
	if(scan.get_scan_size()<2){
		std::cout<<"WARNING: [VisualizationHelper] scan size <2 skip scan..."<<std::endl;
		return;

	}

#ifdef WITH_OLD_MRPT_VERSION
	CObservation2DRangeScan s;
#else
	obs::CObservation2DRangeScan s;
#endif

	CommBasicObjects::CommPose3d bp =
			scan.get_base_state().get_base_position().get_base_pose3d();
	CommBasicObjects::CommPose3d sp = scan.get_sensor_pose();

	poses::CPose3D pBase(bp.get_x(1), bp.get_y(1), bp.get_z(1), bp.get_azimuth(),
			bp.get_elevation(), bp.get_roll());
	poses::CPose3D pSensor(sp.get_x(1), sp.get_y(1), sp.get_z(1), sp.get_azimuth(),
			sp.get_elevation(), sp.get_roll());

	size_t numScans = scan.get_scan_size();
	double resolution = scan.get_scan_resolution();
	double startAngle = pi_to_pi(scan.get_scan_start_angle());
	int max_scan_size = scan.get_max_scan_size();
	double endAngle = pi_to_pi(startAngle+(max_scan_size*resolution));

#if defined (WITH_MRPT_1_5_VERSION) || (WITH_MRPT_2_0_VERSION)
	s.resizeScan(max_scan_size);
#else
	s.scan.resize(max_scan_size);
	s.validRange.resize(max_scan_size, 0);
#endif

	s.aperture = fabs(endAngle - startAngle);
	s.maxRange = scan.get_max_distance(1.0);
	s.sensorPose = pBase + pSensor;

	for (size_t i = 0; i < numScans; ++i) {
		int index = fabs(pi_to_pi(scan.get_scan_angle(i)) - startAngle) / resolution;

#if defined (WITH_MRPT_1_5_VERSION) || (WITH_MRPT_2_0_VERSION)
			s.setScanRange(index, scan.get_scan_distance(i, 1));
			s.setScanRangeValidity(index, true);
#else
			s.scan[index] = scan.get_scan_distance(i, 1.0);
			s.validRange[index] = 1;
#endif

	}
#ifdef WITH_MRPT_2_0_VERSION
	opengl::COpenGLScene::Ptr ptrScene = grid3D->get3DSceneAndLock();
	{
		opengl::CPlanarLaserScan::Ptr sPtr = std::dynamic_pointer_cast<opengl::CPlanarLaserScan>(ptrScene->getByName("scan"));
		sPtr->setScan(s);
	}
#else
	opengl::COpenGLScenePtr &ptrScene = grid3D->get3DSceneAndLock();
	{
		opengl::CPlanarLaserScanPtr sPtr =
				(opengl::CPlanarLaserScanPtr) ptrScene->getByName("scan");
		sPtr->setScan(s);
	}
#endif
	grid3D->unlockAccess3DScene();
	grid3D->forceRepaint();
}



void VisualizationHelper::displayCoordinateSystem( poses::CPose3D& pose, double size){
#ifdef WITH_MRPT_2_0_VERSION
	opengl::COpenGLScene::Ptr theScene = grid3D->get3DSceneAndLock();
	opengl::CSetOfObjects::Ptr corner = opengl::stock_objects::CornerXYZSimple(size,2.0);
	{
		corner->setPose(pose);
		theScene->insert(corner);
	}
#else
		opengl::COpenGLScenePtr &theScene = grid3D->get3DSceneAndLock();
		opengl::CSetOfObjectsPtr corner = opengl::stock_objects::CornerXYZSimple(size,2.0);
		{
		corner->setPose(pose);
		theScene->insert(corner);
		}
#endif
		grid3D->unlockAccess3DScene();
		grid3D->forceRepaint();

}

void VisualizationHelper::displayBase(const CommBasicObjects::CommBasePose& pos) {
	CommBasicObjects::CommPose3d p = pos.get_base_pose3d();
	poses::CPose3D pose(p.get_x(1.0), p.get_y(1.0), p.get_z(1.0), p.get_azimuth(),
			p.get_elevation(), p.get_roll());
	poses::CPose3D poseLabel(p.get_x(1.0) - 0.3, p.get_y(1.0) + 1, p.get_z(1.0),
			p.get_azimuth(), p.get_elevation(), p.get_roll());

	std::stringstream labelString;
	labelString << "Pose: x=" << p.get_x(1.0) << ", y=" << p.get_y(1.0)
			<< ", a=" << p.get_azimuth();
#ifdef WITH_MRPT_2_0_VERSION
	opengl::COpenGLScene::Ptr &ptrScene = grid3D->get3DSceneAndLock();
	{
		opengl::CRenderizable::Ptr obj1 = ptrScene->getByName("robot");
		obj1->setPose(pose);

		opengl::CText::Ptr label = std::dynamic_pointer_cast<opengl::CText>(ptrScene->getByName(
				"robotLabel"));
		label->setPose(poseLabel);
		label->setString(labelString.str());

		//		opengl::CRenderizablePtr obj2 = ptrScene->getByName("robotOrientation");
		//		obj2->setPose(pose);
	}
#else
	opengl::COpenGLScenePtr &ptrScene = grid3D->get3DSceneAndLock();
	{
		opengl::CRenderizablePtr obj1 = ptrScene->getByName("robot");
		obj1->setPose(pose);

		opengl::CTextPtr label = (opengl::CTextPtr) ptrScene->getByName(
				"robotLabel");
		label->setPose(poseLabel);
		label->setString(labelString.str());

		//		opengl::CRenderizablePtr obj2 = ptrScene->getByName("robotOrientation");
		//		obj2->setPose(pose);
	}
#endif
	grid3D->unlockAccess3DScene();
	grid3D->forceRepaint();
}

void VisualizationHelper::displayParticles(const std::vector<cartographer::transform::Rigid3d>& poses) {

       std::cout << "Num poses: " << poses.size() << "\n";
#ifdef WITH_MRPT_2_0_VERSION
   	opengl::COpenGLScene::Ptr &ptrScene = grid3D->get3DSceneAndLock();
   	{
   		opengl::CPointCloudColoured::Ptr obj =
   				std::dynamic_pointer_cast<opengl::CPointCloudColoured>(ptrScene->getByName("particles"));
   		obj->clear();

   		opengl::CSetOfLines::Ptr particleLines =
   				std::dynamic_pointer_cast<opengl::CSetOfLines>(ptrScene->getByName("particleLines"));
   		particleLines->clear();
   		particleLines->setColor(0, 1, 0);

        for (int i = 0; i < poses.size(); i++) {

                obj->push_back(poses[i].translation().x(),
                                poses[i].translation().y(), 0, 0, 1, 0);


                double r,p,y;
                toEulerAngle(poses[i].rotation(), r, p, y);

                particleLines->appendLine(poses[i].translation().x(),
                                poses[i].translation().y(), 0, poses[i].translation().x()
                                                + cos(y) * 0.2,
                                                poses[i].translation().y() + sin(y)
                                                * 0.2, 0);

        }

   	}
#else
   	opengl::COpenGLScenePtr &ptrScene = grid3D->get3DSceneAndLock();
        {
               opengl::CPointCloudColouredPtr obj =
                               (opengl::CPointCloudColouredPtr) ptrScene->getByName("particles");
               obj->clear();

               opengl::CSetOfLinesPtr particleLines =
                               (opengl::CSetOfLinesPtr) ptrScene->getByName("particleLines");
               particleLines->clear();
               particleLines->setColor(0, 1, 0);

               for (int i = 0; i < poses.size(); i++) {

                       obj->push_back(poses[i].translation().x(),
                                       poses[i].translation().y(), 0, 0, 1, 0);


                       double r,p,y;
                       toEulerAngle(poses[i].rotation(), r, p, y);

                       particleLines->appendLine(poses[i].translation().x(),
                                       poses[i].translation().y(), 0, poses[i].translation().x()
                                                       + cos(y) * 0.2,
                                                       poses[i].translation().y() + sin(y)
                                                       * 0.2, 0);

               }

        }
#endif
       grid3D->unlockAccess3DScene();
       grid3D->forceRepaint();
}
