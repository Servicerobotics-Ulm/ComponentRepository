//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------


//--------------------------------------------------------------------------
//BSD 3-Clause License
//
//  Copyright (C) Servicerobotics Ulm
//  University of Applied Sciences Ulm
//  Prittwitzstr. 10
//  89075 Ulm
//  Germany
//  All rights reserved.
//
//  Author: Nayabrasul Shaik
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//
//* Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//
//* Redistributions in binary form must reproduce the above copyright notice,
//  this list of conditions and the following disclaimer in the documentation
//  and/or other materials provided with the distribution.
//
//* Neither the name of the copyright holder nor the names of its
//  contributors may be used to endorse or promote products derived from
//  this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#include "CartographerTask.hh"
#include "ComponentCartographer.hh"
#include "msg_conversion.hh"
#include <iostream>
#include "cartographer/mapping/trajectory_builder_interface.h"
#include "cartographer/transform/rigid_transform.h"
#include "cartographer/sensor/point_cloud.h"
#include "cartographer/common/time.h"
#include "cartographer/mapping/id.h"
#include "cartographer/common/configuration_file_resolver.h"
#include "cairo/cairo.h"
// includes for map serialization
#include <fstream>
#ifdef WITH_OPENCV_4_2_VERSION
   	#include <opencv4/opencv2/core.hpp>
	#include <opencv4/opencv2/highgui.hpp>
#else
	#include <cxcore.h>
	#include <highgui.h>
#endif
#include <OpenCVHelpers/OpenCVHelpers.hh>

#include "eigen3/Eigen/Core"

const std::string CartographerTask::laser_id = "scan";
const std::string CartographerTask::odometry_id = "odom";

CartographerTask::CartographerTask(SmartACE::SmartComponent *comp) 
:	CartographerTaskCore(comp)
{
	std::cout << "constructor CartographerTask\n";
}
CartographerTask::~CartographerTask() 
{
	std::cout << "destructor CartographerTask\n";
}

int CartographerTask::on_entry()
{

	//read parameters
	use_laser                       = COMP->getGlobalState().getSensors().getUse_laser();
	use_odometry                    = COMP->getGlobalState().getSensors().getUse_odometry();
	num_subdivisions_per_laser_scan = COMP->getGlobalState().getSensors().getLaser_subdivisions();
	laser_frequency                 = COMP->getGlobalState().getSensors().getLaser_frequency();
	enable_visualization            = COMP->getParameters().getGeneral().getEnable_visualization();
	cartographer_mode               = COMP->getParameters().getState().getPure_localization() == true ? CartographerMode::Localization : CartographerMode::Mapping;
	load_previous_state             = COMP->getParameters().getState().getLoad_previous_state();
	if(load_previous_state)
	previous_state_pbstream         = COMP->getParameters().getState().getPb_stream();

	if(enable_visualization){
		COMP->h.initObjects();
	}

	int argc =1;
	char* arg0 = "ComponentCartographer";
	char** argv = &arg0;

	google::InitGoogleLogging(arg0);
	google::ParseCommandLineFlags(&argc, &argv, true);


	//read the map_builder_options, trajectory_builder_options specified in .ini and set them in cartographer format accordingly
	using CFR = cartographer::common::ConfigurationFileResolver;
	std::unique_ptr<CFR> file_resolver(new CFR(std::vector<std::string>{COMP->getGlobalState().getConfig().getConfig_dir_path()}));

	std::string code;
	if(cartographer_mode == CartographerMode::Mapping)
	{
	code = file_resolver->GetFileContentOrDie("backpack_2d.lua");
	}else if(cartographer_mode == CartographerMode::Localization)
	{
	assert(load_previous_state && "load previous state must be true for localization mode");
	assert(!previous_state_pbstream.empty() && " previous state pbstream is empty");
	code = file_resolver->GetFileContentOrDie("backpack_2d_localization.lua");
	}

	cartographer::common::LuaParameterDictionary lua_parameter_dictionary(code, std::move(file_resolver));
	map_builder_options = cartographer::mapping::CreateMapBuilderOptions(lua_parameter_dictionary.GetDictionary("map_builder").get());
	trajectory_builder_options = cartographer::mapping::CreateTrajectoryBuilderOptions(lua_parameter_dictionary.GetDictionary("trajectory_builder").get());


	assert(map_builder_options.has_pose_graph_options() == true && "No pose graph options");
	assert(trajectory_builder_options.has_trajectory_builder_2d_options() == true && "No trajectory builder options");

	// create instance of MapBuilder
    map_builder.reset(new MapBuilder(map_builder_options));

    //load previous state if supplied
    if(load_previous_state)
    {
    std::map<int,int> trajectory_id_mapping = map_builder->LoadStateFromFile(COMP->getParameters().getState().getPb_stream(), true);

    for(auto current_id_mapping: trajectory_id_mapping)
    std::cout << " trajectory id in proto = " << current_id_mapping.first << " trajectory id = " << current_id_mapping.second <<std::endl;
    }


    if(use_laser)
    expected_sensor_ids.insert(SensorId{SensorType::RANGE, laser_id});


    if(use_odometry)
    expected_sensor_ids.insert(SensorId{SensorType::ODOMETRY, odometry_id});

    // add trajectory builder
    trajectory_id = map_builder->AddTrajectoryBuilder(
                                                        expected_sensor_ids,
														trajectory_builder_options,
                                                        [this](const int trajectory_id,
                                                        const ::cartographer::common::Time time,
                                                        const Rigid3d local_pose,
                                                        RangeData range_data_in_local,
                                                        const std::unique_ptr<const TrajectoryBuilderInterface::InsertionResult>)
                                                        {
                                                          OnLocalSlamResult(trajectory_id, time, local_pose, range_data_in_local);
                                                        });

    std::cout << "Added trajectory with ID '" << trajectory_id << "'.\n";



    trajectory_builder = map_builder->GetTrajectoryBuilder(trajectory_id);

    //TODO add extrapolator for localtrajectorypublishdata
    constexpr double kExtrapolationEstimationTimeSec = 0.001;  // 1 ms
    const double gravity_time_constant = map_builder_options.use_trajectory_builder_3d() ?
    		                               trajectory_builder_options.trajectory_builder_3d_options().imu_gravity_time_constant() :
										   trajectory_builder_options.trajectory_builder_2d_options().imu_gravity_time_constant();

    //TODO add sensor_samplers_ for taking all sensors uniformly

     timer_counter = 0;
     std::cout << "num_trajectory_builders : " << map_builder->num_trajectory_builders() << "'.\n";

	return 0;
}
int CartographerTask::on_execute()
{
	
	//CommBasicObjects::CommMobileLaserScan laserscan; // moved to class member
	CommBasicObjects::CommBaseState basestate;
	Smart::StatusCode status;

	if(use_laser)
	{
	status = COMP->laserServiceIn->getUpdateWait(current_laser_scan);
	if(status == Smart::SMART_OK && current_laser_scan.is_scan_valid())
		AddSensorData_LaserScanMessage(current_laser_scan);
	}

	if(use_odometry)
	{
		if(status == Smart::SMART_OK)
			AddSensorData_OdometryMessage(current_laser_scan.getBase_state().get_base_raw_position(), current_laser_scan.get_scan_time_stamp());
	}

	if(++timer_counter == 50)
	{
	send_currentmap(get_current_map());
	timer_counter = 0;
	}

	return 0;
}
int CartographerTask::on_exit()
{

	return 0;
}

void CartographerTask::OnLocalSlamResult(const int trajectory_id,
		                                 const ::cartographer::common::Time time,
										 const Rigid3d local_pose,
                                         RangeData range_data_in_local)
{
	std::shared_ptr<const LocalSlamData> local_slam_data = std::make_shared<LocalSlamData>(LocalSlamData{time,
		local_pose,
		std::move(range_data_in_local)});

	//local_slam_data_[trajectory_id] = std::move(local_slam_data);

	CommBasicObjects::CommBasePositionUpdate upd;
	CommBasicObjects::CommBasePose old_pos;
	CommBasicObjects::CommBasePose upd_pos;

	//No Cov to set!
	old_pos.set_cov(0, 0, current_laser_scan.get_base_state().get_base_position().get_cov(0,0));
	old_pos.set_cov(1, 1, current_laser_scan.get_base_state().get_base_position().get_cov(1,1));
	old_pos.set_cov(2, 2, current_laser_scan.get_base_state().get_base_position().get_cov(2,2));
	upd_pos.set_cov(0, 0, current_laser_scan.get_base_state().get_base_position().get_cov(0,0));
	upd_pos.set_cov(1, 1, current_laser_scan.get_base_state().get_base_position().get_cov(1,1));
	upd_pos.set_cov(2, 2, current_laser_scan.get_base_state().get_base_position().get_cov(2,2));

	old_pos.set_x (current_laser_scan.get_base_state().get_base_position().get_x(1), 1);
	old_pos.set_y (current_laser_scan.get_base_state().get_base_position().get_y(1), 1);
	old_pos.set_z (current_laser_scan.get_base_state().get_base_position().get_z(1), 1);
	old_pos.set_base_azimuth (current_laser_scan.get_base_state().get_base_position().get_base_azimuth());

	upd_pos.set_x (local_pose.translation().x(), 1);
	upd_pos.set_y (local_pose.translation().y(), 1);
	upd_pos.set_z (local_pose.translation().z(), 1);

	double r,p,y;
	toEulerAngle(local_pose.rotation(), r, p, y);

	upd_pos.set_base_azimuth (y);
	upd_pos.set_cov_invalid(true);

	upd.set_corrected_position (upd_pos);
	upd.set_old_position (old_pos);

	Smart::StatusCode status;
	status = COMP->localized_robot_pose->send(upd);

	if(status != Smart::SMART_OK)
		std::cout << "Error in sending localized pose : " << Smart::StatusCodeConversion(status)<<std::endl;

}

void CartographerTask::AddSensorData_LaserScanMessage(const CommBasicObjects::CommMobileLaserScan& laser_scan){
	cartographer::sensor::PointCloudWithIntensities point_cloud;
	cartographer::common::Time time;
	//std::cout << " laser time = " << laser_scan.get_scan_time_stamp() << "  scan_id : " << laser_scan.get_scan_update_count()<<std::endl;
	std::tie(point_cloud, time) = ToCartographer_PointCloudWithIntensities(laser_scan);
	//std::cout << "ss, cg  laser time = " << lasercan.get_scan_time_stamp() << ", "<< time <<std::endl;
	CommBasicObjects::CommPose3d laser_sensor_pose = laser_scan.get_sensor_pose();
	CommBasicObjects::CommBasePose odom_pose = laser_scan.get_base_state().get_base_raw_position();

	//std::cout << "points size = : " <<point_cloud.points.size() <<std::endl;
	num_subdivisions_per_laser_scan = 1;
	std::cout <<"laser scan ="<<laser_scan.get_scan_update_count() << " timer_counter = "  << timer_counter<<'\r' <<std::flush;
	for (int i = 0; i != num_subdivisions_per_laser_scan; ++i) {
	    const size_t start_index = point_cloud.points.size() * i / num_subdivisions_per_laser_scan;
	    const size_t end_index   = point_cloud.points.size() * (i + 1) / num_subdivisions_per_laser_scan;
	    cartographer::sensor::TimedPointCloud subdivision(point_cloud.points.begin() + start_index,
	    												  point_cloud.points.begin() + end_index);
	    if (start_index == end_index) {
	      continue;
	    }

	    const double time_to_subdivision_end = subdivision.back().time;

	    const cartographer::common::Time subdivision_time = time + cartographer::common::FromSeconds(time_to_subdivision_end);

//	    auto it = sensor_to_previous_subdivision_time_.find(sensor_id);
//	    if (it != sensor_to_previous_subdivision_time_.end() &&
//	        it->second >= subdivision_time) {
//	      LOG(WARNING) << "Ignored subdivision of a LaserScan message from sensor "
//	                   << sensor_id << " because previous subdivision time "
//	                   << it->second << " is not before current subdivision time "
//	                   << subdivision_time;
//	      continue;
//	    }
//
//	    sensor_to_previous_subdivision_time_[sensor_id] = subdivision_time;

	    for (auto& point : subdivision) {
	      point.time -= time_to_subdivision_end;
	    }

	    //HandleRangefinder(sensor_id, subdivision_time, frame_id, subdivision);
        using cartographer::transform::Rigid3d;
	    Rigid3d transform = ToCartographer_Rigid3d(laser_sensor_pose); // laser sensor pose w.r.t base
	    //std::cout << "base to laser = " <<transform.DebugString() <<std::endl;
	    Eigen::Vector3f translation = ToTranslationVector(laser_sensor_pose); // laser sensor translation w.r.t base
	    //std::cout << "base to laser translation = " <<translation <<std::endl;

	    //std::cout << "subdivision size = " << subdivision.size() <<"\r";//<<std::endl;
	    trajectory_builder->AddSensorData(laser_id,
	    		                          cartographer::sensor::TimedPointCloudData{time,
	    	                                                                        translation,
																					cartographer::sensor::TransformTimedPointCloud(subdivision, transform.cast<float>())});

	  }

}

void CartographerTask::AddSensorData_OdometryMessage(const CommBasicObjects::CommBasePose& odompose, const CommBasicObjects::CommTimeStamp& time_stamp){


	//std::cout << "odom time : " << time_stamp <<std::endl;
	trajectory_builder->AddSensorData(odometry_id, ToCartographer_OdometryData(odompose, time_stamp));
}

bool CartographerTask::FinishTrajectory(const std::string &dirname, const std::string &filename)
{
	using TrajectoryState = cartographer::mapping::PoseGraphInterface::TrajectoryState;

	auto trajectory_states = map_builder->pose_graph()->GetTrajectoryStates();

	for(auto current_trajectory_state : trajectory_states)
	{
	if(current_trajectory_state.second == TrajectoryState::ACTIVE)
	{
		map_builder->FinishTrajectory(current_trajectory_state.first);
        uint64 c =0;
		while(!map_builder->pose_graph()->IsTrajectoryFinished(current_trajectory_state.first))
		{
			std::cout << "waiting for trajectory with Id = "<< current_trajectory_state.first << " to finish" << ++c <<std::endl;
			sleep(1);
		}

		std::cout << "trajectory with ID = "<< current_trajectory_state.first << " is finished = "<<map_builder->pose_graph()->IsTrajectoryFinished(current_trajectory_state.first) <<std::endl;
		std::cout << "trajectory with ID = "<< current_trajectory_state.first << " is frozen = "<<map_builder->pose_graph()->IsTrajectoryFrozen(current_trajectory_state.first)<<std::endl;

	}
	}

	std::cout << "Optimizing the Posegraph" <<std::endl;
	map_builder->pose_graph()->RunFinalOptimization();
	bool state_serialize = false;
	state_serialize = map_builder->SerializeStateToFile(true, dirname+filename+".pbstream");
	if(state_serialize)
	{
		std::cout << "Cartographer current state is serialized to file: " << dirname+filename+".pbstream" <<std::endl;
	}
	else
	{
		std::cout << "Error while serializing the Cartographer current state to file: " <<std::endl;
	}
	return true;
}

bool CartographerTask::savemap(const std::string &dirname, const std::string &filename)
{
	return write_to_disk(get_current_map(), dirname, filename);
}

bool CartographerTask::write_to_disk(const CGmap& cg_map,const std::string &dirname, const std::string &filename)
{
	double resolution = 0.05;
	std::string map_name_with_path = dirname + filename;
	cartographer::io::StreamFileWriter pgm_writer(map_name_with_path + ".pgm");
	//cartographer::io::Image image(std::move(cg_map.surface));
	cartographer::io::Image image(get_current_map().surface);
	WritePgm(image, resolution, &pgm_writer);

	const Eigen::Vector2d origin(-cg_map.origin.x() * resolution, (cg_map.origin.y() - image.height()) * resolution);

	cartographer::io::StreamFileWriter yaml_writer(map_name_with_path + ".yaml");
	WriteYaml(resolution, origin, pgm_writer.GetFilename(), &yaml_writer);
	return true;

//
//    send_currentmap(cg_map); // publish the final map
//	// map context informations
//	const int width  = cairo_image_surface_get_width(cg_map.surface.get()); //x
//	const int height = cairo_image_surface_get_height(cg_map.surface.get()); //y
//	double resolution = 0.05;
//
//	std::cout << "Map width, height : " << width << ", "<<height << std::endl;
//
//
//	double origin_x = -cg_map.origin.x() * resolution;
//	double origin_y = (-height + cg_map.origin.y()) * resolution;
//
//	double origin_z = 0.0;
//
//	bool negate = false;
//	double occupied_thresh = 0.5;
//	double free_thresh = 0.196;
//
//
//	double hit_probability = 0.55;
//	double miss_probability = 0.49;
//
//
//	const char occupied = 0;
//	const char unknown = 205;
//	const char freeSpace = 255;
//
//	const uint32_t* pixel_data = reinterpret_cast<uint32_t*>(cairo_image_surface_get_data(cg_map.surface.get()));
//
//
//
//
//	try	{
//
//		// create a single channel image with the same size and double depth as the map
//		IplImage* image = cvCreateImage(cvSize(width, height), IPL_DEPTH_8U, 1);
//
//		// copy map into a image
//		double value = 0.0;
//
//		for (unsigned int y = 0; y < height; y++)
//		{
//			for (unsigned int x = 0; x < width; x++)
//			{
//				char* ptr = image->imageData + (y * image->widthStep) + x;
//
//				const uint32_t packed = pixel_data[y * width + x];
//				const unsigned char color = packed >> 16;
//				const unsigned char observed = packed >> 8;
//
//				//const int v = (observed == 0) ? -1 : cartographer::common::RoundToInt((1. - color / 255.) * 100.);
//				const int color_observed = (observed == 0) ? 128 : color;
//				//const double value = v/100.0;
//
//				*ptr = color_observed;
//
////				if(color < 0.0)
////				{
////					*ptr = unknown;
////				}
////				else if(color > occupied_thresh*255.0)
////				{
////					*ptr = occupied;
////				}
////				else
////				{
////					*ptr = freeSpace;
////				}
//
//			}
//		}
//
//		//cvFlip(image, NULL, 0); // 0 == horizontal flip
//
//		char  mapFileName[255];
//		char  mapFileNameWithPath[255];
//		sprintf(mapFileName,"%s.pgm", filename.c_str());
//		sprintf(mapFileNameWithPath,"%s/%s.pgm", dirname.c_str(), filename.c_str());
//
//		std::cout <<__FUNCTION__ << " : mapFileNameWithPath = " << mapFileNameWithPath <<std::endl;
//		// save image to file mapAsPGM.pgm
//		if(!cvSaveImage(mapFileNameWithPath,image)){
//			std::cout << "Could not save: " << mapFileNameWithPath << std::endl;
//			return false;
//		}
//
//		// save context information in yaml format
//		char  yamlFileName[255];
//		sprintf(yamlFileName,"%s/%s.yaml", dirname.c_str(), filename.c_str());
//		CvFileStorage* fs = cvOpenFileStorage( yamlFileName, 0, CV_STORAGE_WRITE);
//		cvWriteString( fs, "image", mapFileName);
//		cvWriteReal( fs, "resolution", resolution);
//
//		cvWriteInt( fs, "negate", negate);
//		cvWriteReal( fs, "occupied_thresh", occupied_thresh);
//		cvWriteReal( fs, "free_thresh", free_thresh);
//		cvReleaseFileStorage( &fs );
//
//		ofstream myfile;
//		myfile.open(yamlFileName, ios::app);
//		myfile << "origin: " << "[" << origin_x << "," << origin_y << "," << origin_z << "]\n";
//		myfile.close();
//		std::cout <<__FUNCTION__ << " : yamlFileName = " << yamlFileName <<std::endl;
//
//		// clean up image
//		cvReleaseImage(&image);
//
//		std::cout << "GMAPPING_SAVE_MAP: saved - " << mapFileNameWithPath << std::endl;
//		return true;
//	}
//	catch (cv::Exception& e){
//		const char* err_msg = e.what();
//		std::cout << "exception caught: " << err_msg << std::endl;
//		std::cout<<"ERROR: Could not save map!"<<std::endl;
//	}
//	return false;

}

CGmap CartographerTask::get_current_map_debug()
{
	using SubmapData = cartographer::mapping::PoseGraphInterface::SubmapData;
		using SubmapId   = cartographer::mapping::SubmapId;
		using SubmapPose = cartographer::mapping::PoseGraphInterface::SubmapPose;
		using SubmapQuery_Response = cartographer::mapping::proto::SubmapQuery::Response;
		using SubMapTexture = cartographer::mapping::proto::SubmapQuery_Response_SubmapTexture;
		using SubmapSlice   = cartographer::io::SubmapSlice;
		using cartographer::io::SubmapTexture;
		using cartographer::io::UnpackTextureData;


		cartographer::mapping::MapById<SubmapId, SubmapPose> submap_poses = map_builder->pose_graph()->GetAllSubmapPoses();
		cartographer::mapping::MapById<SubmapId, SubmapData> submap_Id_data = map_builder->pose_graph()->GetAllSubmapData();

		auto graph_nodes =map_builder->pose_graph()->GetTrajectoryNodePoses();

		std::vector<cartographer::transform::Rigid3d> nodes;
		for(auto const& current_node : graph_nodes)
		{
			std::cout << " current_node id =  " << current_node.id << ",  global_pose = " << current_node.data.global_pose
					  << ",  constant_pose_data = " << current_node.data.constant_pose_data->local_pose <<std::endl;
			nodes.push_back(current_node.data.global_pose);
		}

		COMP->h.displayParticles(nodes);


		for(auto const& id_pose_pair : submap_poses)
	    {
		std::cout << " submap id =  " << id_pose_pair.id << ",  pose = " << id_pose_pair.data.pose <<std::endl;
	    }

		std::cout << " size of submap_poses " << submap_poses.size() << " size of submap_Id_data " << submap_Id_data.size() <<std::endl;


		for(auto cur : submap_Id_data ){

			SubmapQuery_Response response_proto;
			std::map<SubmapId, SubmapSlice> submap_slices;

			const std::string error = map_builder->SubmapToProto(cur.id, &response_proto);

			if(error.empty())
			{
				int submap_version = response_proto.submap_version();

				//for (const auto texture_proto : response_proto.textures()) {

				const auto texture_proto = response_proto.textures().begin();
				SubmapTexture submap_texture;
				SubmapSlice& current_submap_slice = submap_slices[cur.id];
				//std::cout << " filling id_pose_pair.id = " << cur.id <<std::endl;
				//current_submap_slice.pose = cur.data.pose;
				current_submap_slice.pose = cartographer::transform::ToRigid3(texture_proto->slice_pose());
				//current_submap_slice.metadata_version = cur.data.;
				current_submap_slice.width = texture_proto->width();
				current_submap_slice.height = texture_proto->height();

				current_submap_slice.resolution = texture_proto->resolution();

				cartographer::io::SubmapTextures current_texture;

				current_texture.textures.push_back(cartographer::io::SubmapTexture{
					        UnpackTextureData(texture_proto->cells(), texture_proto->width(), texture_proto->height()),
							texture_proto->width(),
							texture_proto->height(),
							texture_proto->resolution(),
							cartographer::transform::ToRigid3(texture_proto->slice_pose())});

				current_submap_slice.slice_pose = current_texture.textures[0].slice_pose;
				//current_submap_slice.slice_pose = current_submap_slice.pose;

				current_submap_slice.cairo_data.clear();

				current_submap_slice.surface = cartographer::io::DrawTexture(current_texture.textures[0].pixels.intensity,
						current_texture.textures[0].pixels.alpha,
						current_texture.textures[0].width,
						current_texture.textures[0].width,
						&current_submap_slice.cairo_data);

				//} //for (const auto texture_proto : response_proto.textures())
		}



			write_to_disk(cartographer::io::PaintSubmapSlices(submap_slices, 0.05),"/tmp", std::to_string(cur.id.submap_index));
		}
//#endif

		SubmapQuery_Response response_proto;

		//get texture of all the submaps
		std::map<SubmapId, SubMapTexture> submap_textures;
		std::map<SubmapId, SubmapSlice> submap_slices;

		for(auto const& id_pose_pair : submap_Id_data)
		{
			//std::cout << "---------------------------------------------------------------------" <<std::endl;
			const std::string error = map_builder->SubmapToProto(id_pose_pair.id, &response_proto);

			if(error.empty())
			{

				//for (const auto texture_proto : response_proto.textures()) {

				    const auto texture_proto = response_proto.textures().begin();


					SubmapTexture submap_texture;
					SubmapSlice& current_submap_slice = submap_slices[id_pose_pair.id];
					std::cout << " filling id_pose_pair.id = " << id_pose_pair.id <<std::endl;
					//current_submap_slice.pose = id_pose_pair.data.pose;
					current_submap_slice.pose = cartographer::transform::ToRigid3(texture_proto->slice_pose());

					//std::cout << " id_pose_pair.data.pose : " << id_pose_pair.data.pose << " texture_proto->slice_pose() : " << cartographer::transform::ToRigid3(texture_proto->slice_pose()) <<std::endl;
					current_submap_slice.metadata_version = response_proto.submap_version();
					current_submap_slice.version = response_proto.submap_version();
					current_submap_slice.width = texture_proto->width();
					current_submap_slice.height = texture_proto->height();
					current_submap_slice.slice_pose = cartographer::transform::ToRigid3(texture_proto->slice_pose());
					current_submap_slice.resolution = texture_proto->resolution();
					current_submap_slice.cairo_data.clear();


					cartographer::io::SubmapTextures current_texture;
					current_texture.version = response_proto.submap_version();

					current_texture.textures.push_back(cartographer::io::SubmapTexture{
						                                                        UnpackTextureData(texture_proto->cells(), texture_proto->width(), texture_proto->height()),
					        				                                    texture_proto->width(),
																				texture_proto->height(),
																				texture_proto->resolution(),
																				cartographer::transform::ToRigid3(texture_proto->slice_pose())});

					//current_submap_slice.slice_pose = current_submap_slice.pose;

					current_submap_slice.surface = cartographer::io::DrawTexture(current_texture.textures[0].pixels.intensity,
							                                                     current_texture.textures[0].pixels.alpha,
																				 current_texture.textures[0].width,
																				 current_texture.textures[0].width,
																				 &current_submap_slice.cairo_data);

				//} //for (const auto texture_proto : response_proto.textures())
			}
		}//for(auto const& id_pose_pair : submap_poses)

		//paint submapslices
		return cartographer::io::PaintSubmapSlices(submap_slices, 0.05);
}

CGmap CartographerTask::get_current_map()
{

	using SubmapData = cartographer::mapping::PoseGraphInterface::SubmapData;
	using SubmapId   = cartographer::mapping::SubmapId;
	using SubmapPose = cartographer::mapping::PoseGraphInterface::SubmapPose;
	using SubmapQuery_Response = cartographer::mapping::proto::SubmapQuery::Response;
	using SubMapTexture = cartographer::mapping::proto::SubmapQuery_Response_SubmapTexture;
	using SubmapSlice   = cartographer::io::SubmapSlice;
	using SubmapTexture = cartographer::io::SubmapTexture;
	using cartographer::io::UnpackTextureData;


	std::map<SubmapId, SubmapSlice> submap_slices;

	//getsubmap list
	for (const auto& submap_id_pose : map_builder->pose_graph()->GetAllSubmapPoses()) {


	    const SubmapId submap_id{submap_id_pose.id.trajectory_id, submap_id_pose.id.submap_index};
	    SubmapSlice& current_submap_slice = submap_slices[submap_id];

	    current_submap_slice.pose = submap_id_pose.data.pose;
	    current_submap_slice.metadata_version = submap_id_pose.data.version;

	    //fetch textures for submap with id
	    cartographer::mapping::proto::SubmapQuery::Response response_proto;
	    const std::string error = map_builder->SubmapToProto(submap_id, &response_proto);
	    const auto& texture_proto = response_proto.textures().begin();


	    const std::string compressed_cells(texture_proto->cells().begin(), texture_proto->cells().end());
	    SubmapTexture submap_texture = cartographer::io::SubmapTexture{cartographer::io::UnpackTextureData(compressed_cells,
	    																								   texture_proto->width(),
	    		                                                                                           texture_proto->height()),
	    	                                                 	        texture_proto->width(),
																		texture_proto->height(),
																		texture_proto->resolution(),
																		cartographer::transform::ToRigid3(texture_proto->slice_pose())};






	    current_submap_slice.version = response_proto.submap_version();

	    current_submap_slice.width = texture_proto->width();
	    current_submap_slice.height = texture_proto->height();
	    current_submap_slice.slice_pose = cartographer::transform::ToRigid3(texture_proto->slice_pose());
	    current_submap_slice.resolution = texture_proto->resolution();
	    current_submap_slice.cairo_data.clear();
	    current_submap_slice.surface = ::cartographer::io::DrawTexture(submap_texture.pixels.intensity,
	    		                                                       submap_texture.pixels.alpha,
				                                                       texture_proto->width(),
				                                                       texture_proto->height(),
																	   &current_submap_slice.cairo_data);

	  }

	return cartographer::io::PaintSubmapSlices(submap_slices, 0.05);
}
void CartographerTask::send_currentmap(const CGmap& cartographer_map)
{
	CommNavigationObjects::CommGridMap smartsoft_grid_map;
	CommBasicObjects::CommTimeStamp time;
	const double scaleFactorMtoMM = 1000; // scale factor for converting from m to mm

	// map context information
	const int width  = cairo_image_surface_get_width(cartographer_map.surface.get()); //x
	const int height = cairo_image_surface_get_height(cartographer_map.surface.get()); //y
	double resolution = 0.05;

	double origin_x = -cartographer_map.origin.x() * resolution;
	double origin_y = (-height + cartographer_map.origin.y()) * resolution;

//	double origin_x = cartographer_map.origin.x();
//	double origin_y = cartographer_map.origin.y();


	double origin_z = 0.0;

	bool negate = false;
	double occupied_thresh = 0.5;
	double free_thresh = 0.196;


	double hit_probability = 0.55;
	double miss_probability = 0.49;


	const char occupied = 0;
	const char unknown = 205;
	const char freeSpace = 255;

	const uint32_t* pixel_data = reinterpret_cast<uint32_t*>(cairo_image_surface_get_data(cartographer_map.surface.get()));

	smartsoft_grid_map.setId(++map_id);
	smartsoft_grid_map.setIs_valid(true);
	smartsoft_grid_map.setTime(time);
	smartsoft_grid_map.setXOffsetMM((int)floor(origin_x*scaleFactorMtoMM));
	smartsoft_grid_map.setYOffsetMM((int)floor(origin_y*scaleFactorMtoMM));

	smartsoft_grid_map.setXOffsetCells((int)floor(origin_x / resolution));
	smartsoft_grid_map.setYOffsetCells((int)floor(origin_y / resolution));
	smartsoft_grid_map.setCellSizeMM((int)floor(resolution*scaleFactorMtoMM));

	smartsoft_grid_map.setXSizeMM((int)floor(width*resolution*scaleFactorMtoMM));
	smartsoft_grid_map.setYSizeMM((int)floor(height*resolution*scaleFactorMtoMM));
	smartsoft_grid_map.setXSizeCells((int)width);
	smartsoft_grid_map.setYSizeCells((int)height);
	smartsoft_grid_map.setSize((int)(width*height));
	smartsoft_grid_map.allocateMap();

	// copy map
	double value = 0.0;
	unsigned char cellValue = 0;

	for (unsigned int y = 0; y < height; ++y)
	{
		for (unsigned int x = 0; x < width; ++x)
		{

			const uint32_t packed = pixel_data[y * width + x];
			const unsigned char color = packed >> 16;
			const unsigned char observed = packed >> 8;

			//probability of being occupied 100 = occupied, 0 = free
			const int value = (observed == 0) ? -1 : cartographer::common::RoundToInt((1. - color / 255.) * 100.);

			assert(value <= 100   && "value < 100 failed");
			assert(value >=  -1   && "value >   0 failed");
			assert(color <= 255   && "color < 255 failed");
			assert(color >=   0   && "color >   0 failed");

			cellValue = color;

			//unsigned char cvalue = static_cast<unsigned char>(value);
			//const int color_observed = (observed == 0) ? 128 : color;
			//cellValue = color_observed;

//			if(value == -1)
//			{
//				cellValue = 205; //unkown
//			}
//			else if((value/100.0) > free_thresh)
//			{
//				cellValue = 128; //occupied
//			}
//			else
//			{
//				cellValue = 0; //free
//			}
			//smartsoft_grid_map.set_cells(x,y,cvalue);
			smartsoft_grid_map.set_cells(x,(height - 1) - y,cellValue);
		}
	}

	std::cout<<"[GMappingTask] Publish gridmap with ID: "<<smartsoft_grid_map.getId()<<std::endl;
	COMP->gridMapPushServiceOut->put(smartsoft_grid_map);
}

//from #include "cartographer_ros/ros_map.h"
void CartographerTask::WritePgm(const ::cartographer::io::Image& image, const double resolution,
              ::cartographer::io::FileWriter* file_writer) {
  const std::string header = std::string("P5\n# Cartographer map; ")+std::to_string(resolution)+std::string(" m/pixel\n")
                             +std::to_string(image.width())+std::string(" ")+std::to_string(image.height())+std::string("\n255\n");
  file_writer->Write(header.data(), header.size());
  for (int y = 0; y < image.height(); ++y) {
    for (int x = 0; x < image.width(); ++x) {
      const char color = image.GetPixel(x, y)[0];
      file_writer->Write(&color, 1);
    }
  }
}

//from #include "cartographer_ros/ros_map.h"
void CartographerTask::WriteYaml(const double resolution, const Eigen::Vector2d& origin,
               const std::string& pgm_filename,
               ::cartographer::io::FileWriter* file_writer) {
  const std::string output =  std::string("image: ") + pgm_filename + std::string("\n")
                             +std::string("resolution: ")+std::to_string(resolution)+std::string("\n")
                             +std::string("origin: [")+ std::to_string(origin.x())+std::string(", ")+std::to_string(origin.y())+std::string(", 0.0]\nnegate: 0\noccupied_thresh: 0.65\nfree_thresh: 0.196\n");
  file_writer->Write(output.data(), output.size());
}
