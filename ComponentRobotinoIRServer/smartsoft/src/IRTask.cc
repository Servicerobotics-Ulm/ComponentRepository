//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2014 Matthias Lutz
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "IRTask.hh"
#include "ComponentRobotinoIRServer.hh"

#include <iostream>
#include <assert.h>


IRTask::IRTask(SmartACE::SmartComponent *comp) 
:	IRTaskCore(comp)
{
	std::cout << "constructor IRTask\n";

	analogInputArray.setComId(com.id());
	irFinder.setComId(com.id());
	relay.setComId(com.id());
}
IRTask::~IRTask() 
{
	std::cout << "destructor IRTask\n";
}

void IRTask::enableIRSensors(){
     std::cout<<"Enable IR Sensors"<<std::endl;
     relay.setValue(true);

}


void IRTask::disableIRSensors(){
    std::cout<<"Disable IR Sensors"<<std::endl;
    relay.setValue(false);
}

void MyIRRangeFinder::distancesChangedEvent( const float* distances, unsigned int size ){
	Smart::StatusCode status;
	status = COMP->stateSlave->tryAcquire("fetchIR");
	if (status == Smart::SMART_OK)
	{
		CommBasicObjects::CommMobileIRScan mobileIrScan;
		CommBasicObjects::CommIRScan irScan;
		CommBasicObjects::CommBaseState baseState;

		//for this impl the size of the sensor array has to be 9
		assert(size==max_sensor_size);

		unsigned int valid_point_size=0;
		std::vector< unsigned int > valid_point_index;



		for(unsigned int i=0;i<size;i++){
			if(distances[i]<max_range){
				valid_point_size++;
				valid_point_index.push_back(i);
			}
		}

		//fill vector with data from rpcd
		irScan.resizeDistances(valid_point_size);
		irScan.resizePoses3D(valid_point_size);
		irScan.resizeRaw_readings(this->numDistanceSensors());
		//std::vector<double>& tmp_distances = irScan.getDistancesRef();

		std::vector<float> raw_voltages( this->numDistanceSensors() );
		this->voltages( &raw_voltages[0] );
			for( int i=0; i<raw_voltages.size(); ++i )
			{
			irScan.setRaw_readingsElemAtPos(i,raw_voltages[i]);
			}


		for(unsigned int i=0;i<valid_point_size;i++){
			irScan.setDistancesElemAtPos(i,distances[valid_point_index[i]]);
			irScan.setPoses3DElemAtPos(i,sensorPositions[valid_point_index[i]]);
			//std::cout<<"Distance measure: "<<distances[valid_point_index[i]]<<std::endl;
		}

		Smart::StatusCode status = COMP->baseStateServiceIn->getUpdate(baseState);
		if(status == Smart::SMART_OK){
			mobileIrScan.setBaseState(baseState);
			mobileIrScan.setIrScan(irScan);
			mobileIrScan.setIs_valid(true);

	//		double x,y,z=0;
	//		for(unsigned int i=0;i<mobileIrScan.getIrScan().getDistancesSize();i++){
	//			irScan.get_scan_cartesian_3dpoint_robot(i,x,y,z,1);
	//			//std::cout<<"Point at pose in ROBOT system: "<<x<<"|"<<y<<"|"<<z<<std::endl;
	//		}

		} else {
			mobileIrScan.setIs_valid(false);
		}

		COMP->mobileIRPushOut->put(mobileIrScan);

		COMP->stateSlave->release("fetchIR");
	}
}

void MyIRRangeFinder::initSensorPoses(){


	max_range = COMP->getGlobalState().getSettings().getMaxDist();
	min_range = COMP->getGlobalState().getSettings().getMinDist();

	std::vector<float> vec( numDistanceSensors() );
	headings( &vec[0] );

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS1_x(),
			  COMP->getGlobalState().getSensorPoses().getS1_y(),
			  COMP->getGlobalState().getSensorPoses().getS1_z(),vec[0],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS2_x(),
			  COMP->getGlobalState().getSensorPoses().getS2_y(),
			  COMP->getGlobalState().getSensorPoses().getS2_z(),vec[1],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS3_x(),
			  COMP->getGlobalState().getSensorPoses().getS3_y(),
			  COMP->getGlobalState().getSensorPoses().getS3_z(),vec[2],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS4_x(),
			  COMP->getGlobalState().getSensorPoses().getS4_y(),
			  COMP->getGlobalState().getSensorPoses().getS4_z(),vec[3],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS5_x(),
			  COMP->getGlobalState().getSensorPoses().getS5_y(),
			  COMP->getGlobalState().getSensorPoses().getS5_z(),vec[4],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS6_x(),
			  COMP->getGlobalState().getSensorPoses().getS6_y(),
			  COMP->getGlobalState().getSensorPoses().getS6_z(),vec[5],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS7_x(),
			  COMP->getGlobalState().getSensorPoses().getS7_y(),
			  COMP->getGlobalState().getSensorPoses().getS7_z(),vec[6],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS8_x(),
			  COMP->getGlobalState().getSensorPoses().getS8_y(),
			  COMP->getGlobalState().getSensorPoses().getS8_z(),vec[7],0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getSensorPoses().getS9_x(),
			  COMP->getGlobalState().getSensorPoses().getS9_y(),
			  COMP->getGlobalState().getSensorPoses().getS9_z(),vec[8],0,0,1));

	max_sensor_size = sensorPositions.size();
}

void MyAnlogInputArray::initSensorPoses(){

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getAdditionIRSensors().getS1_x(),
			  COMP->getGlobalState().getAdditionIRSensors().getS1_y(),
			  COMP->getGlobalState().getAdditionIRSensors().getS1_z(),COMP->getGlobalState().getAdditionIRSensors().getS1_heading(),0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getAdditionIRSensors().getS2_x(),
			  COMP->getGlobalState().getAdditionIRSensors().getS2_y(),
			  COMP->getGlobalState().getAdditionIRSensors().getS2_z(),COMP->getGlobalState().getAdditionIRSensors().getS2_heading(),0,0,1));

	sensorPositions.push_back(CommBasicObjects::CommPose3d(COMP->getGlobalState().getAdditionIRSensors().getS2_x(),
			  COMP->getGlobalState().getAdditionIRSensors().getS2_y(),
			  COMP->getGlobalState().getAdditionIRSensors().getS2_z(),COMP->getGlobalState().getAdditionIRSensors().getS2_heading(),0,0,1));
}

void MyAnlogInputArray::valuesChangedEvent( const float* values, unsigned int size ){

	if(COMP->getGlobalState().getAdditionIRSensors().getHasAdditionIRSensors() == true){
		Smart::StatusCode status;
		status = COMP->stateSlave->tryAcquire("fetchAdditionalIR");
		if (status == Smart::SMART_OK)
		{
			CommBasicObjects::CommMobileIRScan mobileIrScan;
			CommBasicObjects::CommIRScan irScan;
			CommBasicObjects::CommBaseState baseState;

			unsigned int usedNumberOfValues =  COMP->getGlobalState().getAdditionIRSensors().getNumberOfSensors();

			irScan.resizeDistances(usedNumberOfValues);
			irScan.resizePoses3D(usedNumberOfValues);
			irScan.resizeRaw_readings(usedNumberOfValues);

			for( int i=0; i<usedNumberOfValues; ++i )
			{
				if(i>=this->numAnalogInputs()){
					std::cout<<"WARNING: False configuration less analogInput values then wanted!"<<std::endl;
				} else {
					double tmp = values[i];

					//			std::cout<<"Raw values: "<<tmp<<std::endl;
					//			std::cout<<"Calculated values: "<<transferIRReadingsToDistances(values[i])<<std::endl;
					irScan.setRaw_readingsElemAtPos(i,tmp);
					irScan.setDistancesElemAtPos(i,transferIRReadingsToDistances(values[i]));
					irScan.setPoses3DElemAtPos(i,sensorPositions[i]);
				}

			}

			Smart::StatusCode status = COMP->baseStateServiceIn->getUpdate(baseState);
			if(status == Smart::SMART_OK){
				mobileIrScan.setBaseState(baseState);
				mobileIrScan.setIrScan(irScan);
				mobileIrScan.setIs_valid(true);

			} else {
				mobileIrScan.setIs_valid(false);
			}

			COMP->additionalIRScanPushOut->put(mobileIrScan);
			if(COMP->getGlobalState().getSettings().getVerbose() == true){
				std::cout<<"SEND: "<<mobileIrScan.getIrScan()<<std::endl;
			}

			COMP->stateSlave->release("fetchAdditionalIR");
		}
	}
}


int IRTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	irFinder.initSensorPoses();
	if(COMP->getGlobalState().getAdditionIRSensors().getHasAdditionIRSensors() == true){
		analogInputArray.initSensorPoses();
		relay.setRelayNumber(COMP->getGlobalState().getAdditionIRSensors().getRelayNumber());
	}

	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	std::cout << "Connecting... to "<<COMP->getGlobalState().getSettings().getDaemonIP()<<std::endl;
	com.setAddress( COMP->getGlobalState().getSettings().getDaemonIP().c_str());

	do{
		sleep(1);
		try{
			com.connectToServer( true );
		}catch(rec::robotino::api2::RobotinoException &e){
			std::cout<<e.what()<<std::endl;
		}
	}while (false == com.isConnected());

	if( false == com.isConnected() )
	{
		std::cout << std::endl << "Could not connect to " << com.address() << std::endl;
		rec::robotino::api2::shutdown();
		return -1;
	}
	else
	{
		std::cout << "success" << std::endl;
		return 0;
	}
	return 0;
}
int IRTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	Smart::StatusCode status;
	status = COMP->stateSlave->acquire("nonneutral");
	if (status == Smart::SMART_OK)
	{
		com.processEvents();
		COMP->stateSlave->release("nonneutral");
	}
	return 0;
}
int IRTask::on_exit()
{
	com.disconnectFromServer();
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
