//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//------------------------------------------------------------------------
//
//  Copyright (C) 2018 Nayabrasul Shaik, Matthias Lutz, Matthias Rollenhagen
//
//        shaik@hs-ulm.de, lutz@hs-ulm.de, rollenhagen@hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "SmartLaserFromRGBDServer component".
//
//  The method for converting 3D pointcloud to 2D laserscan is based on Mobile Robot Programming Toolkit (MRPT), http://www.mrpt.org/
//  https://github.com/MRPT/mrpt/blob/1371504fd3fdb891b92e80aa53eb26c4b33015cd/libs/obs/src/CObservation3DRangeScan.cpp
//--------------------------------------------------------------------------

//------------------------------------------------------------------------
//  For License : https://www.mrpt.org/License/
//  Copyright (c) 2005-2014, Individual contributors, see AUTHORS file
//  Copyright (c) 2005-2014, MAPIR group, University of Malaga
//  Copyright (c) 2012-2014, University of Almeria
//  All rights reserved.

//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are
//  met:
//  * Redistributions of source code must retain the above copyright
//        notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above copyright
//        notice, this list of conditions and the following disclaimer in the
//        documentation and/or other materials provided with the distribution.
//   * Neither the name of the copyright holders nor the
//        names of its contributors may be used to endorse or promote products
//        derived from this software without specific prior written permission.

//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//  'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
//  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE
//  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
//  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//--------------------------------------------------------------------------
#ifndef _LASERTASK_HH
#define _LASERTASK_HH

#include "LaserTaskCore.hh"
#include "CommBasicObjects/CommMobileLaserScan.hh"
#include "DomainVision/CommRGBDImage.hh"

//include needs to be before the pcl, due to the fact that the mrpt needs to be included before eigen
#include <mrpt/poses/CPoint.h>

#include <pcl/common/common_headers.h>

#include <deque>

class LaserTask  : public LaserTaskCore
{

private:
	Smart::TimePoint last;
	CommBasicObjects::CommMobileLaserScan laser_scan;
	DomainVision::CommRGBDImage rgbd_scan;
	CommBasicObjects::CommBaseState base_state;

	DomainVision::DepthFormatType depth_data_type;
	Smart::StatusCode status;
	bool first_image_flag;  /**use this flag to read intrinsic and extrinsic parameters from the first received RGBD image**/


	//these variables are derived from RGBD properties, calculate only once
	float       hfov_rad;    ///< Horizontal field of View (in radians)
	float       vfov_rad;    ///< Vertical field of View (in radians)
	size_t nLaserRays;       ///< number of laser rays in a scan
	double start_angle;      ///< Angle correspond to first scan
	double angle_resolution; ///< Difference of angles between 2 consecutive rays


	float vertical_view;///< vertical field of view angle to be considered (currently full view is considered)
	uint32_t min_dist;  ///< Minimum distance range
	uint32_t max_dist;  ///< Maximum distance range

	//distance between robot base frame and floor( see the image in doc/readme.md)
	double robot_base_frame_height_from_floor; //in meters

	// Color and Depth intrinsics
	struct st_intrinsics{
		int cols, rows;
		float cx, cy, fx, fy;
		float distortion_coeffs[5];
		DomainVision::ImageDistortionModel distortion_model;
	}color_intrinsics, depth_intrinsics;

	//Depth extrinsics with respect to color
	struct st_extrinsics{
		float rotation[9];
		float translation[3];
	}depth_to_color_extrinsics;

	std::deque<float> laser_ray_distances;

	double sensor_pose_x;
	double sensor_pose_y;
	double sensor_pose_z;
	double sensor_pose_azimuth;
	double sensor_pose_elevation;
	double sensor_pose_roll;
public:
	LaserTask(SmartACE::SmartComponent *comp);
	virtual ~LaserTask();
	
	virtual int on_entry();
	virtual int on_execute();
	virtual int on_exit();
	bool realsense_to_laserscan(DomainVision::CommRGBDImage& rgbd_scan, CommBasicObjects::CommMobileLaserScan& laser_scan);
	static double pi_to_pi(double angle);
	void display_parameters();


private:

	void init_laser_generation();
	void read_intrinsics_extrinsics(const DomainVision::CommRGBDImage& rgbd_image);

	void createPointCloud(DomainVision::CommDepthImage &depth_image, pcl::PointCloud<pcl::PointXYZ>::Ptr point_cloud_out);
	void findMinimumDistances(const pcl::PointCloud<pcl::PointXYZ>::Ptr inputCloud, std::deque<float>& laser_ray_distances);
	void set_laser_ray_distances(CommBasicObjects::CommMobileLaserScan& laser_scan, std::deque<float>& laser_ray_distances);

	void calcPointXYZ (const uint32_t& r, const uint32_t& c, const float &depth_val_meters, float &x, float &y, float &z,
			const st_intrinsics& intrinsics, const st_extrinsics& extrinsics);
	void transform (const st_extrinsics& extrinsics, float &x, float &y, float &z);
	void deproject(const st_intrinsics& intrinsics, const uint32_t& r, const uint32_t& c, const float &depth_val_meters, float &out_x, float &out_y, float &out_z);
	void project(const st_intrinsics& intrinsics, uint32_t& out_r, uint32_t& out_c, const float &in_x, const float &in_y, const float &in_z);
	inline float get_depth(DomainVision::CommDepthImage& comm_depth_image, int row, int col);

};

#endif
