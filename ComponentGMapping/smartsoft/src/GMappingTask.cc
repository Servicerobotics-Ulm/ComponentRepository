//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------


// --------------------------------------------------------------------------
//
//  Copyright (C) 2009 Matthias Lutz
//
//        schlegel@hs-ulm.de
//        lutz@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// --------------------------------------------------------------------------


#include "GMappingTask.hh"
#include "ComponentGMapping.hh"
#include <CommBasicObjects/CommMobileLaserScan.hh>
#include <CommBasicObjects/CommBasePose.hh>
#include <CommBasicObjects/CommBasePositionUpdate.hh>

#include <iostream>

GMappingTask::GMappingTask(SmartACE::SmartComponent *comp) 
:	GMappingTaskCore(comp)
{
	processor = NULL;
	mapID=0;
}
GMappingTask::~GMappingTask() 
{
	//this should be working, however this will result in a double free
	//since this is only used in case the component is shutdown,
	//the cleanup of the processor and the map is not that important,
	//as the task will ony be destroyed when the components stops
//	if(processor!=NULL)
//	{
//		delete processor;
//	}
//	if(COMP->mymap!=NULL)
//	{
//		delete COMP->mymap;
//	}
}
void GMappingTask::initGMappingProcessor(double x, double y, double phi)
{
processorLock.acquire();

	if(processor!=NULL)
	{
		helperDeleteProcessor();
		processor = NULL;
	}
	if(COMP->mymap!=NULL)
	{
		delete COMP->mymap;
		COMP->mymap = NULL;
	}

	std::cout<<"Generate new GridSlamProcessor"<<std::endl;
	processor=new GMapping::GridSlamProcessor;
	COMP->mymap = NULL;


	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	CommBasicObjects::CommMobileLaserScan laserscan;
	Smart::StatusCode status;

	//get first laser scan
	do
	{
		status = COMP->laserClient->getUpdate(laserscan);
		if(status != Smart::SMART_OK){
			std::cout<<"GMappingTask::initGMappingProcessor:"<<Smart::StatusCodeConversion(status)<<" ERROR getting laser scan ... retry."<<std::endl;
			sleep(1);
		}
		if(laserscan.is_scan_valid()==false)
		{
				std::cout<<"laserscan is not vaild!"<<std::endl;
		}
	}while(status != Smart::SMART_OK && laserscan.is_scan_valid()==false );

	std::cout<<"[GMappingTask::initGMappingProcessor()] Scan points: "<<laserscan.get_scan_size()<<std::endl;
	std::cout<<"[GMappingTask::initGMappingProcessor()] Scan max points : "<<laserscan.get_max_scan_size()<<std::endl;
	std::cout<<"[GMappingTask::initGMappingProcessor()] Scan res: "<<laserscan.get_scan_resolution()<<std::endl;

	if(COMP->getGlobalState().getSettings().getVerbose()){
		std::cout<<"[GMappingTask::initGMappingProcessor()] laser commObj:"<<laserscan<<std::endl;
	}

	m_frontLaser=0;
	sensorMap.clear();

	//TODO remove used ini instead
	double maximum_range = 8;

	std::string sensorName="FLASER";
	GMapping::OrientedPoint rpose(0, 0, 0);
	GMapping::OrientedPoint lpose(0, 0, 0);
	GMapping::OrientedPoint dp=GMapping::absoluteDifference(lpose, rpose);

	CommBasicObjects::CommPose3d laserPoseRobot = laserscan.get_sensor_pose();

	std::cout<<"Laser Mounting POSE: "<<laserPoseRobot.get_x(1.0)<<" "<<laserPoseRobot.get_y(1) <<" "<<laserPoseRobot.get_azimuth()<<std::endl;
	m_frontLaser=new GMapping::RangeSensor(sensorName,
			                               laserscan.get_max_scan_size(),
										   laserscan.get_scan_resolution(),
										   GMapping::OrientedPoint(laserPoseRobot.get_x(1.0), laserPoseRobot.get_y(1.0), laserPoseRobot.get_azimuth()),
										   0, maximum_range);

        ///////////////////////////////////////////
        // check if the sensor plane is parallel to the x-y plane of the base
        arma::vec zAxis(4);
        zAxis(0) = zAxis(1) = 0;
        zAxis(2) = zAxis(3) = 1.0;

        arma::mat sensor_mat = laserPoseRobot.getHomogeneousMatrix(1.0);
        sensor_mat(0, 3) = sensor_mat(1, 3) = sensor_mat(2, 3) = 0; // remove translation from matrix
        zAxis = sensor_mat * zAxis;

        // laser is planar and mounted upside
        bool isPlanar = (zAxis(2) > 0 && fabs(zAxis(0)) < 0.0001 && fabs(zAxis(1)) < 0.0001);

        // laser is planar but mounted upside down
        isPlanarFliped  = (zAxis(2) < 0 && fabs(zAxis(0)) < 0.0001 && fabs(zAxis(1)) < 0.0001);
        ///////////////////////////////////////////

	if (!isPlanar && ! isPlanarFliped)
        {
        	std::cerr << "\033[0;31m" << "ERROR - LASER IS NOT PLANAR -- " << laserPoseRobot << "\n\033[0m";
        	usleep(500000);
        }


/*
	if(COMP->getGlobalState().getGfs().numScanBeams == 361)
	{
	//TODO change Robot offset
	  m_frontLaser=new GMapping::RangeSensor(sensorName,
	                                         COMP->getGlobalState().getGfs().numScanBeams ,
	                                         laserscan.get_scan_resolution(),
	                                         GMapping::OrientedPoint(laserscan.get_scanner_x(1),
	                                                                 laserscan.get_scanner_y(1),
	                                                                 laserscan.get_scanner_azimuth()), 0, maximum_range);
	}
	else if(COMP->getGlobalState().getGfs().numScanBeams == 181)
	{
	  //0.017453 is the intended scan resolution (1 degree in rad)
	  m_frontLaser=new GMapping::RangeSensor(sensorName,
	                                         COMP->getGlobalState().getGfs().numScanBeams ,0.017453,
	                                         GMapping::OrientedPoint(laserscan.get_scanner_x(1),
	                                                                 laserscan.get_scanner_y(1),
	                                                                 laserscan.get_scanner_azimuth()), 0, maximum_range);
	}
	else
	{
	  std::cerr<<"Invalid number of scan beams configured! Change value in ini file!"<<std::endl;
	  return -1;
	}
*/
	m_frontLaser->updateBeamsLookup();
	sensorMap.insert(make_pair(sensorName, m_frontLaser));

	processor->setSensorMap(sensorMap);
	/////////////////////////////////////////////////////////////////////////////////////////

	processor->setMatchingParameters(COMP->getGlobalState().getGfs().getMaxUrange(),
			                         COMP->getGlobalState().getGfs().getMaxrange(),
									 COMP->getGlobalState().getGfs().getSigma(),
									 COMP->getGlobalState().getGfs().getKernelSize(),
									 COMP->getGlobalState().getGfs().getLstep(),
									 COMP->getGlobalState().getGfs().getAstep(),
									 COMP->getGlobalState().getGfs().getIterations(),
									 COMP->getGlobalState().getGfs().getLsigma(),
									 COMP->getGlobalState().getGfs().getOgain(),
									 COMP->getGlobalState().getGfs().getLskip());

	processor->setMotionModelParameters(COMP->getGlobalState().getGfs().getSrr(),
			                            COMP->getGlobalState().getGfs().getSrt(),
										COMP->getGlobalState().getGfs().getStr(),
										COMP->getGlobalState().getGfs().getStt());

	processor->setUpdateDistances(COMP->getGlobalState().getGfs().getLinearUpdate(),
			                      COMP->getGlobalState().getGfs().getAngularUpdate(),
								  COMP->getGlobalState().getGfs().getResampleThreshold());

	processor->setgenerateMap(COMP->getGlobalState().getGfs().getGenerateMap());
	//OrientedPoint initialPose(xmin+xmax/2, ymin+ymax/2, 0);

	GMapping::OrientedPoint initialPose(x,y,phi);

	//INITIALIZATION
	processor->init(COMP->getGlobalState().getGfs().getParticles(),
			        COMP->getGlobalState().getGfs().getXmin(),
					COMP->getGlobalState().getGfs().getYmin(),
					COMP->getGlobalState().getGfs().getXmax(),
					COMP->getGlobalState().getGfs().getYmax(),
					COMP->getGlobalState().getGfs().getDelta(),
					initialPose);

processorLock.release();
std::cout<<"[GMappingTask::initGMappingProcessor()] - DONE"<<std::endl;
}

void GMappingTask::helperDeleteProcessor(){
			std::cout<<"[helperDeleteProcessor]: START"<<std::endl;
			//CommBasicObjects::CommMobileLaserScan laserscan;
			//COMP->laserClient->getUpdateWait(laserscan);

			const GMapping::RangeSensor * rs= m_frontLaser;
			GMapping::RangeReading reading(rs, 0);
			reading.resize(m_frontLaser->beams().size());

			for (unsigned int i=0;i<m_frontLaser->beams().size(); i++)
			{
				double angle=1;
				reading[i]= 1;
			}

			//insert odometry data in the reading
			//raw odometry data from within the laser scan com object is used
			reading.setPose(GMapping::OrientedPoint(1,1,1));

			bool processed=processor->processScan(reading);
			delete processor;
			std::cout<<"[helperDeleteProcessor]: DONE"<<std::endl;

}


int GMappingTask::on_entry()
{
	initGMappingProcessor(COMP->getGlobalState().getSettings().getInitial_pose_x(),
			              COMP->getGlobalState().getSettings().getInitial_pose_y(),
						  COMP->getGlobalState().getSettings().getInitial_pose_azimuth());
	return 0;
}
int GMappingTask::on_execute()
{
	CommBasicObjects::CommMobileLaserScan laserscan;
		Smart::StatusCode status;


		// ----------------------------------------------------------
		// wait for activation
		// ("active")
		// ----------------------------------------------------------
		status = COMP->stateSlave->acquire("active");

		if (status == Smart::SMART_OK)
		{
			processorLock.acquire();
			if(Smart::SMART_OK == COMP->laserClient->getUpdateWait(laserscan))
			{
				const GMapping::RangeSensor * rs= m_frontLaser;
				GMapping::RangeReading reading(rs, 0);
				reading.resize(laserscan.get_max_scan_size());

				if(COMP->getGlobalState().getSettings().getVerbose()){
					std::cout<<"reading: "<<reading.size()<<std::endl;
					std::cout<<"laserscan get size: "<<laserscan.get_scan_size()<<std::endl;
				}


				//only used to flip the laser planer
				double factor = (isPlanarFliped) ? -1: 1;

				for (unsigned int i=0;i<laserscan.get_scan_size(); i++)
				{
					double angle=COMP->pi_to_pi((double)laserscan.get_scan_angle(i))*factor;
					double index = -1.0*((COMP->pi_to_pi(laserscan.get_scan_start_angle())-angle)/laserscan.get_scan_resolution());
			/*		std::cout<<"Start angle: "<<COMP->pi_to_pi(laserscan.get_scan_start_angle())
			                 <<"INDEX: "<<index<< "angle: "<<angle<<"res: "<<laserscan.get_scan_resolution()<<std::endl;
			*/
					assert((int)index<reading.size());
					assert((int)index>=0);
					reading[(int)index]=(double)laserscan.get_scan_distance(i,1);
				}

				//insert odometry data in the reading
				//raw odometry data from within the laser scan com object is used
				reading.setPose(GMapping::OrientedPoint(laserscan.get_base_state().get_base_raw_position().get_x(1),
				laserscan.get_base_state().get_base_raw_position().get_y(1),
				COMP->pi_to_pi(laserscan.get_base_state().get_base_raw_position().get_base_azimuth())));


				bool processed=processor->processScan(reading);

				//this returns true when the algorithm effectively processes (the traveled path since the last processing is over a given threshold)

				if (processed){

					if(COMP->getGlobalState().getSettings().getVerbose()){

						std::cout<<"SLAM odom pose: "<<laserscan.get_base_state().get_base_raw_position().get_x(1)<<" "
								                     <<laserscan.get_base_state().get_base_raw_position().get_y(1)<<" "
													 <<COMP->pi_to_pi(laserscan.get_base_state().get_base_raw_position().get_base_azimuth())<<std::endl;
					}

					std::cout<< "[GMappingTask::on_execute] SCAN PROCESSED" << std::endl;
					//for searching for the BEST PARTICLE INDEX
					unsigned int best_idx=processor->getBestParticleIndex();



					if(COMP->getGlobalState().getSettings().getVerbose()){
						const GMapping::GridSlamProcessor::ParticleVector& particles = processor->getParticles();
						//this is for recovering the tree of PARTICLE TRAJECTORIES (obtaining the ancestor of each particle)
						std::cerr << "Particle reproduction story begin" << std::endl;
						for (unsigned int i=0; i<particles.size(); i++){
							std::cerr << particles[i].previousIndex << "->"  << i << " ";
						}
						std::cerr << "Particle reproduction story end" << std::endl;
					}


					GMapping::OrientedPoint pose = processor->getParticles()[best_idx].pose;


					if(COMP->getGlobalState().getSettings().getVerbose()){
						double best_weight=processor->getParticles()[best_idx].weightSum;
						std::cerr<<"Best Pose is pose x:"<<pose.x<<" y:"<<pose.y<<" alpha:"<<pose.theta<<std::endl;
						std::cerr << "Best Particle is " << best_idx << " with weight " << best_weight << std::endl;
					}

					CommBasicObjects::CommBasePositionUpdate upd;
					CommBasicObjects::CommBasePose old_pos;
					CommBasicObjects::CommBasePose upd_pos;

					//No Cov to set!
					old_pos.set_cov(0, 0, laserscan.get_base_state().get_base_position().get_cov(0,0));
						old_pos.set_cov(1, 1, laserscan.get_base_state().get_base_position().get_cov(1,1));
						old_pos.set_cov(2, 2, laserscan.get_base_state().get_base_position().get_cov(2,2));
					upd_pos.set_cov(0, 0, laserscan.get_base_state().get_base_position().get_cov(0,0));
						upd_pos.set_cov(1, 1, laserscan.get_base_state().get_base_position().get_cov(1,1));
						upd_pos.set_cov(2, 2, laserscan.get_base_state().get_base_position().get_cov(2,2));

					if(COMP->getGlobalState().getSettings().getVerbose()){
						std::cout<<"SLAM: pos update: old pos: "<<laserscan.get_base_state().get_base_position().get_x(1)<<" "<<
											laserscan.get_base_state().get_base_position().get_y(1)<<" "<<
											laserscan.get_base_state().get_base_position().get_base_azimuth()<<std::endl;
					}
					old_pos.set_x (laserscan.get_base_state().get_base_position().get_x(1), 1);
					old_pos.set_y (laserscan.get_base_state().get_base_position().get_y(1), 1);
					old_pos.set_z (laserscan.get_base_state().get_base_position().get_z(1), 1);
					old_pos.set_base_azimuth (laserscan.get_base_state().get_base_position().get_base_azimuth());

				upd_pos.set_x (pose.x, 1);
					upd_pos.set_y (pose.y, 1);
					upd_pos.set_z (laserscan.get_base_state().get_base_position().get_z(1), 1);
					upd_pos.set_base_azimuth (pose.theta);
					upd_pos.set_cov_invalid(true);

					upd.set_corrected_position (upd_pos);
					upd.set_old_position (old_pos);
					COMP->basePositionUpdateClient->send(upd);

					std::cout<<"[GMappingTask::on_execute] Postion update send!"<<std::endl;

					//new Map data avialable Lock map
					COMP->mapLock.acquire();
						if(COMP->mymap!=NULL)
						{
							delete COMP->mymap;
						}
						COMP->mymap = processor->getParticles()[best_idx].map.toDoubleMap();

						sendMap();

					COMP->mapLock.release();



				} //if processed

			} //if getUpdateWait(laserscan)
			else
			{
				std::cout<<"Error getting laser scan: "<<Smart::StatusCodeConversion(status)<<std::endl;
			}

			processorLock.release();
		}//if state
		// -----------------------------------------------------
		// unlock state at end of while loop
		// -----------------------------------------------------
		status = COMP->stateSlave->release("active");

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}

int GMappingTask::sendMap(){

	if(COMP->mymap==NULL)
	{
		std::cout<<"No map inizialized!"<<std::endl;
		return -1;
	}

	const double scaleFactorMMtoM = 1000; // scale factor for converting from mm to m

	const unsigned map_size_x = COMP->mymap->getMapSizeX();
	const unsigned map_size_y = COMP->mymap->getMapSizeY();
	double resolution = COMP->mymap->getResolution();
	GMapping::Point origin = COMP->mymap->map2world(GMapping::IntPoint(0, 0));

	CommNavigationObjects::CommGridMap gm;
	CommBasicObjects::CommTimeStamp time;
	gm.setId(mapID++);
	gm.setIs_valid(true);
	gm.setTime(time);
	gm.setXOffsetMM((int)floor(origin.x*scaleFactorMMtoM));
	gm.setYOffsetMM((int)floor(origin.y*scaleFactorMMtoM));
	gm.setXOffsetCells((int)floor(origin.x / resolution));
	gm.setYOffsetCells((int)floor(origin.y / resolution));
	gm.setCellSizeMM((int)floor(resolution*scaleFactorMMtoM));

	gm.setXSizeMM((int)floor(map_size_x*resolution*scaleFactorMMtoM));
	gm.setYSizeMM((int)floor(map_size_y*resolution*scaleFactorMMtoM));
	gm.setXSizeCells((int)map_size_x);
	gm.setYSizeCells((int)map_size_y);
	gm.setSize((int)(map_size_x*map_size_y));

	gm.allocateMap();

	// copy map
	double value = 0.0;
	unsigned char cellValue = 0;
	const double occupied_thresh = 0.65;
	const double free_thresh = 0.196;


	//				char scaledValue = 0;
	for (unsigned int y = 0; y < map_size_y; y++)
	{
		for (unsigned int x = 0; x < map_size_x; x++)
		{
			value = COMP->mymap->cell((int)x, (int)y);
			if(value < 0.0)
			{
				cellValue = 205; //unkown
			}
			else if(value > free_thresh)
			{
				cellValue = 128; //occupied
			}
			else
			{
				cellValue = 0; //free
			}
			gm.set_cells(x,y,cellValue);

		}
	}
	std::cout<<"[GMappingTask] Publish gridmap with ID: "<<gm.getId()<<std::endl;
	COMP->newestMapPushServer->put( gm );

	return 0;
}

int GMappingTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
