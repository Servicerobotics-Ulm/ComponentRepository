//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2009 Matthias Lutz
//
//        schlegel@hs-ulm.de
//        lutz@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
// --------------------------------------------------------------------------


#include "TriggerHandler.hh"

#include "ComponentGMapping.hh"

// includes for map serialization
#include <fstream>

#ifdef WITH_OPENCV_4_2_VERSION
#include <opencv4/opencv2/core/core.hpp>
#include <opencv4/opencv2/core/core_c.h>
#include <opencv4/opencv2/core/types_c.h>
#include <opencv4/opencv2/highgui/highgui.hpp>
#include <opencv4/opencv2/imgcodecs/imgcodecs.hpp>
#else
#include <opencv/cxcore.h>
#include <opencv/highgui.h>
#endif
#include <OpenCVHelpers/OpenCVHelpers.hh>

// trigger user methods
void TriggerHandler::handleCommLocalizationObjects_SlamParameter_INITNEWMAP(const int &x, const int &y, const int &a)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::cout<<"INIT_NEW_MAP x: "<<x<<" y: "<<y<<" phi: "<<a<<std::endl;
	Smart::StatusCode status;
	//TODO check if there could be deadlock on component startup
	// if the task is started initGMappingProcessor is called from task thread if the laser data takes some time (LMS100 startup)
	// if this parameter is send to the component the same method is called from component thread and block the component completely!
	status = COMP->stateSlave->tryAcquire("nonneutral");
	if(status != Smart::SMART_OK){
		COMP->gMappingTask->initGMappingProcessor(x, y, a);
	} else
	{
		std::cout<<"[WARNING]: Componente is active --> INIT_NEW_MAP not allowed!"<<std::endl;
		COMP->stateSlave->release("nonneutral");
	}
	std::cout<<"INIT_NEW_MAP PARM DONE"<<std::endl;
}
void TriggerHandler::handleCommLocalizationObjects_SlamParameter_SAVEMAP(const std::string &dirname, const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
		// trigger as active in the model. For an active trigger an active queue will be generated internally
		// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
		if(COMP->mymap==NULL)
		{
			std::cout<<"No map inizialized!"<<std::endl;
			return;
		}

		COMP->mapLock.acquire();
		// map context informations
		const unsigned map_size_x = COMP->mymap->getMapSizeX();
		const unsigned map_size_y = COMP->mymap->getMapSizeY();
		double resolution = COMP->mymap->getResolution();
		GMapping::Point origin = COMP->mymap->map2world(GMapping::IntPoint(0, 0));

		double origin_x = origin.x;
		double origin_y = origin.y;
		double origin_z = 0.0;

		int negate = 0;
		double occupied_thresh = 0.65;
		double free_thresh = 0.196;

		const char occupied = 0;
		const char unknown = 205;
		const char freeSpace = 255;

		try	{

		// create a single channel image with the same size and double depth as the map
		//	IplImage* image = cvCreateImage(cvSize(map_size_x, map_size_y), IPL_DEPTH_64F, 1);
		IplImage* image = cvCreateImage(cvSize(map_size_x, map_size_y), IPL_DEPTH_8U, 1);

		// copy map into a image
		double value = 0.0;

		//				char scaledValue = 0;
		for (unsigned int y = 0; y < map_size_y; y++)
		{
			for (unsigned int x = 0; x < map_size_x; x++)
			{
				char* ptr = image->imageData + (y * image->widthStep) + x;
				value = COMP->mymap->cell((int)x, (int)y);

				/*						if(value < free_thresh && value >= 0.0) // is cell free
							{
				 *ptr = freeSpace;
							}
							else if(value > occupied_thresh) // is cell occupied
							{
				 *ptr = occupied;
							}
							else if(value < occupied_thresh && value > free_thresh)// cell state is unknown
							{
				 *ptr = unknown;
							}
							else // handle initial values lower than 0
							{
				 *ptr = unknown;
							}

				 */
				if(value < 0.0)
				{
					*ptr = unknown;
				}
				else if(value > free_thresh)
				{
					*ptr = occupied;
				}
				else
				{
					*ptr = freeSpace;
				}

			}
		}
		cvFlip(image, NULL, 0); // 0 == horizontal flip


		char  mapFileName[255];
		char  mapFileNameWithPath[255];
		sprintf(mapFileName,"%s.pgm", filename.c_str());
		sprintf(mapFileNameWithPath,"%s/%s.pgm", dirname.c_str(), filename.c_str());

		// save image to file mapAsPGM.pgm

#ifdef WITH_OPENCV_4_2_VERSION
		cv::Mat mat = cv::cvarrToMat(image);
//		bool saved = cv::imwrite(mapFileNameWithPath,cv::Mat(map_size_y,map_size_x,CV_8UC1,image->imageData));
		bool saved = cv::imwrite(mapFileNameWithPath,mat);
#else
		bool saved = cvSaveImage(mapFileNameWithPath,image);
#endif
		if(!saved) std::cout << "Failed to save map file to the disk" << mapFileNameWithPath << std::endl;

		// save context information in yaml format

		char  yamlFileName[255];
		sprintf(yamlFileName,"%s/%s.yaml", dirname.c_str(), filename.c_str());

#ifdef WITH_OPENCV_4_2_VERSION
		cv::FileStorage fs( yamlFileName, cv::FileStorage::Mode::WRITE);
		fs<<"image" <<mapFileName;
		fs<<"resolution"<<resolution;
		fs<<"negate"<< negate;
		fs<< "occupied_thresh"<<occupied_thresh;
		fs<< "free_thresh" <<free_thresh;
		fs.release();

		ofstream myfile;
		myfile.open(yamlFileName, ios::app);
		myfile << "origin: " << "[" << origin_x << "," << origin_y << "," << origin_z << "]\n";
		myfile.close();
#else
		CvFileStorage* fs = cvOpenFileStorage( yamlFileName, 0, CV_STORAGE_WRITE);
		cvWriteString( fs, "image", mapFileName);
		cvWriteReal( fs, "resolution", resolution);

		cvWriteInt( fs, "negate", negate);
		cvWriteReal( fs, "occupied_thresh", occupied_thresh);
		cvWriteReal( fs, "free_thresh", free_thresh);
		cvReleaseFileStorage( &fs );

		ofstream myfile;
		myfile.open(yamlFileName, ios::app);
		myfile << "origin: " << "[" << origin_x << "," << origin_y << "," << origin_z << "]\n";
		myfile.close();
#endif

		// clean up image
		cvReleaseImage(&image);

		COMP->mapLock.release();
		std::cout << "GMAPPING_SAVE_MAP: saved - " << mapFileNameWithPath << "\n";
		}
		catch (cv::Exception& e){
			const char* err_msg = e.what();
			std::cout << "exception caught: " << err_msg << std::endl;
			std::cout<<"ERROR: Could not save map!"<<std::endl;
		}
}
