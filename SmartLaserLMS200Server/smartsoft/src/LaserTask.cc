//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Christian Schlegel (schlegel@hs-ulm.de)
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//
//  Copyright (C) 2003 Boris Kluge
//                2009 Andreas Steck
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

#include "LaserTask.hh"
#include "SmartLaserLMS200Server.hh"

#include <iostream>

LaserTask::LaserTask(Smart::IComponent *comp) 
:	LaserTaskCore(comp)
{
	std::cout << "constructor LaserTask\n";
}
LaserTask::~LaserTask() 
{
	std::cout << "destructor LaserTask\n";
}

void LaserTask::setLaserScan(const CommBasicObjects::CommMobileLaserScan &scan)
{
	SmartACE::SmartGuard g(mutex);
	laser_scan =  scan;
}

CommBasicObjects::CommMobileLaserScan LaserTask::getLaserScan() const
{
	SmartACE::SmartGuard g(mutex);
	return laser_scan;
}


int LaserTask::on_entry()
{
	update_count = 0;
	startTime = 0;
	stopTime = 0;


	  while(!init_laser(laser))
	  {
	    std::cerr << "WARNING: failed to init laser, retry in one second" << std::endl;
	    sleep(1);
	  }
	return 0;
}
int LaserTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
    if (laser.read_laser_data()==0)
    {
      bool base_state_valid = false;

      scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp(laser.get_receive_timestamp()));
      scan.set_scan_update_count(update_count);

      //////////////////////////
      // set base state
      //
      if(COMP->getGlobalState().getBase().getSubscribe()== true)
      {
        Smart::StatusCode status = this->baseStateInGetUpdate(base_state);  //base->getUpdate(base_state);
        if(status!=Smart::SMART_OK)
        {
          std::cerr << "WARNING: failed to get current base state (" << status << "), pushing invalid scan" << std::endl;
          scan.set_scan_valid(false);
        }
        else base_state_valid = true;
      }
      else
      {
        base_state.set_time_stamp(CommBasicObjects::CommTimeStamp(laser.get_receive_timestamp()));
        CommBasicObjects::CommBasePose default_base_position;
        default_base_position.set_x(COMP->getGlobalState().getBase().getX());
        default_base_position.set_y(COMP->getGlobalState().getBase().getY());
        default_base_position.set_z(COMP->getGlobalState().getBase().getZ());
        default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());
        base_state.set_base_position(default_base_position);
        base_state.set_base_velocity(zero_velocity);
        base_state_valid = true;
      }
      scan.set_base_state(base_state);

      //////////////////////////
      // set scanner position
      //
      double base_x = 0;
      double base_y = 0;
      double base_z = 0;
      double base_a = 0;
      if(base_state_valid)
      {
        base_x = base_state.get_base_position().get_x();
        base_y = base_state.get_base_position().get_y();
        base_z = base_state.get_base_position().get_z();
        base_a = base_state.get_base_position().get_base_azimuth();

      }
      const double sin_base_a = sin(base_a);
      const double cos_base_a = cos(base_a);
      scan.set_scanner_x(base_x + COMP->getGlobalState().getLaser().getX() * cos_base_a - COMP->getGlobalState().getLaser().getY() * sin_base_a);
      scan.set_scanner_y(base_y + COMP->getGlobalState().getLaser().getX() * sin_base_a + COMP->getGlobalState().getLaser().getY() * cos_base_a);
      scan.set_scanner_z(base_z + COMP->getGlobalState().getLaser().getZ());
      scan.set_scanner_azimuth(base_a + COMP->getGlobalState().getLaser().getAzimuth());

      CommBasicObjects::CommPose3d SensorOffset(COMP->getGlobalState().getLaser().getX(), COMP->getGlobalState().getLaser().getY(), COMP->getGlobalState().getLaser().getZ(), COMP->getGlobalState().getLaser().getAzimuth(), 0, 0);
      scan.set_sensor_pose(SensorOffset);

      //////////////////////////
      // set scan parameters
      //
      scan.set_scan_length_unit(laser.extract_length_unit());
      scan.set_scan_integer_field_of_view(-50 * int(laser.width), laser.resolution);

      //////////////////////////
      // get maximum non-overflow distance
      //
      const unsigned int max_dist = laser.get_max_distance();
      scan.set_max_distance(max_dist);
      scan.set_min_distance(20);

      //////////////////////////
      // set scan points
      //
      const unsigned int num_points = laser.extract_num_points();
      unsigned int num_valid_points = 0;
      for(unsigned int i=0; i<num_points; ++i)
      {
        if(laser.extract_distance(i) <= max_dist) ++num_valid_points;
      }
      scan.set_scan_size(num_valid_points);
      unsigned int valid_point_index = 0;
      for(unsigned int i=0; i<num_points; ++i)
      {
        const unsigned int dist = laser.extract_distance(i);
        if(dist <= max_dist)
        {
          scan.set_scan_index(valid_point_index, i);
          scan.set_scan_integer_distance(valid_point_index, dist);
          scan.set_scan_intensity(valid_point_index, laser.extract_intensity(i));
          ++valid_point_index;
        }
      }
      scan.set_scan_valid(base_state_valid /* && ... */);

      Smart::StatusCode push_status = this->laserServiceOutPut(scan);
      if(push_status!=Smart::SMART_OK)
      {
        std::cerr << "WARNING: error on push (" << push_status << ")" << std::endl;
      }

      this->setLaserScan(scan);

      /*
            const unsigned int index = 180;
            if(_verbose) std::cout << "Scan " << update_count << " sent." << " Scan Position " << index << " = " << scan.get_scan_distance(index) << " mm"<< std::endl;
      */

      const unsigned int num_scans_freq = 200;
      if(update_count== 0)
      {

          ts = laser.get_receive_timestamp();
          startTime = ts.tv_sec * 1000000 + ts.tv_usec;
          std::cout << "\n\nlaser is ready. measure frequency (first "<< num_scans_freq << " scans)...\n";
      }
      else if(update_count == num_scans_freq)
      {
    	  ts = laser.get_receive_timestamp();
    	  stopTime = ts.tv_sec * 1000000 + ts.tv_usec;
    	  std::cout << "...frequency is " << (double)num_scans_freq / (double)(stopTime-startTime) * 1000000.0 << " Hz.\n";
      }
      ++update_count;
    }
    else
    {
      std::cerr << "WARNING: received unexpected packet type" << std::endl;
    }

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int LaserTask::on_exit()
{
	laser.close_device();

	  if(COMP->getGlobalState().getBase().getSubscribe())
	  {
		status = COMP->baseStateIn->unsubscribe();
		if(status!=Smart::SMART_OK)
		{
		  std::cerr << "WARNING: failed to unsubscribe from base state service laser server" << std::endl;
		  std::cerr << "WARNING: (" << status << ")" << std::endl;
		}
	  }
	return 0;
}

bool LaserTask::init_laser(Smart::SickInterface &laser) const
{
  // set up laser connection
  laser.verbose = COMP->getGlobalState().getLaser().getVerbose();
  laser.length_unit = COMP->getGlobalState().getLaser().getLength_unit();

  laser.resolution = COMP->getGlobalState().getLaser().getResolution();
  if(laser.resolution==25)
  {
    laser.width = 100;
  }
  else
  {
    laser.width = 180;
  }

  laser.bitrate = COMP->getGlobalState().getLaser().getBaudrate();
  laser.term_bitrate = COMP->getGlobalState().getLaser().getBaudrate();

  if(COMP->getGlobalState().getLaser().getSick_type() == "LMS")
  {
    laser.sick_type = Smart::SickInterface::LMS;
  }
  else if(COMP->getGlobalState().getLaser().getSick_type()=="PLS")
  {
    laser.sick_type = Smart::SickInterface::PLS;
  }
  else
  {
    std::cerr << "WARNING: unknown SICK type \"" << COMP->getGlobalState().getLaser().getSick_type() << "\", using default (\"LMS\")." << std::endl;
    laser.sick_type = Smart::SickInterface::LMS;
  }

  if(laser.open_device(COMP->getGlobalState().getLaser().getDevice().c_str()))
  {
    std::cerr << "ERROR: laser.open_device(\"" << COMP->getGlobalState().getLaser().getDevice() << "\") failed." << std::endl;
    return false;
  }
  unsigned int current_laser_speed = 0;
  std::string laser_type;
  if(laser.probe_sick_speed(current_laser_speed, laser_type))
  {
    std::cerr << "ERROR: probe_laser_speed() failed." << std::endl;
    return false;
  }
  if(COMP->getGlobalState().getLaser().getVerbose())
  {
    std::cout << "Connected to \"" << laser_type << "\", initially at " << current_laser_speed << "bps" << std::endl;
  }
  if(laser.set_laser_config())
  {
    std::cerr << "ERROR: set_laser_config() failed." << std::endl;
    return false;
  }
  for(unsigned int retry = 0; true; ++retry)
  {
    if(laser.request_laser_data()==0) break;
    if (retry >= 5)
    {
      std::cerr << "ERROR: request_laser_data() failed." << std::endl;
      return false;
    }
  }
  if(COMP->getGlobalState().getLaser().getVerbose())
  {
    std::cout << "Laser ready." << std::endl;
  }
  return true;
}
