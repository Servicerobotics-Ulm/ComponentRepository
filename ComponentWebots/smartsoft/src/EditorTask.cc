//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C)  2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "EditorTask.hh"
#include "ComponentWebots.hh"
#include <webots/Supervisor.hpp>
#include <webots/Keyboard.hpp>
#include <webots/utils/AnsiCodes.hpp>
#include <unordered_map>

#include <iostream>

using namespace webots;
using namespace std;

struct Pose2D{
    double x, y, heading;
};

// the webots node must have coordinate system x=front, y=left, z=up.
// webots WorldInfo.coordinateSystem must be ENU. (copied from ComponentWebotsMpsDocking)
Pose2D getNodePose(Node *node) {
  const double *position = node->getPosition();
  const double *orientation = node->getOrientation();
  Pose2D pose = { position[0], position[1], atan2(orientation[3], orientation[0]) };
  return pose;
}

EditorTask::EditorTask(SmartACE::SmartComponent *comp) :
    EditorTaskCore(comp) {
    cout << "constructor EditorTask\n";
}

EditorTask::~EditorTask() {
    cout << "destructor EditorTask\n";
}

int EditorTask::on_entry() {
    return 0;
}

// get heading from a webots node (world must have NUE coordinate system, node must have z-axis up => standing upright, not falling)
// (ComponentWebotsRobotArm helper functions would be better, but are more code)
double getHeadingFromWebotsNode(Node* node) {
    const double *matrix = node->getOrientation();
    return atan2(matrix[3], matrix[0]);
}

Field* create_group(int place, string def_name, Supervisor *robot) {
    Node* node = robot->getFromDef(def_name);
    if(!node) {
        robot->getRoot()->getField("children")->importMFNodeFromString(place, "DEF "+def_name+" Group {}");
        node = robot->getFromDef(def_name);
    }
    return node->getField("children");
}

int EditorTask::on_execute() {
    if (!COMP->getParameters().getGeneral().getEnableEditor()) {
        cout << " \033[0;32mEditor disabled\033[0m" << endl;
        return -1;
    }
    string name = "Editor";
    char environment[256] = "WEBOTS_ROBOT_NAME=";
    putenv(strcat(environment, name.c_str()));
    cout << AnsiCodes::GREEN_FOREGROUND + " Connect to webots robot with name '" << name << "' ..." + AnsiCodes::RESET << endl;
    Supervisor *robot = new Supervisor();
    if (!robot) {
        cerr << "Webots Robot '" << name << "' not found" << endl;
        return -1;
    }
    int timeStep = (int) robot->getBasicTimeStep();
    Keyboard *keyboard = robot->getKeyboard();
    keyboard->enable(timeStep);
    create_group(4, "Locations", robot);
    create_group(5, "Stations", robot);
    create_group(6, "Waypoints", robot);
    create_group(7, "WaypointConnections", robot);
    Node *proto = robot->getSelf(); // ->getParentNode();
    // Node *proto = robot->getFromDef("EDITOR");
    if(!proto || proto->getTypeName()!="Editor") {
        cerr << "Webots DEF EDITOR Editor not found" << endl;
        return -1;
    }
    vector<string> last_updateStrings;
    bool firstRun = true;
    int lastKey = -1;
    bool wasWaypoint = false;
    int lastSelectedId;
    bool lastShowWaypoints = true;
    struct XY { double x; double y; };
    while (robot->step(timeStep) != -1) {
        if(firstRun) {
            cout << AnsiCodes::GREEN_FOREGROUND + " Webots simulation started" + AnsiCodes::RESET << endl;
        }
        Node* selectedNode = robot->getSelected();
        const string LOCATION = "Location";
        const string STATION = "Station";
        const string WAYPOINT = "Waypoint";
        const string WAYPOINTCONNECTION = "WaypointConnection";
        string selectedType = "";
        if(selectedNode) {
            selectedType = selectedNode->getTypeName();
            if(selectedType != LOCATION && selectedType != STATION && selectedType != WAYPOINT && selectedType != WAYPOINTCONNECTION)
                selectedType = "";
        }
        int key = keyboard->getKey();
        if((key=='-' || key==7) && selectedType!="") {
            // deleting nodes and reading them from a supervisor can crash
            selectedNode->remove(); // next timeStep() will remove connections with missing id's and update ComponentNavigationGraph
            continue;
        }
        bool showWaypoints = proto->getField("showWaypoints")->getSFBool();
        double defaultWidth = proto->getField("defaultWaypointWidth")->getSFFloat();
        if(key=='/' && (selectedType==WAYPOINT || selectedType==WAYPOINTCONNECTION)) {
            selectedNode->getField("width")->setSFFloat(defaultWidth);
        }
        Field *locations = robot->getFromDef("Locations")->getField("children");
        Field *stations = robot->getFromDef("Stations")->getField("children");
        Field *waypointsField = robot->getFromDef("Waypoints")->getField("children");
        Field *waypointConnectionsField = robot->getFromDef("WaypointConnections")->getField("children");
/*      user has to stop simulation himself during editing, at least if he deletes something
        // if user deletes a station, a supervisor function call to read stations could crash
        // => don't do it if Editor or something inside is selected
        Node *selected = robot->getSelected();
        while (selected != NULL && selected != proto)
            selected = selected->getParentNode();
        if (selected)
            continue;
*/

        //////////////////////////
        // Locations and Stations
        //////////////////////////

        unordered_map<int, XY> station_id_to_xy;
        int count = locations->getCount();
        int count2 = stations->getCount();
        vector<string> updateStrings;

        updateStrings.push_back("(kb-delete :key '(is-a) :value '((is-a location)) )");
        updateStrings.push_back("(kb-delete :key '(is-a) :value '((is-a station)) )");

        // problem: each timestep
        //          stations position change a little bit by gravity and wheels
        //          => station's waypoint position changes too
        //          => WaypointConnection parameter change
        //          => proto regeneration of WaypointConnection very often
        //          => very slow
        // solution: round station position to mm
        // problem:
        //    rounded values can change too (if the real values are close to .5 mm)
        //    all locations/stations are updated (deleted and added to knowledge base)
        //    during this update time, other components may read missing data
        //    (solution: make it possible to update knowledgebase atomically)
        for (int i = count+count2; i--;) {
            string name;
            Pose2D locationPose;
            double radius, smallerRadius;
            if(i<count) {
                Node *node = locations->getMFNode(i);
                const double *coord = node->getField("translation")->getSFVec3f();
                locationPose = getNodePose(node);
                name = node->getField("name")->getSFString();
                radius = node->getField("radius")->getSFFloat();
                smallerRadius = node->getField("smallerRadius")->getSFFloat();
            } else {
                Node *station = stations->getMFNode(i-count);
                bool isProto = station->isProto();
                Node *dockingPoint=NULL;
                if(isProto)
                  dockingPoint=station->getFromProtoDef("DockingPoint");
                if(!isProto || dockingPoint==NULL || !dockingPoint) {
                    cerr << (i-count+1) << ". children in Stations removed (" <<
                        (!isProto ? "not proto" : "has no DEF DockingPoint") <<
                        ") " << station->getTypeName() << endl;
                    station->remove();
                    continue;
                }
                // code from ComponentWebotsMPSDocking
                Pose2D poseDocking = getNodePose(dockingPoint);
                Pose2D pose2 = getNodePose(station);
                pose2.x += (poseDocking.x - pose2.x) * 1.6;
                pose2.y += (poseDocking.y - pose2.y) * 1.6;
                pose2.heading += M_PI;
                locationPose = pose2;
                int stationId = station->getField("id")->getSFInt32();
                name = "Station"+to_string(stationId);
                int waypointId = station->getField("waypointId")->getSFInt32();
                if(waypointId >= 0) {
                    XY _xy = {.x=round(locationPose.x * 1000) / 1000, .y=round(locationPose.y * 1000) / 1000};
                    station_id_to_xy[waypointId] = _xy;
                }
                updateStrings.push_back(
                    "(kb-update"
                    " :key '(is-a id)"
                    " :value '("
                    " (is-a station)"
                    " (id " + to_string(stationId) + ")"
                    " (approach-location " + name + ")"
                    + ( waypointId<0
                        ? ""
                        : (" (approach-waypoint " + to_string(waypointId) + ")")
                      ) +
                    " (docking-type LASER-IR)"
                    " (type mps)))");
                radius = 0.15;
                smallerRadius = 0.0;
            }
            string approachType;
            if(smallerRadius == 0)
                approachType = "region";
            else if(smallerRadius > 0)
                approachType = "exact";
            else
                approachType = "halt-point";

            updateStrings.push_back(
                "(kb-update"
                "  :key '(is-a name)"
                "  :value '("
                "    (is-a location)"
                "    (name " + name + ")"
                "    (approach-type (" + approachType + "))"
                "    (approach-region-pose ("
                + to_string(lround(locationPose.x * 1000)) + " "
                + to_string(lround(locationPose.y * 1000)) + " 0))"
                "    (approach-region-dist " + to_string(lround(radius * 1000)) + ")"
                "    (orientation-region (angle-absolute "+to_string(lround(locationPose.heading/M_PI*180))+"))"
                + (smallerRadius != 0.0 ? (
                    "    (approach-exact-pose ("
                    + to_string(lround(locationPose.x * 1000)) + " "
                    + to_string(lround(locationPose.y * 1000)) + " 0))"
                    "    (approach-exact-dist " + to_string(lround(smallerRadius * 1000)) + ")"
                    "    (orientation-exact (angle-absolute "+to_string(lround(locationPose.heading/M_PI*180))+"))"
                    "    (approach-exact-safetycl 0)"
                ): "") +
                "    (backward-dist 500)"
                ")) ");
        }
        if(updateStrings != last_updateStrings) {
            cout << "Locations or Stations updated " << updateStrings.size() << endl;
            last_updateStrings = updateStrings;
            for(string s : updateStrings) {
                CommBasicObjects::CommKBRequest kbReq;
                CommBasicObjects::CommKBResponse kbResp;
                kbReq.setRequest(s);
                COMP->commKBQueryReq->query(kbReq, kbResp);
            }
        }
        ////////////////////////////////////
        // Waypoints and WaypointConnections
        ////////////////////////////////////

        // https://www.modernescpp.com/index.php/hash-tables
        unordered_map<int, XY> id_to_xy;

        count = waypointsField->getCount();
        for (int i = count; i--;) {
            Node *node = waypointsField->getMFNode(i);
            if(node->getTypeName() != WAYPOINT) {
                cerr << "ERROR: wrong type " << node->getTypeName() << " in Waypoints removed" << endl;
                waypointsField->removeMF(i);
                continue;
            }
            int id = node->getField("id")->getSFInt32();
            if(id_to_xy.count(id) > 0) {
                cerr << "ERROR: double " << id << " waypoint deleted" << endl;
                waypointsField->removeMF(i);
                continue;
            }

            XY _xy;
            if(station_id_to_xy.count(id) > 0) {
                _xy = station_id_to_xy[id];
                const double xyz[3] = {_xy.x, _xy.y, 0};
                node->getField("translation")->setSFVec3f(xyz);
                station_id_to_xy.erase(id);
            } else {
                const double *coord = node->getField("translation")->getSFVec3f();
                _xy = {.x=coord[0], .y=coord[1]};
            }
            id_to_xy[id] = _xy;
            if(showWaypoints != lastShowWaypoints)
                node->getField("showWaypoints")->setSFBool(showWaypoints);
        }
        if(showWaypoints != lastShowWaypoints)
            cout << "change showWaypoints to " << showWaypoints << endl;

        for(auto wp:station_id_to_xy) {
            int id= wp.first;
            XY _xy = wp.second;
            id_to_xy[id] = _xy;
            string s = "Waypoint {\n"
                "  id "+to_string(id)+"\n"
                "  translation "+to_string(_xy.x)+" "+to_string(_xy.y)+" 0\n"
                "  width "+to_string(defaultWidth)+"\n"
                "}";
            cout << "Import Waypoint id  " << id << " for Station" << endl;
            waypointsField->importMFNodeFromString(-1, s);
        }
        struct waypointConnection { int startId; int endId; double width;};
        vector<waypointConnection> waypointConnections;
        count = waypointConnectionsField->getCount();
        for (int i = count; i--;) {
            Node *node = waypointConnectionsField->getMFNode(i);
            if(node->getTypeName() != WAYPOINTCONNECTION) {
                cout << "ERROR: wrong type " << node->getTypeName() << " in WaypointConnections removed" << endl;
                waypointConnectionsField->removeMF(i);
                continue;
            }
            waypointConnection w = {
               .startId = node->getField("startId")->getSFInt32(),
               .endId = node->getField("endId")->getSFInt32(),
               .width = node->getField("width")->getSFFloat()
            };
            if(id_to_xy.count(w.startId) == 0 || id_to_xy.count(w.endId) == 0) {
                cout << "ERROR: missing ids " << w.startId << " " << w.endId << " waypointConnection deleted" << endl;
                waypointConnectionsField->removeMF(i);
                continue;
            }
            waypointConnections.push_back(w);
            const double startCoord[2] = {id_to_xy[w.startId].x, id_to_xy[w.startId].y};
            node->getField("startCoord")->setSFVec2f(startCoord);
            const double endCoord[2] = {id_to_xy[w.endId].x, id_to_xy[w.endId].y};
            node->getField("endCoord")->setSFVec2f(endCoord);
            if(showWaypoints != lastShowWaypoints)
                node->getField("showWaypoints")->setSFBool(showWaypoints);
        }

        bool isWaypoint = selectedType == WAYPOINT;
        bool isConnection = selectedType == WAYPOINTCONNECTION;

        int selectedId;
        if(isWaypoint) {
            selectedId = selectedNode->getField("id")->getSFInt32();
            double x=id_to_xy[selectedId].x;
            double y=id_to_xy[selectedId].y;
            const double redColor[3] = {1.0, 0.0, 0.0};
            const double greenColor[3] = {0.0, 1.0, 0.0};
            bool isError = false;
            for(auto p:id_to_xy) {
                if(p.first != selectedId && sqrt(pow(x-p.second.x,2)+pow(y-p.second.y,2))<defaultWidth*0.9999) {
                    isError = true;
                    break;
                }
            }
            selectedNode->getField("color")->setSFColor(isError ? redColor : greenColor);
        }
        bool addConnection = false;
        int startId, endId;
        // insert key == 6
        if((key=='+' || key==6) && lastKey==-1) {
            int id=0;
            double x=0.0;
            double y=0.0;
            if(isWaypoint) {
                id = selectedId;
                x = id_to_xy[id].x + defaultWidth;
                y = id_to_xy[id].y;
            }
            id++;
            while(id_to_xy.count(id) > 0)
                id++;
            string s = "Waypoint {\n"
                "  id "+to_string(id)+"\n"
                "  translation "+to_string(x)+" "+to_string(y)+" 0\n"
                "  width "+to_string(defaultWidth)+"\n"
                "}";
            waypointsField->importMFNodeFromString(-1, s);
            if(isWaypoint) {
                addConnection = true;
                startId = selectedId;
                endId = id;
            }
        }
        // * key pressed and a Waypoint was selected and now new Waypoint is selected
        if(key=='*' && isWaypoint && wasWaypoint && lastSelectedId!=selectedId) {
            bool isDouble = false;
            for(waypointConnection con:waypointConnections)
                if(con.startId==lastSelectedId || con.startId==selectedId)
                    if(con.endId==lastSelectedId || con.endId==selectedId)
                        isDouble = true;
            if(!isDouble) {
                addConnection = true;
                startId = lastSelectedId;
                endId = selectedId;
            }
        }
        if(addConnection) {
            waypointConnectionsField->importMFNodeFromString(-1, "WaypointConnection {\n"
                "startId "+to_string(startId)+"\n"
                "endId "+to_string(endId)+"\n"
                "startCoord "+to_string(id_to_xy[startId].x)+" "+to_string(id_to_xy[startId].y)+"\n"
                "endCoord "+to_string(id_to_xy[endId].x)+" "+to_string(id_to_xy[endId].y)+"\n"
                "width "+to_string(defaultWidth)+"\n"
                "}");
        }
        if((lastKey==' ' and key==-1) || firstRun) {
            std::vector<DomainRobotFleetNavigation::CommPath> navPath;
            int counter=1;
            for(waypointConnection con:waypointConnections) {
                DomainRobotFleetNavigation::CommPath path;
                std::vector<DomainRobotFleetNavigation::CommNode> nodes;
                DomainRobotFleetNavigation::CommNode startNode, endNode;
                startNode.setId(con.startId);
                startNode.setX(id_to_xy[con.startId].x);
                startNode.setY(id_to_xy[con.startId].y);
                endNode.setId(con.endId);
                endNode.setX(id_to_xy[con.endId].x);
                endNode.setY(id_to_xy[con.endId].y);
                nodes.push_back(startNode);
                nodes.push_back(endNode);
                path.setNode(nodes);
                path.setDirection(0);
                path.setWidth(con.width);
                path.setId(counter);
                navPath.push_back(path);
                counter++;
            }
            DomainRobotFleetNavigation::CommNavPath _navPath;
            _navPath.setPath(navPath);
            COMP->navPathServiceOut->send(_navPath);
        }
        wasWaypoint = isWaypoint;
        lastSelectedId = selectedId;
        lastKey = key;
        lastShowWaypoints = showWaypoints;
        firstRun = false;
    }
    return 0;
}

int EditorTask::on_exit() {
    return 0;
}
