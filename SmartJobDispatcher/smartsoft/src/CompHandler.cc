//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//  BSD 3-Clause License
//
//  Copyright (C) Servicerobotics Ulm
//  University of Applied Sciences Ulm
//  Prittwitzstr. 10
//  89075 Ulm
//  Germany
//  All rights reserved.
//
//  Author: Matthias Lutz
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//
//* Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//
//* Redistributions in binary form must reproduce the above copyright notice,
//  this list of conditions and the following disclaimer in the documentation
//  and/or other materials provided with the distribution.
//
//* Neither the name of the copyright holder nor the names of its
//  contributors may be used to endorse or promote products derived from
//  this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//--------------------------------------------------------------------------

#include "CompHandler.hh"
#include "SmartJobDispatcher.hh"

#include <iostream>
#include <string>

// include communication objects
#include <CommBasicObjects/CommKBRequest.hh>
#include <CommBasicObjects/CommKBResponse.hh>
#include <DomainSymbolicPlanner/CommSymbolicPlannerPlan.hh>
#include <DomainSymbolicPlanner/CommSymbolicPlannerRequest.hh>
#include <CommBasicObjects/CommTaskMessage.hh>
#include <CommBasicObjects/CommTaskEventState.hh>

#include "switchSymbolicPlanner.hh"
#include "switchKnowledgeBase.hh"
#include "switchWiring.hh"
#include "switchHighLevelCommand.hh"
#include "switchPathNavigationServer.hh"
#include "switchFileProvider.hh"
#include "switchRobotinoRPCBridge.hh"
#include "switchMapper.hh"
#include "switchRobotStateViewer.hh"
#include "switchNavigationCoordinationServer.hh"

#if defined (__GNUC__) && defined(__unix__)

#elif defined (WIN32) || defined (WIN64)
#include "ace\Init_ACE.h"
#endif

#include "CompTask.hh"

//CompTask can not be a managed task!
CompTask COMP_TASK;

#if defined (__GNUC__) && defined(__unix__)
extern "C" char* command(char *inString)
#elif defined (WIN32) || defined (WIN64)
extern "C" __declspec(dllexport) char* command(char *inString)
#endif
{
//	std::cout<<__FUNCTION__<<": inString: "<<inString<<std::endl;

	std::string inStringStd = inString;

	//the buffer will be freed on the lisp side
	char* rtrn = NULL;
	//10 bytes extra for () the spaces and the null termination
	unsigned int char_size = 10;

	std::string tmp_buffer;
	tmp_buffer = switchModule(inStringStd);

	char_size += tmp_buffer.size();

	rtrn = (char *)malloc(char_size * sizeof(char));
	strcpy(rtrn, tmp_buffer.c_str());


//	std::cout<<__FUNCTION__<<": rtrn: "<<rtrn<<std::endl;
	return rtrn;
}

#if defined (__GNUC__) && defined(__unix__)
extern "C" char* getjobmsg()
#elif defined (WIN32) || defined (WIN64)
extern "C" __declspec(dllexport) char* getjobmsg()
#endif
{

	//the buffer will be freed on the lisp side
	char* rtrn = NULL;
	//10 bytes extra for () the spaces and the null termination
	unsigned int char_size = 10;

	std::cout<<"Wait for MSG!"<<std::endl;

	std::string msg = COMP->jobBuffer.removeEntry();

	char_size += msg.size();

	std::cout<<"Got MSG|"<<msg<<"|"<<std::endl;

	rtrn = (char *)malloc(char_size * sizeof(char));
	strcpy(rtrn, msg.c_str());

	return rtrn;
}

#if defined (__GNUC__) && defined(__unix__)
extern "C" void sendjobmsg(char*jobmsg,char*robot)
#elif defined (WIN32) || defined (WIN64)
extern "C" __declspec(dllexport) void sendjobmsg(char*jobmsg,char*robot)
#endif
{

	std::cout<<"jobMSG"<<jobmsg<<std::endl;
	std::cout<<"robot"<<robot<<std::endl;

	CommBasicObjects::CommTaskEventState state;
	CommBasicObjects::CommTaskMessage message;
	message.setMsg(jobmsg);
	state.setRobotTarget(robot);
	state.setJob(message);
	COMP->jobEventServer->put(state);

}

#if defined (__GNUC__) && defined(__unix__)
extern "C" void delay(int x)
#elif defined (WIN32) || defined (WIN64)
extern "C" __declspec(dllexport) void delay(int x)
#endif
{
	ACE_OS::sleep(ACE_Time_Value(0, x));
}

void CompHandler::onStartup() 
{
	//DO NOT USE THIS METHOD, IT IS NEVER CALLED!
//	std::cout << "startup - put your startupCode in CompHandler::onStartup()!!!\n";
//
//	Smart::StatusCode status;
//
//	// Start all services. If you need manual control, use the content of this function to
//	// connect and start each service individually, e.g:
//	// COMP->connectMyPortName("SmartExampleComponent", "examplePort");
//	status = COMP->connectAndStartAllServices();
//
//	// Start all tasks. If you need manual control, use the content of this function to
//	// start each task individually.
//	COMP->startAllTasks();
//
//	// Start all timers. If you need manual control, use the content of this function to
//	// start each timer individually.
//	COMP->startAllTimers();
//
//	// Notify the component that setup/initialization is finished.
//	// You may move this function to any other place.
//	COMP->setStartupFinished();
}

void CompHandler::onShutdown()
{
	//DO NOT USE THIS METHOD, IT IS NEVER CALLED!

//	std::cout << "shutdown - put your cleanup code in CompHandler::onShutdown()!!!\n";
	
}

#if defined (__GNUC__) && defined(__unix__)
extern "C" int initialize(char* param)
#elif defined (WIN32) || defined (WIN64)
extern "C" __declspec(dllexport) int initialize(char* param)
#endif
{
	Smart::StatusCode status;

	// force to use point as decimal seperator (required because of SBCL)
	setlocale(LC_NUMERIC, "C");

	std::cout << "initialize  param: " << param << "\n";


	std::istringstream iss(param);
	std::string s;
	std::vector< std::string > list;
	while ( getline( iss, s, ' ' ) ) {
		list.push_back(s);
	}

	//char *argv[list.size()];
	char** argv = new char*[list.size()];
	for(unsigned int i=0;i<list.size();i++){
		argv[i] = const_cast<char*> (list[i].c_str());
	}

#if defined (__GNUC__) && defined(__unix__)
#elif defined (WIN32) || defined (WIN64)
	//TODO why is this needed with win?
	std::cout << "ACE init..." << std::endl;
	ACE::init();
	std::cout << "DONE ACE init" << std::endl;
#endif

	//	argv[0] = (char*)"dummy";
	//	argv[1] = paramFile;
	COMP->init(list.size(), argv);

	// start all tasks
	COMP_TASK.start();

	//status = COMP->connectAndStartAllServices();

	status = COMP->connectJobSourceEventClient(COMP->connections.jobSourceEventClient.serverName, COMP->connections.jobSourceEventClient.serviceName);

	status = COMP->connectJobSource2EventClient(COMP->connections.jobSource2EventClient.serverName, COMP->connections.jobSource2EventClient.serviceName);

	status = COMP->connectCommKBQueryReq(COMP->connections.commKBQueryReq.serverName, COMP->connections.commKBQueryReq.serviceName);

	status = COMP->connectSymbolicPannerServiceReq(COMP->connections.symbolicPannerServiceReq.serverName, COMP->connections.symbolicPannerServiceReq.serviceName);

	if(COMP->getParameters().getModuleConnection().getConnectJobSource3() == true){
		COMP->connectJobSource3EventClient(COMP->connections.jobSource3EventClient.serverName, COMP->connections.jobSource3EventClient.serviceName);
		CommBasicObjects::CommTaskMessage tclParam;
		Smart::EventIdPtr id;
		COMP->jobSource3EventClient->activate(Smart::continuous,tclParam,id);
		std::cout<<"INIT activate JOB3 event!"<<std::endl;
	}

	if(COMP->getGlobalState().getModuleConnection().getConnectNavigationCoordinationServer() == true){
		//nothing to connect here
	}

	if(COMP->getGlobalState().getModuleConnection().getConnectNavigationServer() == true){
		status = COMP->connectNavigationTopologyMapQueryReq(COMP->connections.navigationTopologyMapQueryReq.serverName, COMP->connections.navigationTopologyMapQueryReq.serviceName);
		//nothing to connect here
	}

	CommBasicObjects::CommTaskMessage tclParam;
	Smart::EventIdPtr id;
	COMP->jobSourceEventClient->activate(Smart::continuous,tclParam,id);
	std::cout<<"INIT activate JOB event!"<<std::endl;

	COMP->jobSource2EventClient->activate(Smart::continuous,tclParam,id);
	std::cout<<"INIT activate JOB2 event!"<<std::endl;

	COMP->setStartupFinished();

	delete[] argv;

	return 0;
}


std::string switchModule(std::string inString)
{


	int  module;
	int  function;
	int  counter;
	int  status;

	std::string outString;

	char* cutInString = NULL;

	//10 bytes extra for () the spaces and the null termination
	unsigned int char_size = 10;
	char_size += inString.size();
	cutInString = (char *)malloc(char_size * sizeof(char));

	// read module and function number from inString
	// (leading blank in format string important to allow leading blanks !)
	status = sscanf(inString.c_str()," (%u %u %n", &module, &function, &counter);
	//remove the module info and the tailing )
	strncpy( cutInString, inString.c_str()+counter, strlen(inString.c_str())-counter-1);
	cutInString[strlen(inString.c_str())-counter-1] = '\0';

//	std::cout<<"switchModule: |"<<inString<<"|"<<"size:"<<strlen(inString.c_str())<<"\n";
//	std::cout<<" counter: "<<counter <<"tmp switchModule: |"<<cutInString<<"|\n";

	if (status != 2)
	{
		// error while reading module and function number
		outString = "(error (no module or no function number))";
	} else {

		// now counter points to the beginning of the parameter block within
		// the inString. Switch to the correct module handler with the function
		// number and parameter string.
		switch (module)
		{

		// mapper
		case 2:
		{
			outString = switchMapper(cutInString, function);
			break;
		}

		// symbolic planner
		case 6:
		{
			outString = switchSymbolicPlanner(cutInString, function);
			break;
		}

//		// base
//		case 7:
//		{
//			outString = switchBase(cutInString, function);
//			break;
//		}

		// wiring
		case 21:
		{
			outString = switchWiring(cutInString, function);
			break;
		}
		// highLevelCommand
		case 36:
		{
			outString = switchHighLevelCommand(cutInString, function);
			break;
		}

		// robotinoRPCBridge
		case 40:
		{
			outString = switchRobotinoRPCBridge(cutInString, function);
			break;
		}

		// multiRobotPathNavigation
		case 44:
		{
			outString = switchPathNavigationServer(cutInString, function);
			break;
		}

		case 42:
		{
			outString = switchKnowledgeBase(cutInString, function);
			break;
		}

		case 54:
		{
			outString = switchFileProvider(cutInString, function);
			break;
		}

		case 55:
		{
			outString = switchRobotStateViewer(cutInString, function);
			break;
		}

		case 66:
		{
			outString = switchNavigationCoordinationServer(cutInString, function);
			break;
		}

		default:
		{
			outString = "(error (no module))";
			break;

		}

		} // switch
	}

	free(cutInString);

	return outString;
} // switchModule


#if defined (__GNUC__) && defined(__unix__)
extern "C" void waitoncomptasktocomplete()
#elif defined (WIN32) || defined (WIN64)
extern "C" __declspec(dllexport) void waitoncomptasktocomplete()
#endif
{
	ACE_Thread_Manager::instance()->wait_task(&COMP_TASK);
}

