//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
//  BSD 3-Clause License
//
//  Copyright (C) Servicerobotics Ulm
//  University of Applied Sciences Ulm
//  Prittwitzstr. 10
//  89075 Ulm
//  Germany
//  All rights reserved.
//
//  Author: Matthias Lutz
//
//Redistribution and use in source and binary forms, with or without
//modification, are permitted provided that the following conditions are met:
//
//* Redistributions of source code must retain the above copyright notice, this
//  list of conditions and the following disclaimer.
//
//* Redistributions in binary form must reproduce the above copyright notice,
//  this list of conditions and the following disclaimer in the documentation
//  and/or other materials provided with the distribution.
//
//* Neither the name of the copyright holder nor the names of its
//  contributors may be used to endorse or promote products derived from
//  this software without specific prior written permission.
//
//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
//AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
//IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
//DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
//FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
//DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
//CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//--------------------------------------------------------------------------


#include "SmartJobDispatcherCore.hh"

#ifndef LISP_SEPARATOR
#define LISP_SEPARATOR " ()\"\n"
#endif

#include "DomainSymbolicPlanner/mystrsep.hh"


// constructor
SmartJobDispatcherCore::SmartJobDispatcherCore()
{
	std::cout << "constructor SmartJobDispatcherCore\n";
}

std::string SmartJobDispatcherCore::queryParam(SmartACE::ParameterMaster *parameterMaster,std::string server, char* param){

		std::string outstring;

		std::string input(param);
		Smart::StatusCode status;

		SmartACE::CommParameterRequest parameterRequest;
		SmartACE::CommParameterResponse parameterResponse;


		std::cout<<"QueryParam: "<<input<<std::endl;
		std::cout<<"Server: "<<server<<std::endl;


//		if (lispParamToParameterRequest(input,parameterRequest) == true)//param.set(input) == 0 )
//		{
			lispTokenizer.parse(input);
//			lispTokenizer.printTree();
			parameterRequest = lispTokenizer.getCommParamRequest();

			// everything is ok
//			status = COMP->amclParamClient->send(param);
			status = parameterMaster->sendParameterWait(parameterRequest, parameterResponse, server);
			switch (status)
			{
				case Smart::SMART_OK:
					switch(parameterResponse.getResponse().get_value()){
						case SmartACE::ParamResponseType::BUSY:
							outstring = "(error (busy))";
							break;
						case SmartACE::ParamResponseType::INVALID:
							outstring = "(error (wrong parameter))";
							break;
						case SmartACE::ParamResponseType::OK:
							outstring = "(ok ())";
							break;
						default:
							std::cout<<"SmartLispServerCore.cc::THIS SHOULD NEVEN HAPPEN!"<<std::endl;
							break;
					}
					break;
				case Smart::SMART_CANCELLED:
					outstring = "(error (smart cancelled))";
					break;
				case Smart::SMART_UNKNOWNCOMPONENT:
					outstring = "(error (smart unknown component))";
					break;
				case Smart::SMART_UNKNOWNPORT:
					outstring = "(error (smart unknown port))";
					break;
				case Smart::SMART_SERVICEUNAVAILABLE:
					outstring = "(error (smart service unavailable))";
					break;
				case Smart::SMART_INCOMPATIBLESERVICE:
					outstring = "(error (smart incompatible service))";
					break;
				case Smart::SMART_ERROR:
					outstring = "(error (smart error))";
					break;
				default:
					outstring = "(error (unknown error))";
					break;
			}
//		}
//		else
//		{
//			// error occured
//			sprintf(outString,"(error (wrong parameter))");
//		}

		return outstring;
}


std::string SmartJobDispatcherCore::setState(SmartACE::StateMaster *stateMaster, std::string server, char* state){

		std::string outstring;

		Smart::StatusCode status;
		char *input  = (char *)NULL;
		char *pointer = (char *)NULL;
		char *param1  = (char *)NULL;

		pointer = input = strdup(state);
		do
		{
			param1 = strsep(&input,LISP_SEPARATOR);
		} while ((param1 != NULL) && (strlen(param1)==0));

		std::string str(param1);

		status = stateMaster->setWaitState(str,server);
		switch (status)
		{
			case Smart::SMART_OK:
				outstring = "(ok ())";
				break;
			case Smart::SMART_UNKNOWNSTATE:
				outstring = "(error (smart unknown state))";
				break;
			case Smart::SMART_NOTACTIVATED:
				outstring = "(error (smart state not activated))";
				break;
			case Smart::SMART_CANCELLED:
				outstring = "(error (smart cancelled))";
				break;
			case Smart::SMART_ERROR_COMMUNICATION:
				outstring = "(error (smart communication error))";
				break;
			case Smart::SMART_ERROR:
				outstring = "(error (smart error))";
				break;
			case Smart::SMART_SERVICEUNAVAILABLE:
				outstring = "(error (smart service unavailable))";
				break;
			default:
				std::cout<<"error : "<<Smart::StatusCodeConversion(status)<<std::endl;
				outstring = "(error (unknown error))";
				break;
		}

		return outstring;
}

std::string SmartJobDispatcherCore::waitForLifeCycleState(SmartACE::StateMaster *stateMaster, std::string server, char* lifeCycleState){

	Smart::StatusCode status;
	std::string outstring;

	std::string str(lifeCycleState);
	str.erase(std::remove(str.begin(), str.end(), '"'), str.end());

	std::cout<<"Check if component: "<<server<<" is in state: "<<str<<std::endl;
	bool done = false;

	do{
		std::string mainState;
		status = stateMaster->getCurrentMainState(mainState, server);
		switch (status)
		{
		case Smart::SMART_OK:
			if(mainState.compare(str) == 0){
				done = true;
				outstring = "(ok ())";
				std::cout<<"[waitForLifeCycleState] Component "<< server <<" is in state to wait for: "<<str<<std::endl;
				return outstring;
			} else {
				std::cout<<"[waitForLifeCycleState] Component "<< server <<"  is in state: "<<mainState<<std::endl;
			}
			break;
		case Smart::SMART_NOTACTIVATED:
			outstring = "(error (smart state not activated))";
			break;
		case Smart::SMART_CANCELLED:
			outstring = "(error (smart cancelled))";
			break;
		case Smart::SMART_ERROR_COMMUNICATION:
			outstring = "(error (smart communication error))";
			break;
		case Smart::SMART_ERROR:
			outstring = "(error (smart error))";
			done = true;
			break;
		case Smart::SMART_SERVICEUNAVAILABLE:
			outstring = "(error (smart service unavailable))";
			break;
		default:
			std::cout<<"[waitForLifeCycleState]  error : "<<Smart::StatusCodeConversion(status)<<std::endl;
			outstring = "(error (unknown error))";
			done = true;
			break;
		}

		std::cout<<"[waitForLifeCycleState] Status: "<<Smart::StatusCodeConversion(status)<<std::endl;
		ACE_OS::sleep(ACE_Time_Value(0,500000));


	}while(done == false);

	return outstring;
}

