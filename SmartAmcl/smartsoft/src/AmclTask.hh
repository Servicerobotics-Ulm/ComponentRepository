//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        lutz@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//  This work is based on previous work by the folks from PlayerStage.
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the amcl algorithm was taken from the
// Playerstage Project, which is distributed under GPL, and you can find at
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------
#ifndef _AMCLTASK_HH
#define _AMCLTASK_HH

#include "AmclTaskCore.hh"
#include "AmclTypes.hh"
#include <libgen.h>
#include "CommLocalizationObjects/CommAmclVisualizationInfo.hh"

class AmclTask  : public AmclTaskCore
{

private:

	// sensor objects
//	AMCLOdom* odom_;
//	AMCLLaser* laser_;
	bool laser_update_;
	bool push_vis_data;

	pf_vector_t pf_odom_pose_;

	int resample_interval_;
	int resample_count_;
	CommLocalizationObjects::CommAmclVisualizationInfo particle_visual_info;

public:
	AmclTask(SmartACE::SmartComponent *comp);
	virtual ~AmclTask();

	virtual int on_entry();
	virtual int on_execute();
	virtual int on_exit();

	int init(const std::string& filename);

private:


//    VisualizationHelper h;


	map_t* loadMapFromFile(const std::string& fname, double res, bool negate, double occ_th, double free_th,
			double* origin);

	static double normalize(double z) {
		return atan2(sin(z), cos(z));
	}

	static double angle_diff(double a, double b) {

		double d1, d2;
		a = normalize(a);
		b = normalize(b);
		d1 = a - b;
		d2 = 2* M_PI - fabs(d1);

		if (d1 > 0) {
			d2 *= -1.0;
		}

		if (fabs(d1) < fabs(d2)) {
			return (d1);
		} else {
			return (d2);
		}
	}

	static double pi_to_pi(double angle) {
		angle += M_PI;
		double ret_angle = fmod(angle, 2* M_PI );

		if (angle < 0)
			ret_angle += 2* M_PI ;

		ret_angle -= M_PI;

		return ret_angle;
	}

	void add_particles_to_visuallization_info(CommLocalizationObjects::CommAmclVisualizationInfo& info, const pf_sample_set_t* set);
	void add_hypothesis_to_visuallization_info(CommLocalizationObjects::CommAmclVisualizationInfo& info, const std::vector<amcl_hyp_t>& hyps);

};

#endif
