//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2014 Matthias Lutz
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "LoadTask.hh"
#include "ComponentRobotinoConveyerBeltServer_OPCUA.hh"

#include <iostream>

LoadTask::LoadTask(SmartACE::SmartComponent *comp) 
:	LoadTaskCore(comp)
{
	std::cout << "constructor LoadTask\n";
	abortFlag = false;
	box_present_bit = 0;
	load_signal_bit = 0;
}
LoadTask::~LoadTask() 
{
	std::cout << "destructor LoadTask\n";
}



int LoadTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	box_present_bit = COMP->getGlobalState().getRobot().getBox_present_din();
	if(COMP->getGlobalState().getRobot().getSignal_unloading_dout()>=0){
		load_signal_bit = COMP->getGlobalState().getRobot().getSignal_loading_dout();
	}
	return 0;
}

void LoadTask::resetAbortFlag()
{
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	abortFlag = false;
}

bool LoadTask::getAbortFlag ()
{
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	return abortFlag;
}

void LoadTask::setAbortFlag ()
{
	SmartACE::SmartRecursiveGuard g(this->abortLock);
	abortFlag = true;
}

int LoadTask::on_execute() {
    // this method is called from an outside loop,
    // hence, NEVER use an infinite loop (like "while(1)") here inside!!!
    // also do not use blocking calls which do not result from smartsoft kernel

    Smart::StatusCode status;
    OPCUA::StatusCode opcuaStatus;
    CommRobotinoObjects::RobotinoConveyerBeltEventState eventState;
    bool isPixtend;
    std::string callResult;

    status = COMP->stateSlave->acquire("load");
    COMP->stateSlave->release("load");
    std::cout << "[LoadTask]: start..." << std::endl;
    if (status != Smart::SMART_OK) {
        std::cout << " [LoadTask] acquire state: " << Smart::StatusCodeConversion(status) << std::endl;
    } else {
        COMP->triggerLoad.acquire();

        ParameterStateStruct localState = COMP->getGlobalState();
        float loadDirection = localState.getRobot().getLoad_motor_direction();
        std::cout << "load direction:" << loadDirection << std::endl;
        bool signalLoading = (localState.getRobot().getSignal_loading_dout() >= 0);
        int station_id = localState.getCommRobotinoObjects().getRobotinoConveyerParameter().getSetStationID().getId();
        std::string station_addr;

        std::list<std::string> isPixtendList = localState.getOPCUAstatic().getIs_pixtend();
        if (station_id >= 0 && station_id < isPixtendList.size()) {
            std::list<std::string>::iterator it = isPixtendList.begin();
            std::advance(it, station_id);
            isPixtend = *it == "1";
        } else
            isPixtend = true;

        std::list<std::string> stationsList = localState.getOPCUAstatic().getServer_address();
        std::vector<std::string> stationsVector { std::begin(stationsList), std::end(stationsList) };

        if (station_id >= 0 && station_id < stationsVector.size()) {
            station_addr = stationsVector.at(station_id);

            //this is a hack to use one station with different communication types
            //in this case it is used for unloading only!!!
            if (station_addr[0] == '!') {
                std::cout << "Overwrite passiveStation!" << std::endl;
                //remove the char in this case
                station_addr.erase(0, 1);
            }
            std::cout << "[LoadTask] station id: " << station_id << " station_addr: " << station_addr << " is_pixtend:" << isPixtend << std::endl;
        } else {
            std::cout << "ERROR invalid station id: " << station_id << " - stationsVector size: " << stationsVector.size() << std::endl;
            station_addr = "opc.tcp://0.0.0.0:4840";
        }

        if (queryDigitalInput(box_present_bit) == true) {
            eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_BOX_ADREADY_PRSESENT);
            COMP->robotinoConveyerBeltEventOut->put(eventState);
            std::cout << "[LoadTask] ERROR: loading triggered - box already on the belt!" << std::endl;
            COMP->commPowerOutputSendOut->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0));
        } else {
            //1. Connect to Station
            bool communicationError = false;
            if (localState.getRobot().getIgnore_station_communication()) {
                std::cout << "[LoadTask] ERROR: ignore_station_communication is true" << std::endl;
                communicationError = true;
            } else {
                if (isPixtend) {
                    opcuaStatus = stationPixtend.connect(station_addr, localState.getOPCUAstatic().getObject_name());
                } else {
                    opcuaStatus = stationCpx.connect(station_addr, localState.getOPCUAstatic().getRootObjectPath(), 1);
                }
                if (opcuaStatus != OPCUA::StatusCode::ALL_OK)
                    communicationError = true;
                std::cout << "connect: " << opcuaStatus << std::endl;
            }
            if (!communicationError) {
                //this sleep might help the OPC server to sort things
                ACE_OS::sleep(ACE_Time_Value(1, 0));
                //2. Check if Station is ready?
                std::cout << "[LoadTask] loading" << std::endl;

                //3. Command Station to send the Box
                if (isPixtend) {
                    stationPixtend.setLED_YELLOW(true);
                    stationPixtend.setLED_GREEN(true);
                    opcuaStatus = stationPixtend.callStart_unloading(10, callResult);
                    std::cout << "[LoadTask] stationPixtend.callStart_unloading - status: " << opcuaStatus << " callresult:  " << callResult << std::endl;
                    if (opcuaStatus != OPCUA::StatusCode::ALL_OK || callResult != "UNLOADING_STARTED") {
                        stationPixtend.callStop_unloading(1, callResult);
                        communicationError = true;
                    }
                } else {
                    stationCpx.setLED_YELLOW(true);
                    stationCpx.setLED_GREEN(true);
                    stationCpx.setMotor_timeout(10);
                    stationCpx.setStart_unloading(true);
                    bool unloadingstatus = stationCpx.getStart_unloading();
                    std::cout << "unloadingstatus: " << unloadingstatus << std::endl;
                }
            }
            if (!communicationError) {
                if (signalLoading == true) {
                    queryDigitalOutput(load_signal_bit, true);
                }
                for (int counter = 0; counter < localState.getRobot().getBelt_time_out_sec() * 10; counter++) {
                    //sleep till the box is loaded
                    COMP->commPowerOutputSendOut->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(-50.0 * loadDirection));
                    ACE_OS::sleep(ACE_Time_Value(0, 100000));
                    bool boxPresent = queryDigitalInput(box_present_bit);
                    ACE_OS::sleep(ACE_Time_Value(0, 1000));
                    bool boxPresent2 = queryDigitalInput(box_present_bit);
                    ACE_OS::sleep(ACE_Time_Value(0, 1000));
                    bool boxPresent3 = queryDigitalInput(box_present_bit);
                    std::cout << boxPresent << " " << boxPresent2 << " " << boxPresent3 << std::endl;
                    if (boxPresent && boxPresent2 && boxPresent3) {
                        std::cout << "[LoadTask] Box found" << std::endl;
                        // one more second to move the box
                        ACE_OS::sleep(ACE_Time_Value(0, 1000000));
                        std::cout << "[LoadTask] Box found --> break" << std::endl;
                        break;
                    }
                    if (getAbortFlag() == true) {
                        std::cout << "[LoadTask] Abort Loop!" << std::endl;
                        break;
                    }
                }
                COMP->commPowerOutputSendOut->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));
                if (signalLoading == true) {
                    queryDigitalOutput(load_signal_bit, false);
                }

                //4. Send Station box received
                if (isPixtend) {
                    stationPixtend.setLED_YELLOW(false);
                    opcuaStatus = stationPixtend.callStop_unloading(1, callResult);
                } else {
                    stationCpx.setLED_YELLOW(false);
                    opcuaStatus = stationCpx.setStop_unloading(true);
                    callResult = (std::string) stationCpx.getMethod_result();
                }
                std::cout << "[LoadTask] Stop_unloading - status: " << opcuaStatus << " callresult:  " << callResult << std::endl;

                if (queryDigitalInput(box_present_bit) == true) {
                    eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_DONE);
                    COMP->robotinoConveyerBeltEventOut->put(eventState);
                    std::cout << "[LoadTask] Load EVENT CONVEYER_BELT_LOAD_DONE FIRED!" << std::endl;
                } else {
                    eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_BOX_LOADED);
                    COMP->robotinoConveyerBeltEventOut->put(eventState);
                    std::cout << "[LoadTask] ERROR BOX LOADED FAILED!" << std::endl;
                }
            }
            COMP->commPowerOutputSendOut->send(CommRobotinoObjects::CommRobotinoPowerOutputValue(0.0));
            if (communicationError) {
                eventState.set(CommRobotinoObjects::RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_RESPONSE_FROM_STATION);
                COMP->robotinoConveyerBeltEventOut->put(eventState);
                std::cout << "[LoadTask] ERROR: Can't connect to station or no box on station." << std::endl;
            }
            //5. Disconnect from Station
            if (isPixtend)
                stationPixtend.disconnect();
            else
                stationCpx.disconnect();
        }
    }
    std::cout << "[LoadTask]: ...stop" << std::endl;
    // it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
    return 0;
}

int LoadTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

bool LoadTask::queryDigitalInput(const unsigned int & bit){

	CommBasicObjects::CommIOValues inputQuery;
	CommBasicObjects::CommIOValues inputQueryResult;


	Smart::StatusCode status;
	status = COMP->commIOValuesQueryServiceReq->query(inputQuery,inputQueryResult);
	if(status != Smart::SMART_OK){
		std::cout<<__FUNCTION__<<"[LoadTask] ERROR: query digital IO"<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
		return false;
	}
	if(bit>inputQueryResult.getDigitalInputValuesSize()){
		std::cout<<__FUNCTION__<<"[LoadTask] ERROR: query bit: "<<bit<<" digital IO size: "<<inputQueryResult.getDigitalInputValuesSize()<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
		return false;
	}
	return inputQueryResult.getDigitalInputValuesElemAtPos(bit);

}

void LoadTask::queryDigitalOutput(const unsigned int & bit, const bool & value){

	CommBasicObjects::CommIOValues outputQuery;
	CommBasicObjects::CommIOValues dummy;
	outputQuery.resizeDigitalOutputValues(1);

	Smart::StatusCode status;
	CommBasicObjects::CommDigitalOutputRequest digitalOutputRequest(bit,value);

	outputQuery.setDigitalOutputValuesElemAtPos(0,digitalOutputRequest);

	status = COMP->commIOValuesQueryServiceReq->query(outputQuery,dummy);
	if(status != Smart::SMART_OK){
		std::cout<<__FUNCTION__<<"[LoadTask] ERROR: query digital IO"<<std::endl;
		COMP->stateSlave->setWaitState("FatalError");
	}

}

