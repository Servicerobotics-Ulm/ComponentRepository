//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include <ForwardActivity.hh>
#include "ComponentRosDock.hh"

#include <iostream>

ForwardActivity::ForwardActivity(SmartACE::SmartComponent *comp)
:	ForwardActivityCore(comp)
{
	std::cout << "constructor ForwardActivity\n";
}
ForwardActivity::~ForwardActivity()
{
	std::cout << "destructor ForwardActivity\n";
}

void ForwardActivity::on_BaseStateServiceIn(const CommBasicObjects::CommBaseState &input)
{
	// upcall triggered from InputPort BaseStateServiceIn
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort BaseStateServiceIn
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method baseStateServiceInGetUpdate(input) to get a copy of the input object
	// std::cout << "received base state: " << input << std::endl;

	std_msgs::Bool charging;
	charging.data = (input.get_battery_state().getCurrent() > 0) && (bool)input.get_battery_state().getExternalPower();
	COMP -> rosPorts -> charging_pub.publish(charging);

}

void ForwardActivity::on_LaserServiceIn(const CommBasicObjects::CommMobileLaserScan &input)
{
	// upcall triggered from InputPort LaserServiceIn
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort LaserServiceIn
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method laserServiceInGetUpdate(input) to get a copy of the input object

	//std::cout << "received laserscan: " << input << std::endl;
	unsigned int scan_size = input.get_scan_size();
	unsigned int length_unit = input.get_scan_length_unit();

	sensor_msgs::LaserScan laserscan;

	laserscan.header.frame_id = "base_link";
	laserscan.header.stamp.sec = input.get_scan_time_stamp().get_seconds();
	laserscan.header.stamp.nsec = input.get_scan_time_stamp().get_microseconds()*1000;
	// angles are supposed to be in rad (-3.14 .. 3.14)
	laserscan.angle_min = input.get_scan_start_angle();
	laserscan.angle_max = input.get_scan_start_angle() + input.get_scan_resolution() * scan_size;
	laserscan.angle_increment = input.get_scan_resolution();
	laserscan.range_min = input.get_min_distance() / length_unit;
	laserscan.range_max = input.get_max_distance() / length_unit;

	std::vector<float> ranges;
	std::vector<float> intensities;
	for (unsigned int i = 0; i < scan_size; i++) {
		ranges.push_back(input.get_scan_distance(i, 1) / length_unit);
		intensities.push_back(input.get_scan_intensity(i));
	}
	laserscan.ranges = ranges;
	laserscan.intensities = intensities;

	//std::cout << "publishing laserscan: " << laserscan << std::endl;
	COMP -> rosPorts -> laser_pub.publish(laserscan);
}

void ForwardActivity::twist_sub_cb(const geometry_msgs::Twist::ConstPtr &msg)
{
    CommBasicObjects::CommNavigationVelocity comNavVel;

    comNavVel.set_vX(msg->linear.x);
    comNavVel.set_vY(msg->linear.y);
	comNavVel.set_omega(msg->angular.z);
//	std::cout << "Velocity x: " << msg->linear.x	<< std::endl;
//	std::cout << "velocity y: " << msg->linear.y	<< std::endl;
//	std::cout << "turnrate :" << msg->angular.z	<< std::endl;

    Smart::StatusCode status_nav = this->navigationVelocityServiceOutPut(comNavVel);
    if(status_nav != Smart::SMART_OK)
	{
		std::cerr << status_nav << std::endl;
		std::cout << "Some Error in the Conection as status is not ok " << std::endl;
	}
	else
	{
		//std::cout << "Updating Velocity " << comNavVel << std::endl;
	}
}

int ForwardActivity::on_entry()
{
	std::cout << "entry ForwardActivity " << std::endl;

	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int ForwardActivity::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;

	//std::cout << "Hello from ForwardActivity " << std::endl;

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int ForwardActivity::on_exit()
{
	std::cout << "exit ForwardActivity " << std::endl;

	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
