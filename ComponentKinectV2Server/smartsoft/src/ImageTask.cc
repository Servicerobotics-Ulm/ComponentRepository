//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2011, 2017 Matthias Lutz, Dennis Stampfer, Matthias Rollenhagen
//
//      lutz@hs-ulm.de
//      stampfer@hs-ulm.de
//      rollenhagen@hs-ulm.de
//
//      ZAFH Servicerobotic Ulm
//      Christian Schlegel
//      University of Applied Sciences
//      Prittwitzstr. 10
//      89075 Ulm
//      Germany
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "ImageTask.hh"
#include "ComponentKinectV2Server.hh"

#include "EulerTransformationMatrices.hh"
#include <iostream>
#include <armadillo.hh>
#include "KinectWrapper.hh"

#include <iostream>

ImageTask::ImageTask(SmartACE::SmartComponent *comp) 
:	ImageTaskCore(comp)
{
	std::cout << "constructor ImageTask\n";
	_ring_buffer_index = 0;
}
ImageTask::~ImageTask() 
{
	std::cout << "destructor ImageTask\n";
	COMP->imageTask->close();
	for (unsigned int i = 0; i < _ring_buffer.size() - 2; i++) {
		delete _ring_buffer[i];
	}
	_ring_buffer.clear();
}

void ImageTask::startCapturing() {
	SmartACE::SmartGuard guard(COMP->kinectMutex);
	if (COMP->device != NULL) {
		COMP->device->startVideo();
	}
	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Start capturing\n";
	}
}
void ImageTask::stopCapturing() {
	SmartACE::SmartGuard guard(COMP->kinectMutex);
	if (COMP->device != NULL) {
		COMP->device->stopVideo();
	}
	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Stop capturing" <<std::endl;
	}
}

int ImageTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	// Calculate size of the ring_buffer
	int size = (int) (COMP->getGlobalState().getSettings().getValid_image_time() + 4);

	_ring_buffer.resize(size);

	if (COMP->getGlobalState().getSettings().getDebug_info()) {
		std::cout << "[Image Task] Newest: Size of Ring Buffer " << size << std::endl;
	}

	// Fill ring_buffer with empty images
	for (unsigned int i = 0; i < _ring_buffer.size(); i++) {
		_ring_buffer[i] = new DomainVision::CommRGBDImage;
	}

	//Handle user specified resolution
	if(COMP->getGlobalState().getSettings().getHigh_resolution())
	{
		COMP->device->set_resolution(KinectWrapper::Resolution::RES_1920_X_1080);
	}else{
		COMP->device->set_resolution(KinectWrapper::Resolution::RES_512_X_424);
	}

	return 0;
}
int ImageTask::on_execute()
{
	// this method is called from an outside loop,
		// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
		// also do not use blocking calls which do not result from smartsoft kernel

		CommBasicObjects::CommBasePose default_base_position;
		default_base_position.set_x(COMP->getGlobalState().getBase().getX());
		default_base_position.set_y(COMP->getGlobalState().getBase().getY());
		default_base_position.set_z(COMP->getGlobalState().getBase().getZ());

		default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());

		CommBasicObjects::CommBaseVelocity zero_velocity;
		zero_velocity.set_vX(0);
		zero_velocity.set_vY(0);
		zero_velocity.set_vZ(0);

		zero_velocity.set_WX_base(0);
		zero_velocity.set_WY_base(0);
		zero_velocity.set_WZ_base(0);

		DomainVision::CommRGBDImage* image = NULL;

		try{
			Smart::StatusCode statusCode;
			statusCode = COMP->stateSlave->acquire("pushimage");
			std::cout<< Smart::StatusCodeConversion(statusCode) << std::endl;
			if(statusCode == Smart::SMART_OK)
			{
				image = _ring_buffer[_ring_buffer_index];

				// get newest image from Kinect
				SmartACE::SmartGuard guard(COMP->kinectMutex);
				COMP->device->getImage(*image);
				guard.release();

				arma::mat sensorMat;
				EulerTransformationMatrices::create_zyx_matrix(COMP->getGlobalState().getSensor_pose().getX(), COMP->getGlobalState().getSensor_pose().getY(),
						COMP->getGlobalState().getSensor_pose().getZ(), COMP->getGlobalState().getSensor_pose().getAzimuth(), COMP->getGlobalState().getSensor_pose().getElevation(),
						COMP->getGlobalState().getSensor_pose().getRoll(), sensorMat);

				// set base state
				CommBasicObjects::CommBaseState base_state;

				//////////////
				if (COMP->getGlobalState().getBase().getOn_ptu()) {
					CommBasicObjects::CommDevicePoseState devicePoseState;
					Smart::StatusCode status = COMP->ptuPosePushNewestClient->getUpdate(devicePoseState);

					base_state = devicePoseState.get_base_state();
					CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
					arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

					sensorMat = ptuMat * sensorMat;

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current ptu device state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
						image->setIs_valid(false);
					}
				}
				//////////////

				// read base state from base server
				if (COMP->getGlobalState().getBase().getOn_base()) {
					Smart::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

					if (status != Smart::SMART_OK) {
						std::cerr << "[Image Task] WARNING: failed to get current base state ("
						<< Smart::StatusCodeConversion(status) << "), pushing invalid image" << std::endl;
						image->setIs_valid(false);
					}
				}
				// default base state
				else {
					base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
					base_state.set_base_position(default_base_position);
					base_state.set_base_velocity(zero_velocity);
				}

				CommBasicObjects::CommPose3d sensorPose(sensorMat);
				image->setSensor_pose(sensorPose);
				image->setBase_state(base_state);

				// Save the newest image into the global pointer
				COMP->NewestImageMutex.acquire();
				COMP->newestImage = image;
				COMP->NewestImageMutex.release();


				if(COMP->device->resolution == COMP->device->Resolution::RES_512_X_424)
				{
				DomainVision::CommVideoImage colorImage;
				colorImage.set_parameters(512, 424, DomainVision::FormatType::RGB24);
				colorImage.set_data(get_low_res_rgb_image().data);
				colorImage.setIs_valid(true);
				colorImage.setSeq_count(image->getSeq_count());

				COMP->colorImagePushNewestServer->put(colorImage);

				}else
				{
				DomainVision::CommVideoImage colorImage(image->getColor_image().get_width(),image->getColor_image().get_height(), DomainVision::FormatType::RGB24);
				colorImage.set_data(image->getColor_image().get_data());
				colorImage.set_sequence_counter(image->getSeq_count());
				COMP->colorImagePushNewestServer->put(colorImage);
				}

				DomainVision::CommDepthImage depthImage = image->getDepth_image();
				COMP->depthImagePushServiceOut->put(depthImage);


				COMP->imagePushNewestServer->put(*image);

				if (COMP->getGlobalState().getSettings().getDebug_info()) {
					std::cout << "[Image Task] Newest: Image sent!\n";
					std::cout << "[Image Task] Newest Color: Image sent!\n";
					std::cout << "[Image Task] Image is " << ((image->getIs_valid()) ? "valid" : "invalid") << "\n";
				}

				// calculate new index in the ring_buffer
				_ring_buffer_index++;
				if (_ring_buffer_index == _ring_buffer.size()){
					_ring_buffer_index = 0;
				}

				guard.release();
				COMP->stateSlave->release("pushimage");

			}


		} catch (std::exception e) {
			std::cerr << "[Image Task] Error in ImageTask::svc() " << e.what() << "\n";
		} catch (...) {
			std::cerr << "[Image Task] Unknown error in ImageTask::svc()\n";
		}

		std::chrono::time_point<std::chrono::high_resolution_clock, std::chrono::nanoseconds> current_time = std::chrono::high_resolution_clock::now();
		std::chrono::milliseconds diff_ms =  std::chrono::duration_cast<std::chrono::milliseconds>(current_time - previous_time);
		previous_time = current_time;
		std::cout <<"-------------------------- Frequency = " << " : Hz =" << 1000.0f/diff_ms.count() <<std::endl;

		// TODO: Check
		//smart_task_wait_period();

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int ImageTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

cv::Mat ImageTask::get_low_res_rgb_image()
{
	return low_res_rgb_image;
}
void ImageTask::set_low_res_rgb_image(const cv::Mat& in_image)
{
	low_res_rgb_image = in_image;
}
