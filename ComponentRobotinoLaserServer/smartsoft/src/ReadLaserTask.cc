//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2013 Timo Hegele, Matthias Lutz
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "ReadLaserTask.hh"
#include "ComponentRobotinoLaserServer.hh"
#include <cmath>

#include <EulerTransformationMatrices.hh>

#include <iostream>

void MyLaserRangeFinder::scanEvent( const LaserRangeFinderReadings& scan )
	{
		CommBasicObjects::CommMobileLaserScan lScanComm;
		CommBasicObjects::CommBaseState base_state;
		CommBasicObjects::CommLaserSafetyEventState laserSafetyEvent;

		lScanComm.set_scan_valid(true);

		Smart::StatusCode status = COMP->baseTimedClient->getUpdate(base_state);
		if (status != Smart::SMART_OK) {
			std::cerr << "[LaserTask] WARNING: failed to get current base state ("
					<< Smart::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
			lScanComm.set_scan_valid(false);
		}

		CommBasicObjects::CommBaseVelocity zero_velocity;
		zero_velocity.set_vX(0);
		zero_velocity.set_vY(0);
		zero_velocity.set_vZ(0);
		zero_velocity.setWX(0);
		zero_velocity.setWY(0);
		zero_velocity.setWZ(0);

		float minRange = 0.001f* COMP->getGlobalState().getRobotinoLaser_ini().getMin_range(); //scan.range_min + 0.01;
		float maxRange = scan.range_max - 0.01;//0.001f * COMP->getGlobalState().getRobotinoLaser_ini().getMax_range();


		unsigned int rangesSize = 0;
		const float* ranges;
		scan.ranges( &ranges, &rangesSize );

		unsigned int intensitiesSize = 0;
		const float* intensities;
		scan.intensities( &intensities, &intensitiesSize );

		//std::cout << "Scan event with " << rangesSize << " ranges and " << intensitiesSize << " intensities" << std::endl;

		uint32_t opening_angle = COMP->getGlobalState().getRobotinoLaser_ini().getOpening_angle();

		// set scan header
		lScanComm.set_scan_time_stamp(CommBasicObjects::CommTimeStamp::now());
		lScanComm.set_scan_update_count(scan_id);

		double ranger_opening_angle = scan.angle_max - scan.angle_min;
		ranger_opening_angle *= 180/ M_PI;
		//////////////////////////
		// set scan parameters
		//////////////////////////

		double scan_resolution = scan.angle_increment * 180/M_PI;

		lScanComm.set_scan_length_unit(1);
		lScanComm.set_scan_double_field_of_view(-0.5 * opening_angle, scan_resolution);
		lScanComm.set_min_distance(scan.range_min,1);
		lScanComm.set_max_distance(scan.range_max,1);

		//////////////////////////
		// set scan points
		//////////////////////////
		const int desiredScans = 1 + opening_angle / scan_resolution;
		const int rangerScans = 1 + ranger_opening_angle / scan_resolution;


        lScanComm.set_max_scan_size(desiredScans);

        const int firstScanIndex = (rangerScans - desiredScans) * 0.5;
		int lastScanIndex = rangerScans - firstScanIndex;

		if (lastScanIndex > rangesSize)
			lastScanIndex = rangesSize;

		if (COMP->getGlobalState().getRobotinoLaser_ini().getVerbose()) {
			std::cout << "Read scans: " << rangesSize << "\n";
			std::cout<<" Max possible size: "<<desiredScans<<std::endl;
		}


		if( rangesSize == 0)
		{
			lScanComm.set_scan_valid(false);
		}
		else
		{
			std::vector<float> validIndexes(rangesSize);

		  unsigned int num_valid_points = 0;
		  for (int i = firstScanIndex; i < lastScanIndex; ++i) {
				const float dist = ranges[i];
				if (dist >= minRange && dist <= maxRange)
				{
					validIndexes[num_valid_points] = i;
					++num_valid_points;
				}
		  }

		  lScanComm.set_scan_size(num_valid_points);
		  bool protective = false;
		  bool warning = false;

		  for (int i = 0; i<num_valid_points; ++i)
		  {
			const int rangesIndex = validIndexes[i];
			const float dist = ranges[rangesIndex];
			lScanComm.set_scan_index(i, rangesIndex - firstScanIndex);
			lScanComm.set_scan_distance(i, dist,1);
			double intensity = 0;
			if(i<intensitiesSize)
			{
				intensity = intensities[rangesIndex];
			}
			lScanComm.set_scan_intensity(i, intensity);
			//std::cout<<"Dist: "<<dist;
			if(dist<COMP->getGlobalState().getRobotinoLaser_ini().getLaserWarningSafetyDist()){
				warning = true;
			}
			if(dist<COMP->getGlobalState().getRobotinoLaser_ini().getLaserSafetyDist()){
				protective = true;
			}
		  }

		  if(warning == true){
			  laserSafetyEvent.setWarningState(CommBasicObjects::SafetyFieldState::BLOCKED);
		  } else {
			  laserSafetyEvent.setWarningState(CommBasicObjects::SafetyFieldState::FREE);
		  }
		  if(protective == true){
			  laserSafetyEvent.setProtectiveState(CommBasicObjects::SafetyFieldState::BLOCKED);
		  } else {
			  laserSafetyEvent.setProtectiveState(CommBasicObjects::SafetyFieldState::FREE);
		  }

		}

//		lScanComm.set_scan_size(rangesSize);
//
//		for (unsigned int i = 0; i < rangesSize; ++i) {
//				if(ranges[i]<scan.range_max){
//					lScanComm.set_scan_index(i, i);
//					lScanComm.set_scan_distance(i, ranges[i],1);
//					lScanComm.set_scan_intensity(i, intensities[i]);
//				}
//		}




		lScanComm.set_base_state(base_state);


		//////////////////////////
		// set robot scanner position
		//////////////////////////
		double x = COMP->getGlobalState().getRobotinoLaser_ini().getLaserPosX();
		double y = COMP->getGlobalState().getRobotinoLaser_ini().getLaserPosY();
		double z = COMP->getGlobalState().getRobotinoLaser_ini().getLaserPosZ();
		double azimuth = COMP->getGlobalState().getRobotinoLaser_ini().getYaw();
		double elevation = COMP->getGlobalState().getRobotinoLaser_ini().getPitch();
		double roll = COMP->getGlobalState().getRobotinoLaser_ini().getRoll();
		arma::mat mat_sensor;

		EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_sensor);

		CommBasicObjects::CommPose3d sensor_pose(mat_sensor);
		lScanComm.set_sensor_pose(sensor_pose);

		//////////////////////////
		// set world scanner position
		//////////////////////////
		double base_x = 0;
		double base_y = 0;
		double base_z = 0;
		double base_a = 0;
		arma::mat mat_base(4, 4);

		if (lScanComm.is_scan_valid()) {
			base_x = base_state.get_base_position().get_x();
			base_y = base_state.get_base_position().get_y();
			base_z = base_state.get_base_position().get_z();
			base_a = base_state.get_base_position().get_base_azimuth();
		}

		EulerTransformationMatrices::create_zyx_matrix(base_x, base_y, base_z, base_a, 0, 0, mat_base);
		arma::mat mat_world = mat_base * mat_sensor;
		CommBasicObjects::CommPose3d world_pose(mat_world);

		lScanComm.set_scanner_x(world_pose.get_x());
		lScanComm.set_scanner_y(world_pose.get_y());
		lScanComm.set_scanner_z(world_pose.get_z());

		lScanComm.set_scanner_azimuth(world_pose.get_azimuth());
		lScanComm.set_scanner_elevation(world_pose.get_elevation());
		lScanComm.set_scanner_roll(world_pose.get_roll());


		if (COMP->getGlobalState().getRobotinoLaser_ini().getActivatePushNewest()) {
			Smart::StatusCode push_status = COMP->laserServiceOut->put(lScanComm);
			if (push_status != Smart::SMART_OK) {
				std::cerr << "[LaserTask] WARNING: error on push (" << Smart::StatusCodeConversion(push_status)
						<< ")" << std::endl;
			}
		}

		if (COMP->getGlobalState().getRobotinoLaser_ini().getActivate_safetyEventServer()) {

			//std::cout<<"Protective state: "<<laserSafetyEvent.getProtectiveState()<<" | "<<"Warning state:"<<laserSafetyEvent.getWarningState()<<std::endl;
			Smart::StatusCode status = COMP->safetyfieldEventServer->put(laserSafetyEvent);
			if (status != Smart::SMART_OK) {
				std::cerr << "[LaserTask] WARNING: error on event (" << Smart::StatusCodeConversion(status)
						<< ")" << std::endl;
			}
		}

		// copy local scan to global scan
		SmartACE::SmartGuard guard(COMP->CurrentScanLock);
		COMP->currentLaserScan = lScanComm;
		guard.release();
	}

ReadLaserTask::ReadLaserTask(SmartACE::SmartComponent *comp) 
:	ReadLaserTaskCore(comp)
{
	std::cout << "constructor ReadLaserTask\n";
}
ReadLaserTask::~ReadLaserTask() 
{
	std::cout << "destructor ReadLaserTask\n";
}



int ReadLaserTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	std::cout << "Connecting... to "<<COMP->getGlobalState().getRobotinoLaser_ini().getRobotinoAddress()<<std::endl;
	com.setAddress( COMP->getGlobalState().getRobotinoLaser_ini().getRobotinoAddress().c_str());

	do{
		sleep(1);
		try{
			com.connectToServer( true );
		}catch(rec::robotino::api2::RobotinoException &e){
			std::cout<<e.what()<<std::endl;
		}
	}while (false == com.isConnected());

	if( false == com.isConnected() )
	{
		std::cout << std::endl << "Could not connect to " << com.address() << std::endl;
		rec::robotino::api2::shutdown();
		return -1;
	}
	else
	{
		std::cout << "success" << std::endl;
		return 0;
	}
	return 0;
}
int ReadLaserTask::on_execute()
{
	// this method is called from an outside loop,
		// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
		// also do not use blocking calls which do not result from smartsoft kernel

		com.processEvents();
		rec::robotino::api2::msleep( 20 ); //50Herz

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int ReadLaserTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
