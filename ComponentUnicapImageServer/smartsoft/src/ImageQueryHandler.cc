//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//
//  Copyright (C) 2010 Jonas Brich
//
//        brich@mail.hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "Unicap Video Server component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "ImageQueryHandler.hh"
#include "ComponentUnicapImageServer.hh"
#include "Unicap.hh"
#include "ParameterStateStruct.hh"

#include "EulerTransformationMatrices.hh"
ImageQueryHandler::ImageQueryHandler(Smart::IQueryServerPattern<CommBasicObjects::CommVoid, DomainVision::CommVideoImage>* server)
:	ImageQueryHandlerCore(server)
{
	
}

ImageQueryHandler::~ImageQueryHandler()
{
	
}

void ImageQueryHandler::handleQuery(const Smart::QueryIdPtr &id, const CommBasicObjects::CommVoid& request)

{
	Smart::StatusCode status;
		DomainVision::CommVideoImage image;
		image.set_data_invalid();
		DomainVision::FormatType format;

		ParameterStateStruct localState = COMP->getGlobalState();

		if (localState.getSettings().getDebug_info()) {
			std::cout<<"Query Request received.."<<std::endl;
		}

		// Component Active then get new image
		status = COMP->stateSlave->tryAcquire("nonneutral");
		if(status == Smart::SMART_OK)
		{
				DomainVision::CommVideoImage::string2format(localState.getImage().getSmart_format(),format);
				image.set_parameters(localState.getHardware_properties().getWidth(),localState.getHardware_properties().getHeight(),format);

			// If Newest and Timed active get image from global Reference otherwise get it directly from Unicap
			if (COMP->stateSlave->tryAcquire("PushImage")==Smart::SMART_OK)
			{
				if (localState.getSettings().getDebug_info()) {
								std::cout << "Push image mode"<<std::endl;
				}

				COMP->NewestImageMutex.acquire();
					DomainVision::CommVideoImage* newestImage = COMP->newestImage;
					if (newestImage != NULL) {
						image.set_data(newestImage->get_data());
						image.set_sequence_counter((unsigned long int) newestImage->get_sequence_counter());
						image.set_sensor_pose(newestImage->get_sensor_pose());
						image.set_base_state(newestImage->get_base_state());
					}
				COMP->NewestImageMutex.release();

				COMP->stateSlave->release("pushimage");
			}
			else
			{

				if (localState.getSettings().getDebug_info()) {
						std::cout << "Query only mode"<<std::endl;
				}

				CommBasicObjects::CommBasePose default_base_position;
				default_base_position.set_x(localState.getBase().getX());
				default_base_position.set_y(localState.getBase().getY());
				default_base_position.set_z(localState.getBase().getZ());
				default_base_position.set_base_azimuth(localState.getBase().getAzimuth());
				default_base_position.set_base_elevation(localState.getBase().getElevation());
				default_base_position.set_base_roll(localState.getBase().getRoll());

				CommBasicObjects::CommBaseVelocity zero_velocity;
				zero_velocity.set_vX(0);
				zero_velocity.set_vY(0);
				zero_velocity.set_vZ(0);
				zero_velocity.set_WZ_base(0);
				zero_velocity.set_WY_base(0);
				zero_velocity.set_WX_base(0);


				try {
					UNICAPINZ->getImage(image,localState);
				} catch (Unicap::UnicapException& e) {
					std::cerr << "Error: " << e.what() << " [QueryHandler].\n";
					image.set_data_invalid();
				} catch (...) {
					std::cerr << "Error: Undefined Error. [QueryHandler]\n";
					image.set_data_invalid();
				}

				arma::mat sensorMat;
				EulerTransformationMatrices::create_zyx_matrix(localState.getSensor_pose().getX(), localState.getSensor_pose().getY(),
						localState.getSensor_pose().getZ(), localState.getSensor_pose().getAzimuth(), localState.getSensor_pose().getElevation(),
						localState.getSensor_pose().getRoll(), sensorMat);


				// set base state
				CommBasicObjects::CommBaseState base_state;
				if (localState.getBase().getOn_ptu()) {
					CommBasicObjects::CommDevicePoseState devicePoseState;
					Smart::StatusCode status = COMP->ptuPushTimedClient->getUpdate(devicePoseState);

					base_state = devicePoseState.get_base_state();
					CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
					arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

					sensorMat = ptuMat * sensorMat;

					if (status != Smart::SMART_OK) {
						std::cerr << "WARNING: failed to get current ptu device state (" << Smart::StatusCodeConversion(status)
						<< "), pushing invalid image" << std::endl;
						image.set_data_invalid();
					}

				}
				// read base state from base server
				else if (localState.getBase().getOn_base()) {
					Smart::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

					if (status != Smart::SMART_OK) {
						std::cerr << "WARNING: failed to get current base state (" << Smart::StatusCodeConversion(status)
						<< "), pushing invalid image" << std::endl;
						image.set_data_invalid();
					}
				}
				// default base state
				else {
					base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
					base_state.set_base_position(default_base_position);
					base_state.set_base_velocity(zero_velocity);
				}

				CommBasicObjects::CommPose3d sensorPose(sensorMat);
				image.set_sensor_pose(sensorPose);
				image.set_base_state(base_state);


			}

			COMP->stateSlave->release("nonneutral");
		}
		else
		{
			image.set_data_invalid();
			if (localState.getSettings().getDebug_info()) {
				    std::cout << "Query: StatusCode: "<<Smart::StatusCodeConversion(status)<<std::endl;
					std::cout << "Query: Set Data invalid!"<< std::endl;

			}

		}

		this->server->answer(id, image);
		if (localState.getSettings().getDebug_info()) {
			std::cout << "Query: Answer sent: "<<image.is_data_valid()<<" with ID: " << id << std::endl;
			std::cout << "Query: Answer size: "<<image.get_height()<<":" << image.get_width() << std::endl;
		}
}
