//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//  Copyright (C) 2010 Jonas Brich
//
//        brich@mail.hs-ulm.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This file is part of the "Unicap Video Server component".
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------

#include "ImageTask.hh"
#include "ComponentUnicapImageServer.hh"

#include <iostream>
#include <armadillo.hh>
#include "OpenCVHelpers/OpenCVHelpers.hh"

#include "ParameterStateStruct.hh"

#include "EulerTransformationMatrices.hh"
#include "Unicap.hh"

ImageTask::ImageTask(SmartACE::SmartComponent *comp) 
:	ImageTaskCore(comp)
{
	std::cout << "constructor ImageTask\n";
		_image_buffer_index = 0;
		_image_buffer.resize(2);
		 set_camera_params = true;
}
ImageTask::~ImageTask() 
{
	std::cout << "destructor ImageTask\n";
}


int ImageTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
		// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

		default_base_position.set_x(COMP->getGlobalState().getBase().getX());
		default_base_position.set_y(COMP->getGlobalState().getBase().getY());
		default_base_position.set_z(COMP->getGlobalState().getBase().getZ());
		default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getAzimuth());
		default_base_position.set_base_elevation(COMP->getGlobalState().getBase().getElevation());
		default_base_position.set_base_roll(COMP->getGlobalState().getBase().getRoll());

		zero_velocity.set_vX(0);
		zero_velocity.set_vY(0);
		zero_velocity.set_vZ(0);
		zero_velocity.set_WZ_base(0);
		zero_velocity.set_WY_base(0);
		zero_velocity.set_WZ_base(0);


		DomainVision::FormatType format;
		if (!DomainVision::CommVideoImage::string2format(COMP->getGlobalState().getImage().getSmart_format(), format)) {
			std::cout<<"ERROR in converting format"<<std::endl;
			return -1;
		}

		// Fill ring_buffer with empty images
		for (unsigned int i = 0; i < _image_buffer.size(); i++) {
		  _image_buffer[i] = new DomainVision::CommVideoImage(COMP->getGlobalState().getHardware_properties().getWidth(),
				  COMP->getGlobalState().getHardware_properties().getHeight(), format);
		}


		image = NULL;


		return 0;
}
int ImageTask::on_execute()
{
	// this method is called from an outside loop,
		// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
		// also do not use blocking calls which do not result from smartsoft kernel

		if(COMP->stateSlave->acquire("PushImage") == Smart::SMART_OK)
			{


				ParameterStateStruct localState = COMP->getGlobalState();

				image = _image_buffer[_image_buffer_index];

				// get newest image from Unicap
				try {

					UNICAPINZ->getImage(*image, localState);

				} catch (Unicap::UnicapException& e) {
					std::cerr << "Error: " << e.what() << " [ImageTask].\n";
					return -1;
				} catch (...) {
					std::cerr << "Error: Undefined Error. [ImageTask]\n";
					return -1;
				}

				if(set_camera_params)
				{
					set_camera_intrinsic_params();
					set_camera_params = false;
				}

				arma::mat sensorMat;
				EulerTransformationMatrices::create_zyx_matrix(localState.getSensor_pose().getX(), localState.getSensor_pose().getY(),
						localState.getSensor_pose().getZ(), localState.getSensor_pose().getAzimuth(), localState.getSensor_pose().getElevation(),
						localState.getSensor_pose().getRoll(), sensorMat);

				// set base state
				CommBasicObjects::CommBaseState base_state;
				if (localState.getBase().getOn_ptu()) {
					CommBasicObjects::CommDevicePoseState devicePoseState;
					Smart::StatusCode status = COMP->ptuPushTimedClient->getUpdate(devicePoseState);

					base_state = devicePoseState.get_base_state();
					CommBasicObjects::CommPose3d ptuPose = devicePoseState.get_device_pose3d_robot();
					arma::mat ptuMat = ptuPose.getHomogeneousMatrix();

					sensorMat = ptuMat * sensorMat;

					if (status != Smart::SMART_OK) {
						std::cerr << "WARNING: failed to get current ptu device state (" << Smart::StatusCodeConversion(status)
						<< "), pushing invalid image" << std::endl;
						image->set_data_invalid();
					}

				}
				// read base state from base server
				else if (localState.getBase().getOn_base()) {
					Smart::StatusCode status = COMP->basePushTimedClient->getUpdate(base_state);

					if (status != Smart::SMART_OK) {
						std::cerr << "WARNING: failed to get current base state (" << Smart::StatusCodeConversion(status)
						<< "), pushing invalid image" << std::endl;
						image->set_data_invalid();
					}
				}
				// default base state
				else {
					base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
					base_state.set_base_position(default_base_position);
					base_state.set_base_velocity(zero_velocity);
				}



				CommBasicObjects::CommPose3d sensorPose(sensorMat);
				image->set_sensor_pose(sensorPose);
				image->set_base_state(base_state);


				// Save the newest image into the global Pointer
				COMP->NewestImageMutex.acquire();
				COMP->newestImage = image;
				COMP->NewestImageMutex.release();

				//IplImage* TESTIMAGE = convertDataArrayToIplImage(*image, cvSize(image->get_width(), image->get_height()));
				//cvSaveImage("SmartUnicapImageServer-image.jpg",TESTIMAGE);
				//cvReleaseImage(&TESTIMAGE);


				COMP->imagePushNewestServer->put(*image);
				if (localState.getPush_newest().getDebug_info()) {
					std::cout << "Newest: Image sent.\n";
				}


				// calculate new index in the ring_buffer
				_image_buffer_index++;
				if (_image_buffer_index == _image_buffer.size())
				   _image_buffer_index = 0;

				COMP->stateSlave->release("PushImage");
			}
			// calculate new index in the ring_buffer
			//		_ring_buffer_index++;
			//		if (_ring_buffer_index == _ring_buffer.size())
			//			_ring_buffer_index = 0;

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int ImageTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
		for (unsigned int i = 0; i < _image_buffer.size(); i++) {
			delete _image_buffer[i];
		}
		_image_buffer.clear();
		return 0;
}

IplImage* ImageTask::convertDataArrayToIplImage(DomainVision::CommVideoImage &query_image, CvSize size)
{
        IplImage* ipl_image = NULL;

        if (query_image.get_format() == DomainVision::FormatType::UYVY || query_image.get_format() == DomainVision::FormatType::RGB24)
        {
                unsigned char* arr_image = new unsigned char[query_image.get_size_as_rgb24()];
                query_image.get_as_rgb24(arr_image);

                ipl_image = OpenCVHelpers::copyRGBToIplImage(arr_image, query_image.get_height(), query_image.get_width());
                delete arr_image;

        } else if (query_image.get_format() == DomainVision::FormatType::GREY)
        {
                CvMat mat;
                cvInitMatHeader(&mat, size.height, size.width, CV_8UC1, const_cast<unsigned char *> (query_image.get_data()));
                ipl_image = cvCreateImage(size, IPL_DEPTH_8U, 1);

                // copy matrix data into image
                cvCopy(&mat, ipl_image);

        } else if (query_image.get_format() == DomainVision::FormatType::YUV422)
        {
                unsigned char* arr_image = new unsigned char[query_image.get_size_as_rgb24()];
                query_image.get_as_rgb24(arr_image);

                ipl_image = OpenCVHelpers::copyRGBToIplImage(arr_image, query_image.get_height(), query_image.get_width());
                delete arr_image;

        } else
        {
                std::cout << "Image Format: " << query_image.get_format() << " not supported!" << std::endl;
        }

        return ipl_image;

}
//----------------------------------------------------------------
// ImagePushNewestCleanupThread - Methods
//----------------------------------------------------------------
//
//ImageTask::ImageCleanupThread::ImageCleanupThread() {
//	_queue_sem.acquire();
//}
//
//int ImageTask::ImageCleanupThread::svc() {
//	CommVisionObjects::CommVideoImage *img = 0;
//	while (true) {
//		_queue_sem.acquire();
//		_queue_mutex.acquire();
//		img = _queue.front();
//		_queue.pop();
//		_queue_mutex.release();
//		if (img == 0) {
//			if (COMP->ini.push_newest.debug_info)
//				std::cout << "Newest-CleanUpThread: Stopping SVC\n";
//			break; // "0" means stop, can be done over the method stopThread()
//		}
//		delete img; // may block on semaphore protecting shm
//		if (COMP->ini.push_newest.debug_info)
//			std::cout << "Newest-CleanUpThread: Image deleted\n";
//	}
//	return 0;
//}
//
//void ImageTask::ImageCleanupThread::_enqueue(CommVisionObjects::CommVideoImage *image) {
//	_queue_mutex.acquire();
//	_queue.push(image);
//	_queue_mutex.release();
//	_queue_sem.release();
//}
//
//ImageTask::ImageCleanupThread::~ImageCleanupThread() {
//}

void ImageTask::set_camera_intrinsic_params()
{
	ParameterStateStruct localState = COMP->getGlobalState();
	double fx = localState.getIntrinsicParams().getFx();
	double fy = localState.getIntrinsicParams().getFy();
	double cx = localState.getIntrinsicParams().getCx();
	double cy = localState.getIntrinsicParams().getCy();
	double calib_width = localState.getIntrinsicParams().getCalib_width();
	double calib_height = localState.getIntrinsicParams().getCalib_height();
	std::list<double> dc = localState.getIntrinsicParams().getDistortion_coeffs();

	for (unsigned int i = 0; i < _image_buffer.size(); ++i) {

		//set camera matrix (K 4x4)
		_image_buffer[i]->setIntrinsic_mElemAtPos(0, fx);
		_image_buffer[i]->setIntrinsic_mElemAtPos(5, fy);
		_image_buffer[i]->setIntrinsic_mElemAtPos(2, cx);
		_image_buffer[i]->setIntrinsic_mElemAtPos(6, cy);
		_image_buffer[i]->setIntrinsic_mElemAtPos(10, 1);

		// set distortion coefficients (D 1x5)
		std::vector<double> distortion_v{ std::begin(dc), std::end(dc) };
		_image_buffer[i]->setDistortion_m(distortion_v);

		// Update camera martix, if the image width and height are not same as the width and height of images used for calibration
		unsigned int image_width = _image_buffer[i]->get_width();
		unsigned int image_height = _image_buffer[i]->get_height();

		if(calib_height != image_height || calib_width != image_width)
		{
			_image_buffer[i]->setIntrinsic_mElemAtPos(0, fx*(double(image_width)/double(calib_width)));
			_image_buffer[i]->setIntrinsic_mElemAtPos(5, fy*(double(image_height)/double(calib_height)));
			_image_buffer[i]->setIntrinsic_mElemAtPos(2, cx*(double(image_width)/double(calib_width)));
			_image_buffer[i]->setIntrinsic_mElemAtPos(6, cy*(double(image_height)/double(calib_height)));

			std::cout << " Camera parameters scaled according to the image Height and Width" << std::endl;

		}

	}
}
