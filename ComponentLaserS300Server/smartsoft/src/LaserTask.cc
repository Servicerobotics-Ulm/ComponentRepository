//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//				  2013 Timo Hegele
//
//        schlegel@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------


#include "LaserTask.hh"
#include "ComponentLaserS300Server.hh"
#include <EulerTransformationMatrices.hh>
#include <iostream>

LaserTask::LaserTask(SmartACE::SmartComponent *comp) 
:	LaserTaskCore(comp)
{
	zero_velocity.setVX(0);
	zero_velocity.setVY(0);
	zero_velocity.setVZ(0);
	zero_velocity.setWX(0);
	zero_velocity.setWY(0);
	zero_velocity.setWZ(0);

	_default_base_position.set_x(COMP->getGlobalState().getBase_manipulator().getX());
	_default_base_position.set_y(COMP->getGlobalState().getBase_manipulator().getY());
	_default_base_position.set_z(COMP->getGlobalState().getBase_manipulator().getZ());
	_default_base_position.set_base_azimuth(COMP->getGlobalState().getBase_manipulator().getBase_a());
	_default_base_position.set_base_elevation(COMP->getGlobalState().getBase_manipulator().getSteer_a());
	_default_base_position.set_base_roll(COMP->getGlobalState().getBase_manipulator().getTurret_a());

	// set scan id counter to 0
	scan_id = 0;
}
LaserTask::~LaserTask() 
{
	std::cout << "destructor LaserTask\n";
}



int LaserTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	min_dist = COMP->getGlobalState().getScanner().getMin_range();
	max_dist = COMP->getGlobalState().getScanner().getMax_range();
	lenght_unit = COMP->getGlobalState().getScanner().getLength_unit();
	opening_angle = COMP->getGlobalState().getScanner().getOpening_angle()*100;

	bool bOpenScan = false, bRecScan = false;
	bool firstTry = true;
	// open device
	while (!bOpenScan)
 	{
		bOpenScan = laser.open(COMP->getGlobalState().getScanner().getDevice().c_str(), COMP->getGlobalState().getScanner().getBaudrate());

		if(firstTry)
		{
			std::cout<<"...scanner not available on dev "<< COMP->COMP->getGlobalState().getScanner().getDevice() << std::endl << "Will retry every second."<<std::endl;
			firstTry = false;
			sleep(1);
		}
		else
		{
			sleep(1);
		}
	}

	std::cout << "[LaserTask] Connected to serial port ..." << std::endl;

	std::cout << "[LaserTask] Setting scan configuration ..." << ::std::endl;



	scan_resolution = round(COMP->getGlobalState().getScanner().getResolution() * 100.0);
	ranger_opening_angle = 27000;// / 100.0;
//	ranger_opening_angle = COMP->getGlobalState().getScanner().opening_angle;// / 100.0;

//	std::cout << "[LaserTask] Scanning Frequency: " << c.scaningFrequency / 100.0 << "Hz | AngleResolution: "
//			<< c.angleResolution / 10000.0 << "deg | StartAngle: " << c.startAngle / 10000.0 << "deg | StopAngle: "
//			<< c.stopAngle / 10000.0 << "deg \n";

	std::vector<double> dummy1, dummy2;
	std::vector<unsigned int> dummy3;
	std::vector<bool> dummy4, dummy5;
	int retry_counter = 0;

		// open device
	while(!laser.getScan(dummy1, dummy2, dummy3, dummy4, dummy5))
	{
			if(retry_counter>=5){
				retry_counter = 0;
				std::cout<<"Close scanner dev!"<<std::endl;
				laser.close();
				sleep(1);
				// open device
				firstTry = true;
				bOpenScan = false;
				while (!bOpenScan)
			 	{
					std::cout<<"Open scanner dev!"<<std::endl;
					bOpenScan = laser.open(COMP->getGlobalState().getScanner().getDevice().c_str(), COMP->getGlobalState().getScanner().getBaudrate());

					if(firstTry)
					{
						std::cout<<"...scanner not available on dev "<< COMP->COMP->getGlobalState().getScanner().getDevice() << std::endl << "Will retry every second."<<std::endl;
						firstTry = false;
						sleep(1);
					}
					else
					{
						sleep(1);
					}
				}
			}

			std::cout << "[LaserTask] Probing for valid laser Scans on dev " << COMP->COMP->getGlobalState().getScanner().getDevice()<<" ...["<<retry_counter<<"]"<<std::endl;
			sleep(1);
			retry_counter++;
	}
	return 0;
}
int LaserTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

if (accquireNewScan(scan, laserSafetyEvent)) {
			bool scan_is_valid = false;

			//////////////////////////
			// set base state
			//////////////////////////
			if (COMP->COMP->getGlobalState().getScanner().getVerbose())
				std::cout << "[LaserTask] set base state\n";

			// read base state from base server
			if (COMP->COMP->getGlobalState().getBase_manipulator().getOn_base()) {
				Smart::StatusCode status = COMP->baseTimedClient->getUpdate(base_state);

				if (status == Smart::SMART_OK) {
					scan_is_valid = true;

					if (COMP->COMP->getGlobalState().getScanner().getVerbose()) {
						std::cout << base_state << "\n";
					}
				} else {
					std::cerr << "[LaserTask] WARNING: failed to get current base state ("
							<< Smart::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
					scan.set_scan_valid(false);
				}
			}
			// default base state
			else {
				base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
				base_state.set_base_position(_default_base_position);
				base_state.set_base_velocity(zero_velocity);
				scan_is_valid = true;
			}
			scan.set_base_state(base_state);

			//////////////////////////
			// set robot scanner position
			//////////////////////////
			double x = COMP->getGlobalState().getScanner().getX();
			double y = COMP->getGlobalState().getScanner().getY();
			double z = COMP->getGlobalState().getScanner().getZ();
			double azimuth = COMP->getGlobalState().getScanner().getAzimuth();
			double elevation = COMP->getGlobalState().getScanner().getElevation();
			double roll = COMP->getGlobalState().getScanner().getRoll();
			arma::mat mat_sensor;

			EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_sensor);

			CommBasicObjects::CommPose3d sensor_pose(mat_sensor);
			scan.set_sensor_pose(sensor_pose);

			//////////////////////////
			// set world scanner position
			//////////////////////////
			double base_x = 0;
			double base_y = 0;
			double base_z = 0;
			double base_a = 0;
			arma::mat mat_base(4, 4);

			if (scan_is_valid) {
				base_x = base_state.get_base_position().get_x();
				base_y = base_state.get_base_position().get_y();
				base_z = base_state.get_base_position().get_z();
				//TODO: fix that
				if (COMP->getGlobalState().getScanner().getOn_turret()) {
					base_a = base_state.get_base_position().get_base_azimuth();
				} else {
					 base_a = base_state.get_base_position().get_base_azimuth();
				}
			}

			EulerTransformationMatrices::create_zyx_matrix(base_x, base_y, base_z, base_a, 0, 0, mat_base);
			arma::mat mat_world = mat_base * mat_sensor;
			CommBasicObjects::CommPose3d world_pose(mat_world);

			scan.set_scanner_x(world_pose.get_x());
			scan.set_scanner_y(world_pose.get_y());
			scan.set_scanner_z(world_pose.get_z());

			scan.set_scanner_azimuth(world_pose.get_azimuth());
			scan.set_scanner_elevation(world_pose.get_elevation());
			scan.set_scanner_roll(world_pose.get_roll());


			//////////////////////////
			// send scan to clients
			//////////////////////////
			if (COMP->getGlobalState().getScanner().getVerbose())
				std::cout << "[LaserTask] send scan to clients\n";

			if (COMP->getGlobalState().getServices().getActivate_push_newest()) {
				Smart::StatusCode push_status = COMP->laserPushNewestServer->put(scan);
				if (push_status != Smart::SMART_OK) {
					std::cerr << "[LaserTask] WARNING: error on push (" << Smart::StatusCodeConversion(push_status)
							<< ")" << std::endl;
				}
			}

			if (COMP->getGlobalState().getServices().getActivate_safetyEventServer()) {
				//std::cout<<"Protective state: "<<laserSafetyEvent.getProtectiveState()<<" | "<<"Warning state:"<<laserSafetyEvent.getWarningState()<<std::endl;
				Smart::StatusCode status = COMP->safetyfieldEventServer->put(laserSafetyEvent);
				if (status != Smart::SMART_OK) {
					std::cerr << "[LaserTask] WARNING: error on event (" << Smart::StatusCodeConversion(status)
							<< ")" << std::endl;
				}
			}

			// copy local scan to global scan
			SmartACE::SmartGuard scan_guard(COMP->ScanLock);
			COMP->global_scan = scan;
			scan_guard.release();

			/*if (COMP->getGlobalState().getScanner().verbose) {
				const unsigned int index = scan.get_scan_size() / 2;
				std::cout << "[LaserTask] Scan " << scan_id << " sent." << " Scan Position " << index << "/"
						<< scan.get_scan_size() << " = " << scan.get_scan_distance(index - 1) << " mm" << std::endl;
			}*/
		} else {
			std::cerr << "[LaserTask] WARNING: received unexpected packet type" << std::endl;
		}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int LaserTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again

	laser.stopScanner();

	return 0;
}

bool LaserTask::accquireNewScan(CommBasicObjects::CommMobileLaserScan& scan, CommBasicObjects::CommLaserSafetyEventState& secEvt) {
	bool retVal = false;
	bool protectiveField = false;
	bool warningfield = false;
	std::vector<double> vdDistM, vdAngRAD;
	std::vector<unsigned int> vdIntensAU;
	std::vector<bool> vWarning, vProtective;
	//get a scan from the interface
	if(laser.getScan(vdDistM, vdAngRAD, vdIntensAU, vWarning, vProtective))
	{
		// set scan header
		scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp::now());
		scan.set_scan_update_count(scan_id);

		//////////////////////////
		// set scan parameters
		//////////////////////////
		if (COMP->getGlobalState().getScanner().getVerbose())
			std::cout << "set scan parameters\n";

		scan.set_scan_length_unit(lenght_unit);
		scan.set_scan_integer_field_of_view(-0.5 * opening_angle, scan_resolution);
		scan.set_min_distance(min_dist);
		scan.set_max_distance(max_dist);

		//////////////////////////
		// set scan points
		//////////////////////////
		const int desiredScans = 1 + opening_angle / scan_resolution;
		const int rangerScans = 1 + ranger_opening_angle / scan_resolution;

		scan.set_max_scan_size(desiredScans);

		const int firstScanIndex = (rangerScans - desiredScans) * 0.5;
		int lastScanIndex = rangerScans - firstScanIndex;

		if (lastScanIndex > vdDistM.size())
			lastScanIndex = vdDistM.size();

		if (COMP->getGlobalState().getScanner().getVerbose()) {
			std::cout << "Read scans: " << vdDistM.size() << "\n";
			std::cout<<" Max possible size: "<<desiredScans<<std::endl;
		}

		uint32_t num_valid_points = 0;
		for (int i = firstScanIndex; i < lastScanIndex; ++i) {
			const unsigned int dist = vdDistM[i]*1000;
			if (dist >= min_dist && dist <= max_dist) {
				++num_valid_points;
			}
		}

		scan.set_scan_size(num_valid_points);
		uint32_t valid_point_index = 0;
		bool protective = false;
		bool warning = false;


		for (int i = firstScanIndex; i < lastScanIndex; ++i) {
			const unsigned int dist = vdDistM[i]*1000;
			if (dist >= min_dist && dist <= max_dist) {
				scan.set_scan_index(valid_point_index, i - firstScanIndex);
				scan.set_scan_integer_distance(valid_point_index, dist);
				scan.set_scan_intensity(valid_point_index, vdIntensAU[i]);
				//scan.set_scan_intensity(valid_point_index, (vdIntensAU[i] != 0) ? 1 : 0);

				if(vWarning[i] == true){
					warning = true;
				}
				if(vProtective[i] == true){
					protective = true;
				}
				++valid_point_index;
			}
		}

		if(warning == true){
			secEvt.setWarningState(CommBasicObjects::SafetyFieldState::BLOCKED);
		} else {
			secEvt.setWarningState(CommBasicObjects::SafetyFieldState::FREE);
		}
		if(protective == true){
			secEvt.setProtectiveState(CommBasicObjects::SafetyFieldState::BLOCKED);
		} else {
			secEvt.setProtectiveState(CommBasicObjects::SafetyFieldState::FREE);
		}

		scan.set_scan_valid(true);
		scan_id++;
		retVal = true;
	}
	return retVal;
}


///*
// * This method populates a single safety field for the S300 based on blocked/occupied flags as given from the laser
// */
//void LaserTask::populateSecField(CommBasicObjectsIDL::LaserSafetyField& secField, bool warn, bool prot)
//{
//	//no version of the S300 differs between the configured safety fields
//	secField.id = 0;
//	if(warn || prot)
//	{
//		secField.state = CommBasicObjects::SafetyFieldState::BLOCKED;
//		if(prot)//this scan is a protective field
//		{
//			secField.type = CommBasicObjects::LaserSafetyFieldType::PROTECTIVE;
//		}else//this scan is a warning field is Blocked
//		{
//			//only override the current state if previously a PROTECTIVE field was detected. The S300 and firmware >=2.1 ALWAYS and ONLY detects PROTECTIVE fields, because it doesn't differ between warning and protective
//			if(secField.type != CommBasicObjects::LaserSafetyFieldType::PROTECTIVE)
//			{
//				secField.type = CommBasicObjects::LaserSafetyFieldType::WARNING;
//			}
//		}
//	}else
//	{
//		//make sure a blocked state doesn't get overwritten to be free (for the cases FREE and UNKNOWN)
//		if(secField.state != CommBasicObjects::SafetyFieldState::BLOCKED)
//		{
//			secField.state = CommBasicObjects::SafetyFieldState::FREE;
//			secField.type = CommBasicObjects::LaserSafetyFieldType::OTHER;
//		}
//	}
//}

