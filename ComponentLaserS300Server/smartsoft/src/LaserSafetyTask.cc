//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "LaserSafetyTask.hh"
#include "ComponentLaserS300Server.hh"

#include <iostream>

LaserSafetyTask::LaserSafetyTask(SmartACE::SmartComponent *comp) 
:	LaserSafetyTaskCore(comp)
{
	std::cout << "constructor LaserSafetyTask\n";

	laserSafetyFieldIOBit = COMP->getParameters().getSafetyEvents().getLaserSafetyBit();
	laserSafetyFieldTimerId = -1;
	laserSafetyFieldTimeoutSec = COMP->getParameters().getSafetyEvents().getLaserSafetyFieldTimeOutSec();
	laserSafetyFieldTimeoutMsec = COMP->getParameters().getSafetyEvents().getLaserSafetyFieldTimeOutMSec();
	laserSafetyFieldLastState = 1;

}
LaserSafetyTask::~LaserSafetyTask() 
{
	std::cout << "destructor LaserSafetyTask\n";
}


void LaserSafetyTask::on_CommIOForkingServiceIn(const CommBasicObjects::CommIOValues &input)
{
	// upcall triggered from InputPort CommIOForkingServiceIn
	// - use a local mutex here, because this upcal is called asynchroneously from outside of this task
	// - do not use longer blocking calls here since this upcall blocks the InputPort CommIOForkingServiceIn
	// - if you need to implement a long-running procedure, do so within the on_execute() method and in
	//   there, use the method commIOForkingServiceInGetUpdate(input) to get a copy of the input object
}

int LaserSafetyTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int LaserSafetyTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;
	CommBasicObjects::CommIOValues commIOForkingServiceInObject;
	status = this->commIOForkingServiceInGetUpdate(commIOForkingServiceInObject);
	if(status != Smart::SMART_OK) {
		std::cerr << status << std::endl;
		// return 0;
	} else {

		////////////////////////////////////////////////////////////////
		//robotino laser safety field state evalution
		//this should be realized within a laser server component
		//due to firmware issues with the sick s300 laser sever the evaluation of the lasersafety fields
		//is done using the digital io of the robotino base
		//This will only work if the laser is configured to switch the io and connected to the digital ios of the robotino base!

//		int laserSafetyFieldCurrentState = digitalInputs[0];
		int laserSafetyFieldCurrentState = commIOForkingServiceInObject.getDigitalInputValuesElemAtPos(laserSafetyFieldIOBit);

		if(laserSafetyFieldCurrentState != laserSafetyFieldLastState){

			if(laserSafetyFieldCurrentState == 0){
				//we need some timeout here. If station is invisible for more than x seconds, we abort this task
				if(laserSafetyFieldTimerId == -1){
					std::cout << "[LaserSafetyTask::on_execute()] laserSafety Event scheduleTimer relative time: " << laserSafetyFieldTimeoutSec << " : " << laserSafetyFieldTimeoutMsec << std::endl;

					std::chrono::seconds sec(laserSafetyFieldTimeoutSec);
					std::chrono::milliseconds msec(laserSafetyFieldTimeoutMsec);
					laserSafetyFieldTimerId = COMP->getComponentImpl()->getTimerManager()->scheduleTimer(this,NULL,sec+msec);
				} else {
					std::cout<<__FUNCTION__<<":"<<__LINE__<<"ERROR: this should never had happened!"<<std::endl;
				}

			} else {
				//abort timer
				if(laserSafetyFieldTimerId != -1)
				{
					std::cout << "[LaserSafetyTask::on_execute()] laserSafety Event cancelTimer!"<< std::endl;
					COMP->getComponentImpl()->getTimerManager()->cancelTimer(laserSafetyFieldTimerId);
					laserSafetyFieldTimerId = -1;
				} else {
					std::cout<<__FUNCTION__<<":"<<__LINE__<<" ERROR: this should never had happened!"<<std::endl;
				}

				//send free state immediately
				CommBasicObjects::CommLaserSafetyEventState state;
				state.setProtectiveState(CommBasicObjects::SafetyFieldState::FREE);
				COMP->safetyfieldEventServer->put(state);
			}

			laserSafetyFieldLastState = laserSafetyFieldCurrentState;
		} else {
			//state not changed this is only used for output!
			if (laserSafetyFieldCurrentState == 0){
				if(COMP->getGlobalState().getScanner().getVerbose()){
					std::cout << "LaserSafety blocked!" << std::endl;
				}
				if(laserSafetyFieldTimerId == -1){
					std::cout << "[LaserSafetyTask::on_execute()] laserSafety Event scheduleTimer relative time: " << laserSafetyFieldTimeoutSec << " : " << laserSafetyFieldTimeoutMsec << std::endl;
					std::chrono::seconds sec(laserSafetyFieldTimeoutSec);
					std::chrono::milliseconds msec(laserSafetyFieldTimeoutMsec);
					laserSafetyFieldTimerId = COMP->getComponentImpl()->getTimerManager()->scheduleTimer(this,NULL, sec+msec);
				}
			}
		}
		////////////////////////////////////////////////////////////////


	}


	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int LaserSafetyTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}


//void Robot::timerExpired(const ACE_Time_Value & absolute_time,const void * arg){
void LaserSafetyTask::timerExpired(const Smart::TimePoint &abs_time, const void * arg){

	std::cout<<"[Robot:laserSafetyFieldTimerExpired] LaserSafetyField blocked timeout!"<<std::endl;

	COMP->getComponentImpl()->getTimerManager()->cancelTimer(laserSafetyFieldTimerId);
	laserSafetyFieldTimerId = -1;
	CommBasicObjects::CommLaserSafetyEventState state;
	state.setProtectiveState(CommBasicObjects::SafetyFieldState::BLOCKED);
	COMP->safetyfieldEventServer->put(state);

}

void LaserSafetyTask::timerCancelled(){};
void LaserSafetyTask::timerDeleted(const void * arg){};
