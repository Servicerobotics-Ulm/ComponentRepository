//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs.
// If you want the toolchain to re-generate this file, please
// delete it before running the code generator.
//--------------------------------------------------------------------------
//------------------------------------------------------------------------
//
//  Copyright (C) 2010 Manuel Wopfner
//                2020 Thomas Feldmeier
//
//        thomas.feldmeier@thu.de
//
//        Christian Schlegel (schlegel@hs-ulm.de)
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm (Germany)
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//--------------------------------------------------------------------------
#include "LaserTask.hh"
#include "ComponentWebots2DLidar.hh"
#include <EulerTransformationMatrices.hh>

#include <climits>
#include <cstdint>
#include <iostream>

#include <webots/Device.hpp>
#include <webots/Node.hpp>

#include <iostream>

// from https://stackoverflow.com/questions/154536/encode-decode-urls-in-c
std::string url_encode(const std::string &value) {
    std::ostringstream escaped;
    escaped.fill('0');
    escaped << std::hex;
    for (std::string::const_iterator i = value.begin(), n = value.end(); i != n; ++i) {
        std::string::value_type c = (*i);
        // Keep alphanumeric and other accepted characters intact
        if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
            escaped << c;
            continue;
        }
        // Any other characters are percent-encoded
        escaped << std::uppercase;
        escaped << '%' << std::setw(2) << int((unsigned char) c);
        escaped << std::nouppercase;
    }
    return escaped.str();
}

LaserTask::LaserTask(SmartACE::SmartComponent *comp) :
    LaserTaskCore(comp) {
    std::cout << "constructor LaserTask\n";
    _default_base_position.set_x(COMP->getGlobalState().getBase_manipulator().getX());
    _default_base_position.set_y(COMP->getGlobalState().getBase_manipulator().getY());
    _default_base_position.set_z(COMP->getGlobalState().getBase_manipulator().getZ());
    _default_base_position.set_base_azimuth(COMP->getGlobalState().getBase_manipulator().getBase_a());
}

LaserTask::~LaserTask() {
    std::cout << "destructor LaserTask\n";
}

int LaserTask::on_entry() {
    std::string robotName = COMP->getParameters().getWebots().getRobotName();
    char environment[256] = "WEBOTS_CONTROLLER_URL=";
    putenv(strcat(environment, url_encode(robotName).c_str()));
    std::cout << "\033[0;32mConnect to webots robot with name '" << robotName << "' ...\033[0m" << std::endl;
    webotsRobot = new webots::Robot();
    if (!webotsRobot) {
        std::cerr << "Webots robot '" << robotName << "' not found" << std::endl;
        return -1;
    }
    webotsLidar = NULL;
    for (int i = 0; i < webotsRobot->getNumberOfDevices(); i++) {
        webots::Device *webotsDevice = webotsRobot->getDeviceByIndex(i);
        std::cout << "Device " << i << " name=" << webotsDevice->getName() << " type=" << webotsDevice->getNodeType() << std::endl;
        if (webotsDevice->getNodeType() == webots::Node::LIDAR) {
            std::string lidarName = webotsDevice->getName();
            webotsLidar = webotsRobot->getLidar(lidarName);
            webotsLidar->enable(webotsRobot->getBasicTimeStep());
            webotsLidar->enablePointCloud();
            std::cout << "Device #" << i << " called " << lidarName << " is a lidar." << std::endl;
            horizontalResolution = webotsLidar->getHorizontalResolution();
            numberValidPoints = webotsLidar->getNumberOfPoints();
            double hfov_deg = webotsLidar->getFov() * 180 / M_PI;
            scan.set_scan_size(numberValidPoints);
            scan.set_max_scan_size(numberValidPoints);
            scan.set_scan_integer_field_of_view(-horizontalResolution * UNIT_FACTOR / 2.0,
                horizontalResolution * UNIT_FACTOR);
            std::cout << " horizontalResolution : " << horizontalResolution << std::endl;
            std::cout << " numberValidPoints : " << numberValidPoints << std::endl;
            std::cout << " hfov_deg : " << hfov_deg << std::endl;
            //scan.set_scan_integer_field_of_view(-1* hfov_deg * UNIT_FACTOR / 2.0, (hfov_deg/numberValidPoints)*UNIT_FACTOR);
            // pay attention to limits as min/max_distance variables are short type (max value is 65535)
            if (webotsLidar->getMaxRange() * M_TO_MM > SHORT_LIMIT) {
                std::cout << "The lidar range is bigger than 65.535 meters and will be set to 65 meters." << std::endl;
                scan.set_max_distance(65 * M_TO_MM);
            } else {
                scan.set_max_distance(webotsLidar->getMaxRange() * M_TO_MM);
            }

            std::cout << "laser max :" << webotsLidar->getMaxRange() << std::endl;
            std::cout << "laser min :" << webotsLidar->getMinRange() << std::endl;
            scan.set_min_distance(webotsLidar->getMinRange() * M_TO_MM);
            scan.set_scan_length_unit(MEASURE_UNIT);
            break;
        }
    }
    if (!webotsLidar) {
        std::cout << "No lidar found, no data is sent." << std::endl;
        return -1;
    }

    zero_velocity.set_vX(0);
    zero_velocity.set_WX_base(0);

    min_range = COMP->getGlobalState().getScanner().getMin_range();
    max_range = COMP->getGlobalState().getScanner().getMax_range();
    opening_angle = COMP->getGlobalState().getScanner().getOpening_angle();
    resolution = COMP->getGlobalState().getScanner().getResolution();
    length_unit = COMP->getGlobalState().getScanner().getLength_unit();
    frequency = COMP->getGlobalState().getScanner().getFrequency();

    std::cout << "-----------------------------------------------------------------" << std::endl;
    std::cout << std::setw(40) << "Laser Parameters" << std::endl;
    std::cout << "-----------------------------------------------------------------" << std::endl;
    std::cout << std::setw(25) << "Angle resolution = " << resolution << " degrees" << std::endl;
    std::cout << std::setw(25) << "Horizontal Field of View = " << opening_angle << " degrees" << std::endl;
    std::cout << std::setw(25) << "Number of rays = " << (opening_angle / resolution + 1) << std::endl;
    std::cout << std::setw(25) << "Start_angle = " << -0.5 * opening_angle << std::endl;
    std::cout << std::setw(25) << "End_angle = " << 0.5 * opening_angle << std::endl;
    std::cout << std::setw(25) << "Min distance = " << min_range / 1000.0 << " meters" << std::endl;
    std::cout << std::setw(25) << "Max distance = " << max_range / 1000.0 << " meters" << std::endl;
    std::cout << "-----------------------------------------------------------------" << std::endl;

    lastTimeStep = CommBasicObjects::CommTimeStamp::now();
    return 0;
}

int LaserTask::on_execute() {
    while (webotsRobot->step(webotsRobot->getBasicTimeStep()) != -1) {
        const int inputSize = webotsLidar->getHorizontalResolution();
        const float *inputData = webotsLidar->getRangeImage();
        double inputAngle = webotsLidar->getFov() / M_PI * 180.0;
        const int outputSize = 1 + std::round(opening_angle / resolution);
        double outputAngle = opening_angle;
        for(int runTwice=0; runTwice<2; runTwice++) {
          int validPoints=0;
          for(int i=0; i<outputSize; i++) {
            double pos = ((double)i)/(outputSize-1); // 0.0=rightmost entry in outputData ... 1.0=left
            // webots orders scan points from left to right, but smartsoft from right to left
            pos = 1.0-2.0*pos; // -1.0=left ... 1.0=right
            pos = pos * outputAngle; // => degrees
            pos = pos / inputAngle; // -1.0=first entry in inputData, +1.0=last
            int index = std::round((pos+1.0)/2.0*(inputSize-1));
            if(index>=0 && index<inputSize) {
//            In webots distances are floating point numbers [m], but in smartsoft lidar distances are unsigned short (16 bit) [mm]
//            (=> max. distance 65535 mm, you can set length_unit to e.g. 10 to change from mm to cm so lidar has bigger maxRange but less accuracy)
              double dist = inputData[index]*1000; // m -> mm
//            what happens if there is no obstacle between minRange and maxRange of the lidar ray?
//            webots will return infinity as distance (even in case obstacle < minRange)
//            smartsoft will handle this data point as 'invalid', removing this point from CommMobileLaserScan
//            (get_scan_angle(i) returns the angle of an data point, 0=front of lidar, pi/2=left of lidar, 3*pi/2=right of lidar, 0<=angle<2*pi)
              if(dist >= min_range && dist <= max_range) {
                if(runTwice==1) {
                  scan.set_scan_index(validPoints, i);
                  scan.set_scan_integer_distance(validPoints, dist / length_unit);
                  scan.set_scan_intensity(validPoints, 0);
                }
                validPoints++;
              }
            }
          }
          if(runTwice==0)
            scan.set_scan_size(validPoints);
        }

        // webots is updating the physics world only every timeStep,
        // so scanning was done last timeStep
        scan.set_scan_time_stamp(lastTimeStep);
        lastTimeStep = CommBasicObjects::CommTimeStamp::now();

        scan.set_scan_update_count(scanCounter++);
        scan.set_scan_length_unit(length_unit);
        scan.set_scan_double_field_of_view(-0.5 * opening_angle, resolution);
        scan.set_min_distance(min_range);
        scan.set_max_distance(max_range);
        scan.set_max_scan_size(outputSize);
        scan.set_scan_valid(true);

        bool scan_is_valid = false;

        // read base state from base server
        if (COMP->getGlobalState().getBase_manipulator().getOn_base()) {
            Smart::StatusCode status = COMP->baseStateServiceIn->getUpdate(base_state);
            if (status == Smart::SMART_OK) {
                scan_is_valid = true;
            } else {
                std::cerr << "[LaserTask] WARNING: failed to get current base state ("
                    << Smart::StatusCodeConversion(status) << "), pushing invalid scan" << std::endl;
                scan.set_scan_valid(false);
            }
        }
        // default base state
        else {
            base_state.set_time_stamp(CommBasicObjects::CommTimeStamp::now());
            base_state.set_base_position(_default_base_position);
            base_state.set_base_velocity(zero_velocity);
            scan_is_valid = true;
        }
        scan.set_base_state(base_state);

        //////////////////////////
        // set robot scanner position
        //////////////////////////
        double x = COMP->getGlobalState().getScanner().getX();
        double y = COMP->getGlobalState().getScanner().getY();
        double z = COMP->getGlobalState().getScanner().getZ();
        double azimuth = COMP->getGlobalState().getScanner().getAzimuth();
        double elevation = COMP->getGlobalState().getScanner().getElevation();
        double roll = COMP->getGlobalState().getScanner().getRoll();
        arma::mat mat_sensor;

        EulerTransformationMatrices::create_zyx_matrix(x, y, z, azimuth, elevation, roll, mat_sensor);

        CommBasicObjects::CommPose3d sensor_pose(mat_sensor);
        scan.set_sensor_pose(sensor_pose);

        //////////////////////////
        // set world scanner position
        //////////////////////////
        double base_x = 0;
        double base_y = 0;
        double base_z = 0;
        double base_a = 0;
        arma::mat mat_base(4, 4);

        if (scanCounter == 0)
            lastBasePosition = base_state.get_base_position();

        if (scan_is_valid) {
            base_x = lastBasePosition.get_x();
            base_y = lastBasePosition.get_y();
            base_z = lastBasePosition.get_z();
            if (COMP->getGlobalState().getScanner().getOn_turret()) {
                //base_a = base_state.get_base_position().get_turret_alpha();
            } else {
                base_a = lastBasePosition.get_base_azimuth();
            }
        }
        // use robot's position of last physics timeStep instead of the actual timeStep,
        // because lidar data was generated at last timeStep too
        lastBasePosition = base_state.get_base_position();

        EulerTransformationMatrices::create_zyx_matrix(base_x, base_y, base_z, base_a, 0, 0, mat_base);
        arma::mat mat_world = mat_base * mat_sensor;
        CommBasicObjects::CommPose3d world_pose(mat_world);

        scan.set_scanner_x(world_pose.get_x());
        scan.set_scanner_y(world_pose.get_y());
        scan.set_scanner_z(world_pose.get_z());

        scan.set_scanner_azimuth(world_pose.get_azimuth());
        scan.set_scanner_elevation(world_pose.get_elevation());
        scan.set_scanner_roll(world_pose.get_roll());

        //////////////////////////
        // send scan to clients
        //////////////////////////

        if (COMP->getGlobalState().getServices().getActivate_push_newest()) {
            Smart::StatusCode push_status = COMP->laserServiceOut->put(scan);
            if (push_status != Smart::SMART_OK) {
                std::cerr << "[LaserTask] WARNING: error on push (" << Smart::StatusCodeConversion(push_status) << ")"
                    << std::endl;
            }
        }

        // copy local scan to global scan
        SmartACE::SmartGuard scan_guard(COMP->ScanLock);
        COMP->global_scan = scan;
        scan_guard.release();

        if (COMP->getGlobalState().getScanner().getVerbose()) {
            const unsigned int index = scan.get_scan_size() / 2;
//            std::cout << "[LaserTask] Scan " << scanCounter << " sent." << " Scan Position " << index << "/"
//                    << scan.get_scan_size() << " = " << scan.get_scan_distance(index - 1) << " mm" << std::endl;
        }
    }
    delete webotsRobot;
    return 1; // ends this thread after webots world ends
}

int LaserTask::on_exit() {
    std::cout << "[LaserTask] Disconnect from laser" << std::endl;
    return 0;
}
