//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------

#include "DockingTask.hh"
#include "ComponentWebotsMpsDocking.hh"

#include <iostream>

DockingTask::DockingTask(SmartACE::SmartComponent *comp) :
    DockingTaskCore(comp) {
}
DockingTask::~DockingTask() {
}

// the webots node must have coordinate system x=front, y=left, z=up.
// webots WorldInfo.coordinateSystem must be NUE. (todo: handle all coordinate systems correct)
Pose2D DockingTask::getNodePose(webots::Node *node) {
  const double *position = node->getPosition();
  const double *orientation = node->getOrientation();
  Pose2D pose = { position[0], -position[2], atan2(-orientation[6], orientation[0]) };
  return pose;
}

void DockingTask::handleEnterState(std::string substate) {
  if (substate == "laserDocking" || substate == "irDocking")
    newProgram = prDocking;
  else if (substate == "unDocking")
    newProgram = prUndocking;
  else if (substate == "neutral")
    newProgram = prNeutral;
}

//void DockingTask::sendEvent(CommNavigationObjects::DockingEventType event) {
void DockingTask::sendEvent(CommRobotinoObjects::RobotinoDockingEventType event) {
  std::cout << "XXX sendEvent " << event << std::endl;
  //CommNavigationObjects::CommDockingEventState eventState;
  CommRobotinoObjects::RobotinoDockingEventState eventState;
  eventState.setNewState(event);
  COMP->robotDockingEventServiceOut->put(eventState);
}

int DockingTask::on_entry() {
  std::string webotsRobotName =
  COMP->getParameters().getWebots().getRobotName();
  char environment[256] = "WEBOTS_ROBOT_NAME=";
  putenv(strcat(environment, webotsRobotName.c_str()));
  std::cout << " \033[0;32mConnect to webots robot with name '" << webotsRobotName << "' ...\033[0m" << std::endl;
  robot = new webots::Supervisor();
  if (!robot) {
    std::cerr << "in webots is no robot with name '" << webotsRobotName << "'" << std::endl;
    return 1;
  }
  return 0;
}

int DockingTask::on_execute() {
  Program oldProgram = prFirstRun;
  int programCounter;
  double blinkTime;
  bool blink;
  bool isError = false;
  Pose2D targetPose;
  while (robot->step(robot->getBasicTimeStep()) != -1) {
    Program program = newProgram;
    double t = robot->getTime();
    double vx = 0.0;
    double vy = 0.0;
    double omega = 0.0;
    if (program != oldProgram) {
      oldProgram = program;
      blinkTime = t;
      blink = false;
      programCounter = 0;
      if (program != prNeutral)
        isError = false;
    }
    // start of program
    if (programCounter == 0) {
      if (program == prNeutral)
        programCounter = 8;
      if (program == prDocking || program == prUndocking) {
        // robot should be right in front of correct station. which one?
        webots::Node *robotNode = robot->getSelf();
        const double *robotPosition = robotNode->getPosition();
        const double *robotOrientation = robotNode->getOrientation();
        double minDistance = COMP->getParameters().getWebots().getMaxDistanceToDockingPoint();
        webots::Node *bestDocking = NULL;
        webots::Node *bestStation;
        std::list<std::string> nameList =
        COMP->getParameters().getWebots().getStationName();
        std::cout << " minDistance " << minDistance;
        for (auto const &i : nameList) {
          webots::Node *station = robot->getFromDef(i);
          webots::Node *node = NULL;
          if (station != NULL)
            node = station->getFromProtoDef("DockingPoint");
          if (station == NULL || node == NULL) {
            std::cerr << "in webots is no ProductionStation with DEF '" << i << "' (and DEF DockingPoint inside proto)"
                << std::endl;
            if (program == prDocking) {
              //sendEvent(CommNavigationObjects::DockingEventType::DOCKING_ERROR);
              sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_ERROR);
            }
            else {
              //sendEvent(CommNavigationObjects::DockingEventType::UN_DOCKING_ERROR);
            	sendEvent(CommRobotinoObjects::RobotinoDockingEventType::UN_DOCKING_ERROR);
            }
           return 1; // stop thread
          }
          const double *position = node->getPosition();
          const double *orientation = node->getOrientation();
          double relativ[3];
          for (int i = 0; i < 3; i++)
            relativ[i] = position[i] - robotPosition[i];
          double dist = std::sqrt(relativ[0] * relativ[0] + relativ[1] * relativ[1] + relativ[2] * relativ[2]);
          if (dist < minDistance) {
            minDistance = dist;
            bestDocking = node;
            bestStation = station;
          }
        }
        std::cout << " bestDocking " << bestDocking;
        if (bestDocking == NULL) {
          isError = true;
          std::cout << "no station found within " << minDistance << "m" << std::endl;
          //sendEvent(CommNavigationObjects::DockingEventType::DOCKING_ERROR);
          sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_ERROR);
          program = prNeutral;
        } else {
          Pose2D poseDocking = getNodePose(bestDocking);
          Pose2D pose2 = getNodePose(bestStation);
          //                             poseDocking
          // station center point      docking point    undocking point
          //                |                  |                  |
          //                X------------------X------------------X
          //                0                  0.774              0.774*1.6
          pose2.x += (poseDocking.x - pose2.x) * 1.6;
          pose2.y += (poseDocking.y - pose2.y) * 1.6;
          // robot heading must be opposite direction to docking station heading
          pose2.heading += M_PI;
          poseDocking.heading = pose2.heading;
          if (program == prDocking) {
            targetPose = poseDocking;
            //sendEvent(CommNavigationObjects::DockingEventType::DOCKING_NOT_DONE);
            sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_NOT_DONE);
          } else {
            targetPose = pose2;
            //sendEvent(CommNavigationObjects::DockingEventType::UN_DOCKING_NOT_DONE);
            sendEvent(CommRobotinoObjects::RobotinoDockingEventType::UN_DOCKING_NOT_DONE);
          }
        }
        programCounter = 1;
      }
    }
    // main loop of program
    if (programCounter == 1) {
      Pose2D robotPose = getNodePose(robot->getSelf());
      // todo: put constants in webots proto
      //       proto for robot parameters and robot coordinate system
      const double radiansPerSecond = 1.2;
      omega = targetPose.heading - robotPose.heading + 4 * M_PI;
      while (omega > M_PI)
        omega -= 2 * M_PI;
      if (omega > radiansPerSecond)
        omega = radiansPerSecond;
      if (omega < -radiansPerSecond)
        omega = -radiansPerSecond;
      // if rotation can be corrected in one timestep, then start movement
      if (abs(omega) < radiansPerSecond * robot->getBasicTimeStep() / 1000) {
        const double metersPerSecond = 0.8;
        const double acceleration = 0.25;
        double dx = targetPose.x - robotPose.x;
        double dy = targetPose.y - robotPose.y;
        double distance = std::sqrt(dx * dx + dy * dy);
        // v = sqrt(2*a*x)
        double v = std::sqrt(2 * acceleration * distance);
        if (v > metersPerSecond)
          v = metersPerSecond;
        //std::cout << " distance " << distance;
        if (distance < 0.001)
          programCounter = 2; // do last rotation timestep
        else {
          // vector d = robot to target (length 1)
          dx = dx / distance;
          dy = dy / distance;
          // vector a = x-axis of robot (length 1)
          double ax = cos(robotPose.heading);
          double ay = sin(robotPose.heading);
          vx = v * (dx * ax + dy * ay);
          // vector a = y-axis of robot (length 1)
          ax = cos(robotPose.heading + M_PI / 2);
          ay = sin(robotPose.heading + M_PI / 2);
          vy = v * (dx * ax + dy * ay);
        }
      }
      if (t >= blinkTime) {
        blink = !blink;
        blinkTime = t + 0.5;
      }
    } else if (programCounter == 2)
      programCounter = 8;
    // end of program
    if (programCounter == 8) {
      if (program == prDocking) {
    	  std::cout << "********************************************" << std::endl;
        //sendEvent(CommNavigationObjects::DockingEventType::DOCKING_DONE);
    	sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_DONE);
      }
      if (program == prUndocking) {
        //sendEvent(CommNavigationObjects::DockingEventType::UN_DOCKING_DONE);
    	  sendEvent(CommRobotinoObjects::RobotinoDockingEventType::UN_DOCKING_DONE);
      }
      blink = false;
    }
    if (programCounter != 9) {
      CommBasicObjects::CommNavigationVelocity navigationVelocity;
      navigationVelocity.setVX(vx * 1000).setVY(vy * 1000).setOmega(omega);
      COMP->navigationVelocityServiceOut->send(navigationVelocity);
      CommBasicObjects::CommTrafficLights trafficLights;
      trafficLights.setYellow(blink).setRed(isError);
      COMP->trafficLightsServiceOut->put(trafficLights);
      //std::cout << "program " << program << " Counter " << programCounter << " targetPose=" << targetPose.x << " "
       //   << targetPose.y << " " << targetPose.heading << " vx=" << vx << " vy=" << vy << " omega=" << omega
        //  << " isError=" << isError << std::endl;
    }
    if (programCounter == 8)
      programCounter = 9;
  }
  delete robot;
  return 1; // ends this thread after webots world ends
}

int DockingTask::on_exit() {
  return 0;
}
