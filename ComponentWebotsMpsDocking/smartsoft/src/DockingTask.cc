//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------

#include "DockingTask.hh"
#include "ComponentWebotsMpsDocking.hh"
#include <webots/Keyboard.hpp>
#include <webots/Supervisor.hpp>

#include <iostream>

// from https://stackoverflow.com/questions/154536/encode-decode-urls-in-c
std::string url_encode(const std::string &value) {
    std::ostringstream escaped;
    escaped.fill('0');
    escaped << std::hex;
    for (std::string::const_iterator i = value.begin(), n = value.end(); i != n; ++i) {
        std::string::value_type c = (*i);
        // Keep alphanumeric and other accepted characters intact
        if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
            escaped << c;
            continue;
        }
        // Any other characters are percent-encoded
        escaped << std::uppercase;
        escaped << '%' << std::setw(2) << int((unsigned char) c);
        escaped << std::nouppercase;
    }
    return escaped.str();
}

DockingTask::DockingTask(SmartACE::SmartComponent *comp) :
    DockingTaskCore(comp) {
}
DockingTask::~DockingTask() {
}

// the webots node must have coordinate system x=front, y=left, z=up.
// webots WorldInfo.coordinateSystem must be ENU. (todo: handle all coordinate systems correct)
Pose2D getNodePose(webots::Node *node) {
  const double *position = node->getPosition();
  const double *orientation = node->getOrientation();
// NUE:
//  Pose2D pose = { position[0], -position[2], atan2(-orientation[6], orientation[0]) };
// ENU:
  Pose2D pose = { position[0], position[1], atan2(orientation[3], orientation[0]) };
  return pose;
}

void DockingTask::handleEnterState(std::string substate) {
  if (substate == "laserDocking" || substate == "irDocking")
    newProgram = prDocking;
  else if (substate == "unDocking")
    newProgram = prUndocking;
  else if (substate == "neutral")
    newProgram = prNeutral;
}

void DockingTask::sendEvent(CommRobotinoObjects::RobotinoDockingEventType event) {
  std::cout << "XXX sendEvent " << event << std::endl;
  CommRobotinoObjects::RobotinoDockingEventState eventState;
  eventState.setNewState(event);
  COMP->robotDockingEventServiceOut->put(eventState);
}

int DockingTask::on_entry() {
  return 0;
}

int DockingTask::on_execute() {
  std::string webotsRobotName =
  COMP->getParameters().getWebots().getRobotName();
  char environment[256] = "WEBOTS_CONTROLLER_URL=";
  putenv(strcat(environment, url_encode(webotsRobotName).c_str()));
  std::cout << " \033[0;32mConnect to webots robot with name '" << webotsRobotName << "' ...\033[0m" << std::endl;
  webots::Supervisor *robot = new webots::Supervisor();
  if (!robot) {
    std::cerr << "in webots is no robot with name '" << webotsRobotName << "'" << std::endl;
    return 1;
  }
  webots::Keyboard *keyboard = robot->getKeyboard();
  keyboard->enable(robot->getBasicTimeStep());
  Program oldProgram = prFirstRun;
  int programCounter;
  double blinkTime;
  bool blink;
  bool isError = false;
  Pose2D targetPose;
  webots::Node* node = robot->getFromDef("Stations");
  if(!node) {
      std::cerr << "ERROR: no DEF Stations Group found" << std::endl;
      return 1;
  }
  webots::Field* stations = node->getField("children");
  if(!stations || node->getTypeName()!="Group") {
      std::cerr << "ERROR LINE" << __LINE__ << std::endl;
      return 1;
  }

  while (robot->step(robot->getBasicTimeStep()) != -1) {
    int key=keyboard->getKey();
    if(key=='-' || key==7) // Editor may delete Station
        continue;
    Program program = newProgram;
    double t = robot->getTime();
    double vx = 0.0;
    double vy = 0.0;
    double omega = 0.0;
    if (program != oldProgram) {
      oldProgram = program;
      blinkTime = t;
      blink = false;
      programCounter = 0;
      if (program != prNeutral)
        isError = false;
    }
    // start of program
    if (programCounter == 0) {
      if (program == prNeutral)
        programCounter = 8;
      if (program == prDocking || program == prUndocking) {
        // robot should be right in front of correct station. which one?
        webots::Node *robotNode = robot->getSelf();
        const double *robotPosition = robotNode->getPosition();
        const double *robotOrientation = robotNode->getOrientation();
        double minDistance = COMP->getParameters().getWebots().getMaxDistanceToDockingPoint();
        webots::Node *bestDocking = NULL;
        webots::Node *bestStation;

/*      user has to stop simulation himself during editing, at least if he deletes something
        // if user deletes a station, a supervisor function call to read stations could crash
        // => don't do it if Editor or something inside is selected
        webots::Node *selected = robot->getSelected();
        while (selected != NULL && selected != editor)
            selected = selected->getParentNode();
        if (selected)
            continue;
*/
        std::cout << "   ***\n   ***\nminDistance " << minDistance << " Calculating Nearest station" << std::endl;
        for(int i=stations->getCount(); i--;) {
          webots::Node *station = stations->getMFNode(i);
          webots::Field* locations = station->getField("Locations");

          if(!locations || !locations->getCount()) {
              std::cerr << (i+1) << ". children in Stations is wrong (has no or empty Locations field)" << station->getTypeName() << std::endl;
              if (program == prDocking) {
                sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_ERROR);
              }
              else {
                  sendEvent(CommRobotinoObjects::RobotinoDockingEventType::UN_DOCKING_ERROR);
              }
             return 1; // stop thread
          }
          webots::Node *node = locations->getMFNode(0);
          const double *position = node->getPosition();
          const double *orientation = node->getOrientation();
          double relativ[3];
          for (int i = 0; i < 3; i++)
            relativ[i] = position[i] - robotPosition[i];
          double dist = std::sqrt(relativ[0] * relativ[0] + relativ[1] * relativ[1] + relativ[2] * relativ[2]);
          if (dist < minDistance) {
            minDistance = dist;
            bestDocking = node;
            bestStation = station;
          }
        }
        std::cout << " bestDocking " << bestDocking;
        if (bestDocking == NULL) {
          isError = true;
          std::cout << "no station found within " << minDistance << "m" << std::endl;
          sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_ERROR);
          program = prNeutral;
        } else {
          Pose2D undockingPose = getNodePose(bestDocking);
          Pose2D stationPose = getNodePose(bestStation);
          // how docking is done: (undocking is reverse)
          // 1) mobile robot drives near to a point in front of station (half a meter space to station, called 'undocking point') by other components/behavior
          // 2) state is changed to laserDocking or irDocking (prDocking)
          // 3) drive exactly to a point in front of station (a view millimeters space to station, called 'docking point') by this component
          // (docking drives from actual mobile robot position to docking point. undocking drives to undocking point)
          // station center point and docking point are directly read from webots
          // the undocking point is calculated based on them:

          //          stationPose        dockingPose         undockingPose
          //                |                  |                  |
          //                +------------------+------------------+
          //                0m                 0.775m             1.24m   distance to station center point

          // todo: add docking pose as Location in Station
          Pose2D dockingPose;
          dockingPose.x = stationPose.x + cos(stationPose.heading) * 0.775;
          dockingPose.y = stationPose.y + sin(stationPose.heading) * 0.775;
          dockingPose.heading = stationPose.heading + M_PI;
          if (program == prDocking) {
            targetPose = dockingPose;
            sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_NOT_DONE);
          } else {
            targetPose = undockingPose;
            sendEvent(CommRobotinoObjects::RobotinoDockingEventType::UN_DOCKING_NOT_DONE);
          }
          std::cout << "center point of station:" << stationPose.x << " y:" << stationPose.y << " heading:" << stationPose.heading << std::endl;
          std::cout << "point half a meter in front of station x:" << undockingPose.x << " y:" << undockingPose.y << " heading:" << undockingPose.heading << std::endl;
          std::cout << "point directly in front of station x:" << dockingPose.x << " y:" << dockingPose.y << " heading:" << dockingPose.heading << std::endl;
        }
        programCounter = 1;
      }
    }
    // main loop of program
    if (programCounter == 1) {
      Pose2D robotPose = getNodePose(robot->getSelf());
      // todo: put constants in webots proto
      //       proto for robot parameters and robot coordinate system
      const double radiansPerSecond = 1.2;
      omega = targetPose.heading - robotPose.heading + 4 * M_PI;
      while (omega > M_PI)
        omega -= 2 * M_PI;
      if (omega > radiansPerSecond)
        omega = radiansPerSecond;
      if (omega < -radiansPerSecond)
        omega = -radiansPerSecond;
      // if rotation can be corrected in one timestep, then start movement
      if (abs(omega) < radiansPerSecond * robot->getBasicTimeStep() / 1000) {
        const double metersPerSecond = 0.8;
        const double acceleration = 0.25;
        double dx = targetPose.x - robotPose.x;
        double dy = targetPose.y - robotPose.y;
        // std::cout << "target pose [" << targetPose.x << ", " << targetPose.y  <<", "<< targetPose.heading << "]"
        //		  << "Robot pose  [" << robotPose.x  << ", " << robotPose.y  <<", "<<  robotPose.heading << "]"<<std::endl;
        double distance = std::sqrt(dx * dx + dy * dy);
        // v = sqrt(2*a*x)
        double v = std::sqrt(2 * acceleration * distance);
        if (v > metersPerSecond)
          v = metersPerSecond;
        //std::cout << " distance " << distance;
        if (distance < 0.001)
          programCounter = 2; // do last rotation timestep
        else {
          // vector d = robot to target (length 1)
          dx = dx / distance;
          dy = dy / distance;

          // vector a = x-axis of robot (length 1)
          double ax = cos(robotPose.heading);
          double ay = sin(robotPose.heading);
          vx = v * (dx * ax + dy * ay);
          // vector a = y-axis of robot (length 1)
          ax = cos(robotPose.heading + M_PI / 2);
          ay = sin(robotPose.heading + M_PI / 2);
          vy = v * (dx * ax + dy * ay);
        }
      }
      if (t >= blinkTime) {
        blink = !blink;
        blinkTime = t + 0.5;
      }
    } else if (programCounter == 2)
      programCounter = 8;
    // end of program
    if (programCounter == 8) {
      if (program == prDocking) {
    	  std::cout << "********************************************" << std::endl;
    	sendEvent(CommRobotinoObjects::RobotinoDockingEventType::LASER_DOCKING_DONE);
      }
      if (program == prUndocking) {
    	  sendEvent(CommRobotinoObjects::RobotinoDockingEventType::UN_DOCKING_DONE);
      }
      blink = false;
    }
    if (programCounter != 9) {
      CommBasicObjects::CommNavigationVelocity navigationVelocity;
      navigationVelocity.setVX(vx * 1000).setVY(vy * 1000).setOmega(omega);
      COMP->navigationVelocityServiceOut->send(navigationVelocity);
      CommBasicObjects::CommTrafficLights trafficLights;
      trafficLights.setYellow(blink).setRed(isError);
      COMP->trafficLightsServiceOut->put(trafficLights);
      std::cout << "program " << program << " Counter " << programCounter << " targetPose=" << targetPose.x << " "
                << targetPose.y << " " << targetPose.heading << " vx=" << vx << " vy=" << vy << " omega=" << omega
                << " isError=" << isError << std::endl;
    }
    if (programCounter == 8)
      programCounter = 9;
  }
  delete robot;
  return 1; // ends this thread after webots world ends
}

int DockingTask::on_exit() {
  return 0;
}
