//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2009-2017 Andreas Steck, Matthias Lutz
//                     2021 Nayabrasul Shaik
//
//        lutz@hs-ulm.de
//        shaik@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#ifndef _TRACKINGTHREAD_HH
#define _TRACKINGTHREAD_HH

#include "TrackingThreadCore.hh"

#include "DomainVision/CommRGBDImage.hh"
#include "CommTrackingObjects/enumPersonLostEventType.hh"
#include "CommTrackingObjects/enumTrackingGoalType.hh"
#include <mrpt/poses/CPoint.h>
#include "SmartSoft2RealSenseSdkConverter.hh"
#include  "TrackingVisualization.hh"

#include <librealsense/rs.hpp>
#include "3rdParty/include/librealsense/pt/person_tracking_video_module_factory.h"
#include "3rdParty/include/librealsense/pt/person_tracking_video_module_interface.h"
#include "3rdParty/include/librealsense/pt/RealSense/PersonTracking/PersonTrackingConfiguration.h"
#include "3rdParty/include/librealsense/pt/RealSense/PersonTracking/PersonTrackingModule.h"
#include "3rdParty/include/librealsense/pt/RealSense/PersonTracking/PersonTrackingData.h"

#include <opencv2/opencv.hpp>
#include <opencv2/highgui.hpp>
#include <iostream>
#include <limits>
#include <memory>
#include <chrono>

#ifndef PERSON_TRACKING_DATA_FILES
#define PERSON_TRACKING_DATA_FILES "/usr/share/librealsense/pt/data/"
#endif

using namespace rs::person_tracking;
using namespace Intel::RealSense::PersonTracking;


class TrackingThread  : public TrackingThreadCore
{
private:
	  Smart::StatusCode status;
	  DomainVision::CommRGBDImage scan;
	  long int goalCounter;

	  //rs::person_tracking::person_tracking_video_module_interface* ptModule;
	  Intel::RealSense::PersonTracking::PersonTrackingData *realsense_pt_data;
	  rs::core::video_module_interface::actual_module_config actualModuleConfig;
	  rs::core::correlated_sample_set sample_set;
	  rs::core::image_info m_colorInfo;
	  rs::core::image_info m_depthInfo;
	  rs::core::extrinsics d2c_extrinsics;
	  rs::core::intrinsics m_colorInt;
	  rs::core::intrinsics m_depthInt;
	  std::unique_ptr<SmartSoft2RealSenseSdkConverter> m_smartsoft2realsense;
	  TrackingVisualization mVisualization;
	  cv::Mat m_imageColor;
	  cv::Mat m_imageDepth;

	  bool first_image_flag;                  /**< use this flag to initialize intrinsic and extrinsic parameters after receiving first image from server    */
	  int m_frame_number;                     /**< Local frame number zero for the first frame received by tracker 											 */
    short int number_of_no_persons_frames;  /**< Counter to set goal (0,0) if person is not found in frame for long time 									 */

	  double person_x;
	  double person_y;

	  bool personFound;
	  int noPersonCount;

	  SmartACE::SmartMutex goalCounterLock;
	  std::chrono::steady_clock::time_point last_run;
public:
	TrackingThread(SmartACE::SmartComponent *comp);
	virtual ~TrackingThread();
	
	virtual int on_entry();
	virtual int on_execute();
	virtual int on_exit();

	void resetGoalCounter();

	void release_images();
	void init_person_tracking();
	void DisplayTrackingResult(Intel::RealSense::PersonTracking::PersonTrackingData &mtrackingData, cv::Mat &rgb, cv::Mat &depth, std::string str_framenum, CommBasicObjects::CommPose3d &sensor_pose);
	void SendGoal(Intel::RealSense::PersonTracking::PersonTrackingData &mtrackingData);
	mrpt::poses::CPoint3D transormPointToRobotCoord(const mrpt::poses::CPoint3D & point, CommBasicObjects::CommPose3d& sensor_pose);
	bool startStopTracking(bool isStart, int personId);
	void SendEventPersonFoundLost(CommTrackingObjects::PersonLostEventType current_event);
	void SendTrackingGoalToServer(double _angle, double _distance, double _x, double _y, bool _valid, CommTrackingObjects::TrackingGoalType _type);
	const wchar_t *GetWC(const char *c);
	void publish_rgb_image (cv::Mat &rgb);

};

#endif
