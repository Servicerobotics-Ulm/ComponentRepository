//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------


#include "WebotsTask.hh"
#include "ComponentWebotsConveyorBeltOpcua.hh"
#include <iostream>

using namespace std;
using namespace webots;
using namespace OPCUA;
using namespace CommRobotinoObjects;

WebotsTask::WebotsTask(SmartACE::SmartComponent *comp) :
    WebotsTaskCore(comp) {
}
WebotsTask::~WebotsTask() {
}

int WebotsTask::on_entry() {
  return 0;
}

void WebotsTask::sendEvent(RobotinoConveyerBeltEventType t) {
  std::cout << "XXX sendEvent " << t << std::endl;
  RobotinoConveyerBeltEventState goalEventState;
  goalEventState.set(t);
  COMP->robotinoConveyerBeltEventOut->put(goalEventState);
}


/*
stationName : String [*] = ["MPS0", "MPS1", "MPS2", "MPS3"];
stationUrl : String [*] = ["opc.tcp://localhost:4840", "opc.tcp://localhost:4841", "opc.tcp://localhost:4842", "PASSIVE_STATION"];
*/

int WebotsTask::on_execute() {
  ProductionStation station;
  ParameterStateStruct params = COMP->getParameters();
  int timeOut = params.getRobot().getBelt_time_out_sec();

  // webots variables
  string robotName = params.getWebots().getRobotName();
  char environment[256] = "WEBOTS_ROBOT_NAME=";
  putenv(strcat(environment, robotName.c_str()));
  std::cout << "\033[0;32mConnect to webots robot with name '" << robotName << "' ...\033[0m" << std::endl;
  Supervisor *robot = new Supervisor();
  if (!robot) {
    cerr << "Webots robot '" << robotName << "' not found" << endl;
    return -1;
  }
  webots::Node* node = robot->getFromDef("Stations");
  if(!node) {
      std::cerr << "ERROR: no DEF Stations Group found" << std::endl;
      return 1;
  }
  webots::Field* stations = node->getField("children");
  if(!stations || node->getTypeName()!="Group") {
      std::cerr << "ERROR LINE" << __LINE__ << std::endl;
      return 1;
  }

  Motor *motor = robot->getMotor("Belt_Motor");
  motor->setPosition(INFINITY);
  LED *greenLED = robot->getLED("green_led");
  LED *yellowLED = robot->getLED("orange_led");
  LED *redLED = robot->getLED("red_led");
  Keyboard *keyboard = robot->getKeyboard();
  keyboard->enable(robot->getBasicTimeStep());
  DistanceSensor *dsBoxPresent = robot->getDistanceSensor("isBoxPresent");
  dsBoxPresent->enable(robot->getBasicTimeStep());

  // other variables
  Program oldProgram;
  int programCounter;
  double waitTime, errorTime, blinkTime;
  bool isRed;
  bool isError;
  bool firstRun = true;
  bool isPassiveStation;
  int _counter = 0;
  while (robot->step(robot->getBasicTimeStep()) != -1) {
    int key=keyboard->getKey();
    if(key=='-' || key==7) // Editor may delete Station
      continue;
    bool isBoxPresent = dsBoxPresent->getValue() > 0.3;

    Program program = newProgram;
    //if (_counter % 10 == 0)
     // std::cout << "program:" << program << " pc:" << programCounter << " box:" << dsBoxPresent->getValue() << " err:"
       //   << isError << " errT:" << errorTime << " waitT:" << waitTime << std::endl;
    double t = robot->getTime();
    if (firstRun || program != oldProgram) {
      firstRun = false;
      oldProgram = program;
      motor->setVelocity(0.0);
      waitTime = -1.0;
      errorTime = -1.0;
      blinkTime = t;
      isRed = false;
      programCounter = 0;
      isError = program == prSignalError;
    }
    bool isLoad = (program == prLoad) || (program == prManualLoad);
    bool isUnload = (program == prUnload) || (program == prManualUnload);
    bool isManual = (program == prManualLoad) || (program == prManualUnload);
    bool isAutomatic = (program == prLoad) || (program == prUnload);
    // green LED: box is detected
    greenLED->set(isBoxPresent);
    // yellowLED: warning, belt motor is turned on (program Load or Unload)
    yellowLED->set(program == prLoad || program == prUnload);
    // red LED: flashing = SignalError, constant = ManualLoad/ManualUnload,
    //          (in both cases wait for enter key or new state)
    redLED->set(isRed);
    if (program == prNeutral) {
      CommBasicObjects::CommTrafficLights trafficLights;
      COMP->trafficLightsServiceIn->getUpdate(trafficLights);
      yellowLED->set(trafficLights.getYellow());
      redLED->set(trafficLights.getRed());
      continue;
    }
    // wait until Behavior has reacted to an error:
    // error handling: sendEvent(...ERROR...); isError=true; continue;
    // Behavior will read the Error Event and change the State to SignalError, in handleEnterExitState newProgram=SignalError,
    // pressing enter key will sendEvent(ENUM_VALUE_UNDEFINED), Behavior should change to neutral State and clear the isError flag
    if (isError) {
      motor->setVelocity(0.0);
      continue;
    }
    if (errorTime > 0 && t > errorTime) {
      if (isAutomatic)
        station.disconnect();
      sendEvent(
          program == prLoad ?
              RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_BOX_LOADED :
              RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_ERROR_NO_BOX);
      isError = true;
      continue;
    }
    // start of program
    if (programCounter == 0) {
      if (isLoad) {
        if (isBoxPresent) {
          sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_BOX_ADREADY_PRSESENT);
          isError = true;
          continue;
        }
        sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_NOT_DONE);
      }
      if (isUnload) {
        if (!isBoxPresent) {
          sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_ERROR_NO_BOX);
          isError = true;
          continue;
        }
        sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_NOT_DONE);
      }
      if (isAutomatic) {
        int stationId = getStationId();

        Node *stationNode;
        int stationNr = stations->getCount();
        while(stationNr--) {
          stationNode = stations->getMFNode(stationNr);
          webots::Field *idField = stationNode->getField("name");
          if(idField==NULL) {
            std::cerr << (stationNr+1) << ". children in Editor Stations is wrong (has no name field)"
                << std::endl;
          } else if(idField->getSFString() == to_string(stationId))
              break;
        }
        string nameVector = "";
        string urlVector = "";
        if (stationNr<0) {
          isError = true;
        } else {
          nameVector = "Station" + to_string(stationId);
          Field *portField = stationNode->getField("port");
          if(portField!=NULL)
             urlVector = "opc.tcp://localhost:" + to_string(portField->getSFInt32());
          else
             urlVector = "PASSIVE_STATION";
          isPassiveStation = urlVector == "PASSIVE_STATION";
          if (isLoad && isPassiveStation)
            isError = true;
        }
        if (isError) {
          cerr << "ERROR invalid station id: " << stationId << " (too small or too big or PASSIVE_STATION)" << endl;
          sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_UNKNOWN);
          continue;
        }
        if (isPassiveStation)
          waitTime = t + params.getRobot().getIgnore_station_communication_unload_time_sec();
        else {
          string callResult;
          if (station.connect(urlVector, nameVector) != OPCUA::StatusCode::ALL_OK)
            isError = true;
          else if (isLoad) {
            if (station.callStart_unloading(timeOut, callResult) != OPCUA::StatusCode::ALL_OK
            /* || callResult != "UNLOADING_STARTED"*/) {
              station.callStop_unloading(1, callResult);
              isError = true;
            }
          } else if (isUnload) {
            if (station.callLoadbox(timeOut, callResult) != OPCUA::StatusCode::ALL_OK)
              isError = true;
          }
          if (isError) {
            sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_ERROR_NO_RESPONSE_FROM_STATION);
            station.disconnect();
            continue;
          }
        }
        motor->setVelocity(isLoad ? 0.3 : -0.3);
        errorTime = t + timeOut;
      }
      programCounter = 1;
    }
    // main loop of program
    if (programCounter == 1) {
      if (program == prLoad && isBoxPresent)
        programCounter = 3;
      if (program == prUnload && isPassiveStation && t > waitTime)
        programCounter = 3;
      if (program == prUnload && !isPassiveStation && station.getIsBoxPresent())
        programCounter = 3;
      if (isManual)
        isRed = true;
      if (program == prSignalError && t > blinkTime) {
        isRed = !isRed;
        blinkTime = t + 0.5;
      }
      if ((isManual || program == prSignalError) && (key == 4 || key == 5)) // 4 = return key, 5 = enter key
        programCounter = 3;
    }
    // end of program
    if (programCounter == 3) {
      string callResult;
      errorTime = 0.0;
      motor->setVelocity(0.0);
      if (isManual)
        isRed = false;
      if (program == prLoad)
        station.callStop_unloading(1, callResult);
      if (isAutomatic)
        station.disconnect();
      if (isLoad)
        sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_LOAD_DONE);
      if (isUnload)
        sendEvent(RobotinoConveyerBeltEventType::CONVEYER_BELT_UNLOAD_DONE);
      if (program == prSignalError)
        sendEvent(RobotinoConveyerBeltEventType::ENUM_VALUE_UNDEFINED);
      programCounter = 4;
    }
  }
  cout << "Webots world has ended, task stopped." << endl;
  delete robot;
  return 1; // ends this thread after webots world ends
}

int WebotsTask::on_exit() {
  return 0;
}

int WebotsTask::getStationId() {
  return COMP->getParameters().getCommRobotinoObjects().getRobotinoConveyerParameter().getSetStationID().getId();
}

// called from SmartStateChangeHandler
void WebotsTask::handleEnterState(string substate) {
  std::cout << "handleEnterState " << substate << std::endl;
  int nr = -1;
  for (int i = 0; i < programSubstate.size(); i++)
    if (substate == programSubstate[i])
      nr = i + 1;
  if(nr != -1)
    newProgram = Program(nr);
}

/*
 int DockingTask::on_execute() {
 CommBasicObjects::CommMobileLaserScan laserScan;
 CommBasicObjects::CommBaseState baseState;
 CommBasicObjects::CommNavigationVelocity navigationVelocity;
 CommRobotinoPowerOutputValue powerOutput;
 CommBasicObjects::CommTrafficLights trafficLights;
 CommBasicObjects::CommMobileIRScan mobileIRScan;
 CommBasicObjects::CommIRScan irScan;
 while (webotsRobot->step(webotsTimeStep) != -1) {
 COMP->baseStateServiceIn->getUpdate(baseState);
 COMP->laserServiceIn->getUpdate(laserScan);
 irScan.setTimeStamp(CommBasicObjects::CommTimeStamp::now());
 vector<double> distances = { webotsSensorIsBoxPresent->getValue() };
 irScan.setDistances(distances);
 mobileIRScan.setBaseState(baseState).setIrScan(irScan).setIs_valid(true);
 COMP->mobileIRPushOut->put(mobileIRScan);
 navigationVelocity.setVX(0.0).setVX(0.0).setOmega(0.0);
 COMP->navigationVelocityServiceOut->send(navigationVelocity);
 }
 cout << "Webots world has ended, task stopped." << endl;
 COMP->stateSlave->setWaitState("FatalError");
 return 1; // ends this thread after webots world ends
 }
 */
