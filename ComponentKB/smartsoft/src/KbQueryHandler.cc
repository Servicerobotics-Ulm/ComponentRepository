//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "KbQueryHandler.hh"
#include "ComponentKB.hh"

KbQueryHandler::KbQueryHandler(Smart::IQueryServerPattern<CommBasicObjects::CommKBRequest, CommBasicObjects::CommKBResponse>* server)
:	KbQueryHandlerCore(server),
	lock(),
	sema(0)
{
	
}

KbQueryHandler::~KbQueryHandler()
{
	std::cout<<"KBQueryHandler desctructor"<<std::endl;
}


void KbQueryHandler::handleQuery(const Smart::QueryIdPtr &id, const CommBasicObjects::CommKBRequest& request) 
{
	CommBasicObjects::CommKBResponse answer;
	
	ACE_Time_Value start = ACE_OS::gettimeofday();
//	std::cout<<"Enter Handler: "<<start<<std::endl;
	long int_id = *std::dynamic_pointer_cast<Smart::NumericCorrelationId>(id);
	lock.acquire();
	internal_KB_query req_item;
	req_item.msg = request;
	req_item.id = int_id;
	req_item.requires_answ = true;
	req_item.cond = new SmartACE::SmartConditionMutex(lock);
	this->request_list.push_back(req_item);
	sema.release();

	req_item.cond->wait();

	delete req_item.cond;
	ACE_Time_Value past_wait = ACE_OS::gettimeofday();
//	std::cout<<"past wait: "<<past_wait-start<<std::endl;

   	this->server->answer(id, this->ans_list[int_id].answ);
   	this->ans_list.erase(int_id);
	lock.release();
	ACE_Time_Value end = ACE_OS::gettimeofday();
//	std::cout<<"Quit Handler: "<<end<<std::endl;
	std::cout<<"KB Query took overall: "<<end-start<<std::endl;
	
}

void KbQueryHandler::insertChainedQueryFromComponent(std::string request){
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	lock.acquire();
	internal_KB_query req_item;
	CommBasicObjects::CommKBRequest tmp_msg;
	tmp_msg.setRequest(request);
	req_item.msg = tmp_msg;
	req_item.id = -1;
	req_item.requires_answ = false;
	req_item.cond = 0;
	this->request_list.push_back(req_item);
	sema.release();
	lock.release();
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
}

void KbQueryHandler::insertCompShutdownQuery(){
	lock.acquire();
	internal_KB_query req_item;
	CommBasicObjects::CommKBRequest tmp_msg;
	tmp_msg.setRequest("Shutdown");
	req_item.msg = tmp_msg;
	req_item.id = -99;
	req_item.requires_answ = false;
	req_item.cond = 0;
	this->request_list.push_back(req_item);
	std::cout<<"insertCompShutdownQuery"<<std::endl;
	sema.release();
	lock.release();
}


int KbQueryHandler::getQuery(CommBasicObjects::CommKBRequest &request, long &req_id){
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	int res = sema.acquire();
	if(res < 0){
		// during the shutdown of the component, induced by a system signal, the semaphore can be released with an error value
		// in this case the msg queue is still empty and should not be read.
		// Shutdown the component in this case!
		std::cout<<"getQuery sema.acquire_done res: "<<res<<" errno: "<< ACE_OS::last_error()<<" - "<<ACE_OS::gettimeofday()<<std::endl;
		ACE_ERROR ((LM_ERROR, ACE_TEXT ("%p\n"), ACE_TEXT ("log")));
		return -1;
	}
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	lock.acquire();
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	internal_KB_query cur_req = request_list.front();
	request_list.pop_front();

	request = cur_req.msg;
	req_id = cur_req.id;

	ans_list[cur_req.id].requires_answ = cur_req.requires_answ;
	ans_list[cur_req.id].cond = cur_req.cond;

	if(cur_req.id == -99){
		std::cout<<"getQuery - shutdown case!"<<ACE_OS::gettimeofday()<<std::endl;
		res = -1;
	}

	lock.release();
	return res;
}

void KbQueryHandler::answerQuery(const CommBasicObjects::CommKBResponse &answer, const long& id){
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	lock.acquire();
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	if(ans_list[id].requires_answ == true) {
		ans_list[id].answ = answer;
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
		ans_list[id].cond->signal();
	}
//	std::cout<<__FUNCTION__<<":"<<__LINE__<<std::endl;
	lock.release();
}

