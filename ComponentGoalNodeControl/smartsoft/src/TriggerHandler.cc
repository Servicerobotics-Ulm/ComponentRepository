//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2021 Timo Blender
//
//
//        timo.blender@thu.de
//        christian.schlegel@thu.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "TriggerHandler.hh"

#include "ComponentGoalNodeControl.hh"

#include <DomainRobotFleetNavigation/CommCorridorPath.hh>

// trigger user methods
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_ACQ_INIT_NODE(const unsigned int &node)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	std::cout << "Initial Acquire of Node: " << node << std::endl;

	DomainRobotFleetNavigation::CommNodeStatusUpdateRequest statReq;
	DomainRobotFleetNavigation::CommNodeStatusUpdateAnswer statAnsw;

	statReq.setId(node);
	statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::ACQUIRENODE);

	COMP->nodeStatusUpdateServiceReq->query(statReq, statAnsw);
}
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_ACQ_INIT_POSE(const unsigned int &pose)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// This is currently used to set the goalid
	COMP->id = pose;
}
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_REL_ALL_NODES()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_REL_ALL_NODES_BUT(const unsigned int &pose)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::cout << "Release Node: " << pose << std::endl;

	DomainRobotFleetNavigation::CommNodeStatusUpdateRequest statReq;
	DomainRobotFleetNavigation::CommNodeStatusUpdateAnswer statAnsw;

	statReq.setId(pose);
	statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::FREENODE);

	COMP->nodeStatusUpdateServiceReq->query(statReq, statAnsw);
}
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_REL_POSE(const unsigned int &pose)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_SET_GOAL(const unsigned int &startPose, const unsigned int &goalPose)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.

	DomainRobotFleetNavigation::CommShortestPathRequest request;
	//DomainRobotFleetNavigation::CommShortestPathAnswer answer;
	//DomainRobotFleetNavigation::CommNavPath answer;
	DomainRobotFleetNavigation::CommCorridorPath answer;

	request.setFrom(startPose);
	request.setTo(goalPose);

	COMP->shortestPathRequestServiceReq->query(request, answer);

	std::cout << "TIMO answer: " << answer << std::endl;

	CommNavigationObjects::CommCorridorNavigationGoal goal;
	CommNavigationObjects::CommNavigationPaths paths;

	std::vector<CommNavigationObjects::CommCorridorNode> cnodes;
	std::vector<double> widths;

	SmartACE::SmartGuard guard(COMP->mutex);

	for (int i = 0; i < answer.getNodesSize(); i++) {
		CommNavigationObjects::CommCorridorNode cnode;
		cnode.setX(answer.getNodesElemAtPos(i).getX());
		cnode.setY(answer.getNodesElemAtPos(i).getY());
		cnodes.push_back(cnode);
		COMP->path.push_back(answer.getNodesElemAtPos(i));
	}

	paths.setNodes(cnodes);
	paths.setPathWidth(answer.getWidthsCopy());

	//goal.setStartX(cnodes[0].getX());
	//goal.setStartY(cnodes[0].getY());

//	goal.setGoalX(cnodes[cnodes.size()-1].getX());
//	goal.setGoalY(cnodes[cnodes.size()-1].getY());

	//goal.setGoalX(cnodes[1].getX());
	//goal.setGoalY(cnodes[1].getY());

	goal.setPaths(paths);

	COMP->commCorridorNavigationGoal = goal;



	COMP->id++;
	guard.release();
}
void TriggerHandler::handleCommNavigationObjects_CorridorNavigationClientParams_SET_GOAL_FROM_NODE(const unsigned int &startNode, const unsigned int &goalPose)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
}
