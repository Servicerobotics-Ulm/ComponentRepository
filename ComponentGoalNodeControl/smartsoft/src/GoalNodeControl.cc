//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
// --------------------------------------------------------------------------
//
//  Copyright (C) 2021 Timo Blender
//
//
//        timo.blender@thu.de
//        christian.schlegel@thu.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------
#include "GoalNodeControl.hh"
#include "ComponentGoalNodeControl.hh"

#include <iostream>

GoalNodeControl::GoalNodeControl(SmartACE::SmartComponent *comp) 
:	GoalNodeControlCore(comp)
{
	std::cout << "constructor GoalNodeControl\n";
}
GoalNodeControl::~GoalNodeControl() 
{
	std::cout << "destructor GoalNodeControl\n";
}



int GoalNodeControl::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further

	COMP->id = 0;
	this->previd = -1;
	this->next = false;
	this->success = false;
	this->nextPathStart = true;
	this->checkForPrevNodeRelease = false;

	return 0;
}
int GoalNodeControl::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel
	
	// to get the incoming data, use this methods:
	Smart::StatusCode status;

	SmartACE::SmartGuard guard(COMP->mutex);

	if (COMP->path.size() > 0) {

		COMP->baseStateServiceIn->getUpdate(this->state);

		double cx = COMP->path.front().getX() * 1000.0;	// m -> mm
		double cy = COMP->path.front().getY() * 1000.0;	// m -> mm

//		std::cout << "cx: " << cx << std::endl;
//		std::cout << "cy: " << cy << std::endl;
//
//		std::cout << "rx: " << state.getBasePose().get_x() << std::endl;
//		std::cout << "ry: " << state.getBasePose().get_y() << std::endl;

		/*if (this->nextPathStart) {
			//std::cout << "PUT CORRIDOR: " << COMP->commCorridorNavigationGoal << std::endl;
			if (COMP->commCorridorNavigationGoal.getPaths().getNodesSize() == 1) {
				COMP->commCorridorNavigationGoal.setStartX(COMP->path.front().getX());
				COMP->commCorridorNavigationGoal.setStartY(COMP->path.front().getY());
				COMP->commCorridorNavigationGoal.setGoalX(COMP->path.front().getX());
				COMP->commCorridorNavigationGoal.setGoalY(COMP->path.front().getY());

				std::cout << "PUT 0 (== 1): " << COMP->path.front().getId() << " -> " << COMP->path.front().getId() << std::endl;

			}
			else {
				COMP->commCorridorNavigationGoal.setStartX(COMP->path.front().getX());
				COMP->commCorridorNavigationGoal.setStartY(COMP->path.front().getY());
				COMP->commCorridorNavigationGoal.setGoalX(COMP->path[1].getX());
				COMP->commCorridorNavigationGoal.setGoalY(COMP->path[1].getY());

				std::cout << "PUT 0 (> 1): " << COMP->path.front().getId() << " -> " << COMP->path[1].getId() << std::endl;
			}

			COMP->corridorNavigationNextGoalOut->put(COMP->commCorridorNavigationGoal);


		}*/

		if (this->nextPathStart && COMP->path.size() == 1) {
			// goal is the current location of the robot
			this->goal.setXGoalPoint(COMP->path.front().getX() * 1000.0); // m -> mm
			this->goal.setYGoalPoint(COMP->path.front().getY() * 1000.0); // m -> mm
			this->goal.setXWayPoint(COMP->path.front().getX() * 1000.0); // m -> mm
			this->goal.setYWayPoint(COMP->path.front().getY() * 1000.0); // m -> mm
			this->goal.setId(COMP->id);
			this->goal.setFlag(0);

			COMP->plannerGoalServiceOut->put(this->goal);



			COMP->commCorridorNavigationGoal.setStartX(COMP->path.front().getX());
			COMP->commCorridorNavigationGoal.setStartY(COMP->path.front().getY());

			COMP->commCorridorNavigationGoal.setGoalX(COMP->path.front().getX());
			COMP->commCorridorNavigationGoal.setGoalY(COMP->path.front().getY());

			COMP->corridorNavigationNextGoalOut->put(COMP->commCorridorNavigationGoal);

		}

		else {

			if (sld(cx, cy, state.getBasePose().get_x(), state.getBasePose().get_y()) < 100 || this->nextPathStart) { // 100 mm
				// current goal node reached
				//if (COMP->getParameters().getGoalNodeControl().getFreeStrategy() == ParameterStateStructCore::GoalNodeControlType::freeStrategyType::CURRENT) {
				//	this->statReq.setId(COMP->path.front().getId());
					//if (COMP->path.size() > 1) {
						// do not free the last (final goal node) when reached with freestrategy current
						// this is the case when we are here and COMP->path.size() == 1
					//	this->statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::FREENODE);
					//	COMP->nodeStatusUpdateServiceReq->query(this->statReq, this->statAnsw);
					//}
				//}
				//else if (COMP->getParameters().getGoalNodeControl().getFreeStrategy() == ParameterStateStructCore::GoalNodeControlType::freeStrategyType::PREVIOUS) {
				//	this->statReq.setId(this->previd);
				//	this->previd = COMP->path.front().getId();
				//	this->statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::FREENODE);
				//	COMP->nodeStatusUpdateServiceReq->query(this->statReq, this->statAnsw);
				//}

				this->prevNode = COMP->path.front();

				COMP->path.pop_front();

				std::cout << " GOAL REACHED (< 100) !" << std::endl;

				this->next = true;
				this->success = false;

				this->checkForPrevNodeRelease = true;
			}

			if (this->checkForPrevNodeRelease == true && sld(this->prevNode.getX()*1000.0, this->prevNode.getY()*1000.0, state.getBasePose().get_x(), state.getBasePose().get_y()) > 500) {
				std::cout << "RELEASE: " << this->prevNode.getId() << std::endl;
				this->statReq.setId(this->prevNode.getId());
				this->statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::FREENODE);
				COMP->nodeStatusUpdateServiceReq->query(this->statReq, this->statAnsw);
				this->checkForPrevNodeRelease = false;
			}

			this->nextPathStart = false;

			if (COMP->path.size() == 0) {
				std::cout << "Final Goal Node reached!" << std::endl;
				this->nextPathStart = true;
				this->checkForPrevNodeRelease = false;
			}
			else {

				this->goal.setXGoalPoint(COMP->path.back().getX() * 1000.0); // m -> mm
				this->goal.setYGoalPoint(COMP->path.back().getY() * 1000.0); // m -> mm

				//COMP->commCorridorNavigationGoal.setGoalX(COMP->path.back().getX() * 1000.0);
				//COMP->commCorridorNavigationGoal.setGoalY(COMP->path.back().getY() * 1000.0);


				// The following is not working because a single push with the current value is sometimes not received from the client (still receiving the old data)
				// => sending only one time is therefore not robust enough!

				//if (COMP->path.front().getReserved()) {
					// the path we want to approach next was reserved in our initial request -> we need to ask again until its free

	//				if (this->next) {
	//
	//					this->statReq.setId(COMP->path.front().getId());
	//					this->statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::ACQUIRENODE);
	//					COMP->nodeStatusUpdateServiceReq->query(this->statReq, this->statAnsw);
	//
	//					std::cout << "query (ACQUIRE): " << this->statReq << std::endl;
	//					std::cout << "answer (ACQUIRE): " << this->statAnsw << std::endl;
	//
	//					if (this->statAnsw.getSuccess()) {
	//
	//						this->goal.setXWayPoint(COMP->path.front().getX() * 1000.0); // m -> mm
	//						this->goal.setYWayPoint(COMP->path.front().getY() * 1000.0); // m -> mm
	//
	//						this->goal.setId(COMP->id);
	//						this->goal.setFlag(0);
	//						std::cout << "Put (id): " << COMP->path.front().getId() << "with goalid: " << this->goal.getId() << std::endl;
	//						std::cout << goal << std::endl;
	//						COMP->plannerGoalServiceOut->put(this->goal);
	//						this->next = false;
	//					}
	//					else {
	//						// the next node is currently not free => set current node (previously approached) as current waypoint and final waypoint so that robot stops
	//						this->goal.setId(COMP->id);
	//						this->goal.setFlag(1);
	//						COMP->plannerGoalServiceOut->put(this->goal);
	//					}
	//				}

					if (!this->success || this->next) {
						this->statReq.setId(COMP->path.front().getId());
						this->statReq.setType(DomainRobotFleetNavigation::StatusUpdateType::ACQUIRENODE);
						std::cout << "query (ACQUIRE): " << this->statReq << std::endl;
						COMP->nodeStatusUpdateServiceReq->query(this->statReq, this->statAnsw);
						std::cout << "answer (ACQUIRE): " << this->statAnsw << std::endl;
						this->success = this->statAnsw.getSuccess();
						this->next = false;
					}

					if (this->success) {
						this->goal.setXWayPoint(COMP->path.front().getX() * 1000.0); // m -> mm
						this->goal.setYWayPoint(COMP->path.front().getY() * 1000.0); // m -> mm

						this->goal.setId(COMP->id);
						this->goal.setFlag(0);
						//std::cout << "Put (id): " << COMP->path.front().getId() << "with goalid: " << this->goal.getId() << std::endl;
						//std::cout << goal << std::endl;
						COMP->plannerGoalServiceOut->put(this->goal);


//						COMP->commCorridorNavigationGoal.setStartX(COMP->path.front().getX() * 1000.0);
//						COMP->commCorridorNavigationGoal.setStartY(COMP->path.front().getY() * 1000.0);


						COMP->commCorridorNavigationGoal.setStartX(this->prevNode.getX());
						COMP->commCorridorNavigationGoal.setStartY(this->prevNode.getY());

						COMP->commCorridorNavigationGoal.setGoalX(COMP->path.front().getX());
						COMP->commCorridorNavigationGoal.setGoalY(COMP->path.front().getY());


						std::cout << "PUT 1: " << this->prevNode.getId() << " -> " << COMP->path.front().getId() << std::endl;



						COMP->corridorNavigationNextGoalOut->put(COMP->commCorridorNavigationGoal);
					}
					else {
						// the next node is currently not free => set current node (previously approached) as current waypoint and final waypoint so that robot stops
						this->goal.setId(COMP->id);
						this->goal.setFlag(1);
						COMP->plannerGoalServiceOut->put(this->goal);

						COMP->commCorridorNavigationGoal.setStartX(this->prevNode.getX());
						COMP->commCorridorNavigationGoal.setStartY(this->prevNode.getY());

						COMP->commCorridorNavigationGoal.setGoalX(this->prevNode.getX());
						COMP->commCorridorNavigationGoal.setGoalY(this->prevNode.getY());

						COMP->corridorNavigationNextGoalOut->put(COMP->commCorridorNavigationGoal);
					}
			}
		}
	}

	guard.release();

	//sleep(1);

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}
int GoalNodeControl::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}

double GoalNodeControl::sld(double x1, double y1, double x2, double y2) {
	return sqrt(pow(x1-x2,2)+pow(y1-y2,2));
}
