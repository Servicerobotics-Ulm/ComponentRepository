//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2011 Matthias Lutz, Dennis Stampfer
//
//        schlegel@hs-ulm.de
//
//        Prof. Dr. Christian Schlegel
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
// --------------------------------------------------------------------------

#include "GuiTask.hh"
#include "ComponentUnicapImageClient.hh"

#ifdef WITH_MRPT_2_0_VERSION
#include <mrpt/img/CImage.h>
#else
#include <mrpt/utils/CImage.h>
#include <mrpt/math/lightweight_geom_data.h>
#include <mrpt/math/geometry.h>
using namespace mrpt::math;
using namespace mrpt::utils;
#endif

#include <iostream>

GuiTask::GuiTask(SmartACE::SmartComponent *comp) 
:	GuiTaskCore(comp), window("Image Viewer")
{
	std::cout << "constructor GuiTask\n";
}
GuiTask::~GuiTask() 
{
	std::cout << "destructor GuiTask\n";
}



int GuiTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int GuiTask::on_execute()
{
	SmartACE::SmartGuard imgGuard(COMP->CurrentImageMutex);
			{
#ifdef WITH_MRPT_2_0_VERSION
		if (COMP->currentImage->isEmpty() != NULL)

#else
		if (COMP->currentImage != NULL)
				{

					// get image
					mrpt::utils::CImage img(COMP->currentImage);
					const size_t maxSize = 800;
					if (img.getWidth() > maxSize || img.getHeight() > maxSize)
					{
						unsigned int factor, newWidth, newHeight;

						factor = img.getWidth() / maxSize;
						newWidth = img.getWidth() / factor;
						newHeight = img.getHeight() / factor;
#ifdef WITH_MRPT_2_0_VERSION
						img.scaleImage(img, newWidth, newHeight);
#else
						img.scaleImage(newWidth, newHeight);
#endif
					}

					/*
					COMP->vHelper.clearScene(0);
					COMP->vHelper.showBaseCoordinateSystem(0);
					COMP->vHelper.showXYPlane(0,-2,2,-2,2,-0.094,0.2); // floor
					COMP->vHelper.showCoordinateSystem(0, COMP->currentImagePose);
					*/

					std::cout << COMP->currentImagePose <<  std::endl;

				//	justifyHorizon(img, COMP->currentImagePose);

					window.showImage(img);
				} else
#endif
				{
					std::cout << "[GuiTask] Error no image to show!" << std::endl;
				}
			}
			imgGuard.release();
			usleep(200000);

		// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
		return 0;
}
int GuiTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
#ifdef WITH_MRPT_2_0_VERSION
#else
void GuiTask::justifyHorizon(mrpt::utils::CImage &image, CPose3D &imagePose) {
/*
// OLD STUFF FROM KATE.
// will not work on larry due to more DOFS there. See implementation below.

	CPose3D tmp(
			0,
			0,
			0.5,
			DEG2RAD(-90.0),
			imagePose.pitch(),
			DEG2RAD(-90.0)
			);

	CPose3D normal(
			0,
			0,
			0.5,
			DEG2RAD(-90.0),
			DEG2RAD(0),
			DEG2RAD(-90.0)
		      );

	CPose3D result_angle(normal - tmp);


	CPoint3D tmpPoint(0, 1, 0);
	tmpPoint = imagePose + tmpPoint;
	CPoint3D yAxisCamera(tmpPoint - CPoint3D(imagePose));

	//std::cout << "tmpPont" << tmpPoint << std::endl;
	//std::cout << "yAxisCamera" << yAxisCamera << std::endl;
	//CPose3D tmp2(yAxisCamera);
	//COMP->vHelper.showCoordinateSystem(0, tmp, 0.05);
	//COMP->vHelper.showCoordinateSystem(0, normal, 0.05);
	//COMP->vHelper.showCoordinateSystem(0, tmp2, 0.02);
	double correction = 0;
	double correction_signature = -1;

	if(yAxisCamera.z() > 0) {
		correction = DEG2RAD(180);
		correction_signature = 1;
	}

	image.rotateImage((result_angle.yaw() + correction) * correction_signature , image.getWidth()/2, image.getHeight()/2);
*/



	// NEW IMPLEMENTATION ON LARRY -- START

	TPlane robot_xy;
	mrpt::math::createPlaneFromPoseXY(CPose3D(), robot_xy);
	TLine3D camera_x;
	mrpt::math::createFromPoseX(imagePose, camera_x);
	TLine3D camera_y;
	mrpt::math::createFromPoseY(imagePose, camera_y);

	double angle_x = getAngle(robot_xy, camera_x);
	double angle_y = getAngle(robot_xy, camera_y);

	std::cout << "##### Correction angle_x: " << RAD2DEG(angle_x) << " via getAngle(robot_xy, camera_x)" << std::endl;
	std::cout << "##### Correction angle_y: " << RAD2DEG(angle_y) << " via getAngle(robot_xy, camera_y)" << std::endl;

	double angle=0.0;

	if(abs(angle_x) < abs(angle_y)) {
		std::cout << "Taking X-Angle." << std::endl;

		// check if Y-axis points towards sky or ground, i.e. if camera is upside down or not.
		// it is upside down if xAxisCamera.z > 0
		CPoint3D tmpPoint(0, 1, 0);
		tmpPoint = imagePose + tmpPoint; // find point that is along y-Axis of camera coord
		std::cout << "tmp point after first trans: " << tmpPoint << std::endl;
		CPoint3D pnt(tmpPoint - CPoint3D(imagePose)); // get that coordinate system down to ground to see wether the point from before is below or above ground level.
		std::cout << "pnt: " << pnt << std::endl;

		if(pnt.z() > 0) { // new point above 0-plane, i.e. camera upside down
			angle = angle_x;
			angle += M_PI; // add 180째 to rotate image correct
		} else {
			angle = -angle_x; // rotate in the other direction
		}


	} else {
		std::cout << "Taking Y-Angle." << std::endl;

		// check if X-Axis points towards sky or ground, i.e. which side of camera
		// chassis (left/right) points towards sky or ground
		CPoint3D tmpPoint(1, 0, 0);
		tmpPoint = imagePose + tmpPoint; // find point that is along X-Axis of camera coord
		std::cout << "tmp point after first trans: " << tmpPoint << std::endl;
		CPoint3D pnt(tmpPoint - CPoint3D(imagePose)); // get that coordinate system down to ground to see wether the point from before is below or above ground level.
		std::cout << "pnt: " << pnt << std::endl;

		if(pnt.z() > 0) { // new point above 0-plane
			angle = -angle_y;
			angle += M_PI;
		} else {
			angle = +angle_y;
		}

		angle += M_PI_2; // add 90째 because in this case, camera is sidewards (90째 to ground plane)

	}


	std::cout << ">>>> Result angle: " << RAD2DEG(angle) << "째" << std::endl;

	// LARRY END

	image.rotateImage(angle, image.getWidth()/2, image.getHeight()/2);

}
#endif
