//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

// --------------------------------------------------------------------------
//
//  Copyright (C) 2008 Christian Schlegel, Andreas Steck, Matthias Lutz
//
//        schlegel@hs-ulm.de
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotik Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        D-89075 Ulm
//        Germany
//
//  This file is part of the "SmartSoft Mapper/GridMapper component".
//  It provides mapping services based on grid maps. The current map
//  represents the latest snapshot of the local surrounding based on
//  laserscans. The current map can be preoccupied by the longterm map.
//  The longterm map is a simple occupancy grid map.
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// --------------------------------------------------------------------------

#include "TriggerHandler.hh"
#include "IEEEMDR.hh"
#include "SmartMapperGridMap.hh"

// trigger user methods
void TriggerHandler::handleCommNavigationObjects_MapperParams_CURPARAMETER(const int &xsize, const int &ysize, const int &xpos, const int &ypos, const int &id)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	COMP->CurLock.acquire();
	delete COMP->currentGridMap;
	COMP->currentGridMap = new Smart::SmartCurrentGridMap(	xsize,ysize,
															xpos,ypos,
															COMP->getGlobalState().getGeneral().getCellsize(),COMP->growingType,id);
	COMP->CurLock.release();
	std::cout<<"Generated new CurrentMap with size: "<< xsize<<" "<<ysize<<" offset: "<<xpos<<" "<<ypos<<" id: "<<id<<std::endl;
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMPARAMETER(const int &xsize, const int &ysize, const int &xpos, const int &ypos, const int &id)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	COMP->LtmLock.acquire();
	delete COMP->ltmGridMap;
	COMP->ltmGridMap = new Smart::SmartLtmGridMap(	xsize,ysize,
													xpos,ypos,
													COMP->getGlobalState().getGeneral().getCellsize(),id);
	COMP->LtmLock.release();
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMINITIALIZE(const int &value)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	COMP->LtmLock.acquire();
	COMP->ltmGridMap->clearMap(value);
    COMP->LtmLock.release();
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_CURSAVE(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::string file = filename;
	file.append(".xml");
	file.insert(0,COMP->getGlobalState().getGeneral().getMapDataDir());
	COMP->CurLock.acquire();
	std::ofstream myFile ( file.c_str() , std::ios::out | std::ios::binary);
	std::cout<<"WARNING NOT TESTED XML FILE FORMAT!!"<<std::endl;
	COMP->currentGridMap->to_xml( myFile );
	myFile.close();
	COMP->CurLock.release();
	std::cout << "MAPPER_CUR_SAVE: saved -  " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_CURLOAD(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	std::string file = filename;
	file.append(".xml");
	file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
	COMP->CurLock.acquire();
	std::ifstream myFile ( file.c_str() , std::ios::in | std::ios::binary);
	std::cout<<"WARNING NOT TESTED XML FILE FORMAT!!"<<std::endl;
	COMP->currentGridMap->from_xml( myFile );
	myFile.close();
	COMP->CurLock.release();
	std::cout << "MAPPER_CUR_LOAD: loaded -  " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_CURLOADLTM()
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// only allowed in deactivated mode
	COMP->CurLock.acquire();
	std::cout << "MAPPER_CUR_LOAD_LTM: clearnMap()"<<std::endl;
	COMP->currentGridMap->clearMap();
	std::cout << "MAPPER_CUR_LOAD_LTM: setLtmOccupation()"<<std::endl;
	COMP->currentGridMap->setLtmOccupation(COMP->ltm_threshold,*(COMP->ltmGridMap));
	COMP->CurLock.release();
	std::cout << "MAPPER_CUR_LOAD_LTM: cur map built from ltm map -  threshold = " << COMP->ltm_threshold << "\n";

}
void TriggerHandler::handleCommNavigationObjects_MapperParams_CURSAVEXPM(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// allowed in running mode
	std::string file = filename;
	file.append(".xpm");
	file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
	COMP->CurLock.acquire();
	std::ofstream myFile ( file.c_str() , std::ios::out | std::ios::binary);
	COMP->currentGridMap->save_xpm( myFile );
	myFile.close();
	COMP->CurLock.release();
	std::cout << "MAPPER_CUR_SAVE_XPM: saved -  " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMSAVE(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// allowed in running mode
	std::string file = filename;
	file.append(".xml");
	file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
	COMP->LtmLock.acquire();
	std::ofstream myFile ( file.c_str() , std::ios::out | std::ios::binary);
	std::cout<<"WARNING NOT TESTED XML FILE FORMAT!!"<<std::endl;
	COMP->ltmGridMap->to_xml( myFile );
	myFile.close();
	COMP->LtmLock.release();
	std::cout << "MAPPER_LTM_SAVE: saved -  " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMLOAD(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
    // only allowed in deactivated mode
	std::string file = filename;
    file.append(".xml");
    file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
    COMP->LtmLock.acquire();
    std::ifstream myFile ( file.c_str() , std::ios::in | std::ios::binary);
	std::cout<<"WARNING NOT TESTED XML FILE FORMAT!!"<<std::endl;
    COMP->ltmGridMap->from_xml( myFile );
    myFile.close();
    COMP->LtmLock.release();
    std::cout << "MAPPER_LTM_LOAD: loaded -  " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMSAVEXPM(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// allowed in running mode
	std::string file = filename;
	file.append(".xpm");
	file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
	COMP->LtmLock.acquire();
	std::ofstream myFile ( file.c_str() , std::ios::out | std::ios::binary);
	COMP->ltmGridMap->save_xpm( myFile );
	myFile.close();
	COMP->LtmLock.release();
	std::cout << "MAPPER_LTM_SAVE_XPM: saved -  " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMSAVEYAMLPGM(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// allowed in running mode
	std::string file = filename;
	file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
	std::string mapFileName = filename;
	file.append(".yaml");
	mapFileName.append(".pgm");

	COMP->LtmLock.acquire();
	std::ofstream myFile ( file.c_str() , std::ios::out | std::ios::binary);
	COMP->ltmGridMap->save_yaml_pgm( myFile, mapFileName );
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMSAVEYAMLPPM(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
    // allowed in running mode
	std::string file = filename;
    file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
    std::string mapFileName = filename;
    file.append(".yaml");
    mapFileName.append(".ppm");

    COMP->LtmLock.acquire();
    std::ofstream myFile ( file.c_str() , std::ios::out | std::ios::binary);
    COMP->ltmGridMap->save_yaml_ppm( myFile, mapFileName);
    myFile.close();
    COMP->LtmLock.release();
    std::cout << "MAPPER_LTM_SAVE_YAML_PPM: saved - " << file << "\n";
}
void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMLOADYAML(const std::string &filename)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	// only allowed in deactivated mode
	std::string file = filename;
	file.append(".yaml");
	file.insert(0, COMP->getGlobalState().getGeneral().getMapDataDir());
	COMP->LtmLock.acquire();
	if(COMP->ltmGridMap->load_yaml( file ) !=0){
		std::cout<<"ERROR LOADING map file: "<<file <<" continue with old map \n";
	} else {
		std::cout << "MAPPER_LTM_LOAD_YAML: loaded - " << file << "\n";
	}
	COMP->LtmLock.release();
}


void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMLOADIEEESTD(const std::string &filename)
{
	std::string file = filename;
	IEEEMDR imdr;
	COMP->LtmLock.acquire();
	imdr.ieeemdr_to_ltm_gridmap(file, *COMP->ltmGridMap);
	COMP->LtmLock.release();
	std::cout << "MAPPER_LTM_LOAD_IEEE_STD: saved -  " << file << "\n";

}

void TriggerHandler::handleCommNavigationObjects_MapperParams_LTMSAVEIEEESTD(const std::string &filename)
{
	std::string file = filename;
	file.append(".xml");
	file.insert(0,COMP->getGlobalState().getGeneral().getMapDataDir());
	IEEEMDR imdr;
	COMP->LtmLock.acquire();
	imdr.ltm_gridmap_to_ieeemdr(*COMP->ltmGridMap, file);
	COMP->LtmLock.release();
	std::cout << "MAPPER_LTM_SAVE_IEEESTD: saved -  " << file << "\n";

}
