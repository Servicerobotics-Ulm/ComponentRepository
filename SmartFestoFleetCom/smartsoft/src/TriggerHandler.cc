//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------

#include "TriggerHandler.hh"

#include "SmartFestoFleetCom.hh"
#include "CommBasicObjects/CommBaseStateACE.hh"
#include "CommBasicObjects/CommIOValuesACE.hh"

// trigger user methods
void TriggerHandler::handleDomainRobotFleet_FleetManagerParameter_ADDROBOT(const std::string &robotName, const std::string &baseComponentName, const std::string &baseServiceName, const std::string &baseriOQueryServerName, const std::string &laserComponentName, const std::string &laserServiceName, const std::string &pathNavClientComponentName, const std::string &pathNavClientServiceName)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	{
		SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
		if(lock.locked()){

			if(COMP->robotConnectionMap.find(robotName) != COMP->robotConnectionMap.end()){
				std::cout<<"WARNING: the robots connection list to add is already in the list!--> DO NOTHING"<<std::endl;
			} else{
				std::pair<std::string,SmartFestoFleetCom::RobotConnetions> newConnection;
				SmartFestoFleetCom::RobotConnetions connection;
				connection.baseComponentName = baseComponentName;
				connection.baseServiceName = baseServiceName;
				connection.baseriOQueryServerName = baseriOQueryServerName;
				connection.laserComponentName = laserComponentName;
				connection.laserServiceName = laserServiceName;
				connection.pathNavClientComponentName = pathNavClientComponentName;
				connection.pathNavClientServiceName = pathNavClientServiceName;
				newConnection.first = robotName;
				newConnection.second = connection;

				COMP->robotConnectionMap.insert(newConnection);
			}


			if(COMP->basePorts.find(robotName) != COMP->basePorts.end()){
				std::cout<<"WARNING: the base component to add is already in the list!--> DO NOTHING"<<std::endl;
			} else {

				std::pair<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *> newBasePort;
				newBasePort.first = robotName;
				newBasePort.second = new SmartACE::PushClient<CommBasicObjects::CommBaseState>(COMP->getComponentImpl());
				COMP->basePorts.insert(newBasePort);

				std::map<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *>::iterator it;
				it=COMP->basePorts.find(robotName);

				Smart::StatusCode status;
				std::cout << "connecting to: " << baseComponentName << "; " << baseServiceName << std::endl;
				status = it->second->connect(baseComponentName, baseServiceName);
				it->second->subscribe(COMP->getGlobalState().getSettings().getBasePortsSubcriptionInterval());
				std::cout<<"Connect result: "<<Smart::StatusCodeConversion(status)<<std::endl;
			}


			if(COMP->baseIOPorts.find(robotName) != COMP->baseIOPorts.end()){
				std::cout<<"WARNING: the baseIO component to add is already in the list!--> DO NOTHING"<<std::endl;
			} else {

				std::pair<std::string,Smart::IQueryClientPattern<CommBasicObjects::CommIOValues,CommBasicObjects::CommIOValues> *> newBaseIOPort;
				newBaseIOPort.first = robotName;
				newBaseIOPort.second = new SmartACE::QueryClient<CommBasicObjects::CommIOValues,CommBasicObjects::CommIOValues>(COMP->getComponentImpl());
				COMP->baseIOPorts.insert(newBaseIOPort);

				std::map<std::string,Smart::IQueryClientPattern<CommBasicObjects::CommIOValues,CommBasicObjects::CommIOValues> *>::iterator it;
				it=COMP->baseIOPorts.find(robotName);

				Smart::StatusCode status;
				std::cout << "connecting to: " << baseComponentName << "; " << baseriOQueryServerName << std::endl;
				status = it->second->connect(baseComponentName, baseriOQueryServerName);
				std::cout<<"Connect result: "<<Smart::StatusCodeConversion(status)<<std::endl;
			}
		}

	}
}
void TriggerHandler::handleDomainRobotFleet_FleetManagerParameter_RMROBOT(const std::string &robotName)
{
	// implement the trigger behavior here. Be aware, if you must use blocking calls here, please set this
	// trigger as active in the model. For an active trigger an active queue will be generated internally 
	// (transparent for the usage here). Thus an active trigger will be called within a separate task scope.
	{
		SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
		if(lock.locked()){

			std::map<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *>::iterator it;
			it=COMP->basePorts.find(robotName);
			if(it != COMP->basePorts.end())
			{
				Smart::StatusCode status;
				std::cout << "Disconnecting: " << robotName << ";"<<std::endl;
				status = it->second->unsubscribe();
				std::cout<<"Unsubscribe result: "<<Smart::StatusCodeConversion(status)<<std::endl;
				status = it->second->disconnect();
				std::cout<<"Disconnect result: "<<Smart::StatusCodeConversion(status)<<std::endl;
				COMP->basePorts.erase(it);
			} else {
				std::cout<<"WARNING: trying to remove an not added robot base port!"<<std::endl;
			}


			std::map<std::string,Smart::IQueryClientPattern<CommBasicObjects::CommIOValues,CommBasicObjects::CommIOValues> *>::iterator it2;
			it2=COMP->baseIOPorts.find(robotName);
			if(it2 != COMP->baseIOPorts.end())
			{
				Smart::StatusCode status;
				std::cout << "Disconnecting: " << robotName << ";"<<std::endl;
				status = it2->second->disconnect();
				std::cout<<"Disconnect result: "<<Smart::StatusCodeConversion(status)<<std::endl;
				COMP->baseIOPorts.erase(it2);
			} else {
				std::cout<<"WARNING: trying to remove an not added robot base port!"<<std::endl;
			}

			{
				std::map<std::string, SmartFestoFleetCom::RobotConnetions>::iterator it;
				it=COMP->robotConnectionMap.find(robotName);
				if(it != COMP->robotConnectionMap.end())
				{
					Smart::StatusCode status;
					COMP->robotConnectionMap.erase(it);
				} else {
					std::cout<<"WARNING: trying to remove an not added connection entry !"<<std::endl;
				}
			}
		}

	}
}
