//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "ReadCommandTask.hh"
#include "SmartFestoFleetCom.hh"

#include <iostream>
#include <algorithm>
#include <locale>
#include <functional>
#include <cctype>

#include "CommBasicObjects/CommKBRequest.hh"
#include "CommBasicObjects/CommBaseState.hh"

#if defined (__GNUC__) && defined(__unix__)

#elif defined (WIN32) || defined (WIN64)
#define _USE_MATH_DEFINES
#include <math.h>
#include <ctype.h>
#endif

ReadCommandTask::ReadCommandTask(SmartACE::SmartComponent *comp) 
:	ReadCommandTaskCore(comp)
{
	std::cout << "constructor ReadCommandTask\n";
}
ReadCommandTask::~ReadCommandTask() 
{
	std::cout << "destructor ReadCommandTask\n";
}

bool IsNonNewLineChar(char c)
{
        switch(c)
        {
	//in windows a \n and \r is send as one newline
        case '\n':
        case '\r':
                return true;
        default:
                return false;

        }
}


bool IsNonContentChar2(char c)
{
	switch(c)
	{
	case '\\':
		return true;
	default:
		return false;

	}
}

// trim from start
static inline std::string &ltrim(std::string &s) {
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
        return s;
}

// trim from end
static inline std::string &rtrim(std::string &s) {
        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
        return s;
}

// trim from both ends
static inline std::string &trim(std::string &s) {
        return ltrim(rtrim(s));
}

int ReadCommandTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	std::cout<<std::endl<<"[ReadCommandTask] Ready to receive data from FleetManager\n"<<std::endl;
	std::string message;
	message = "(defun format-locations (s obj colonmod at-sign) (declare (ignore colonmod)) (declare (ignore at-sign)) (format s \"~s ~3$ ~3$ ~d ~s\" (get-value obj 'name)(/ (first (get-value obj 'approach-region-pose)) 1000)(/ (second (get-value obj 'approach-region-pose)) 1000)(second (get-value obj 'orientation-region))(get-value obj 'type)))";
	CommBasicObjects::CommKBRequest	request;
	CommBasicObjects::CommKBResponse answer;
	request.setRequest(message);
	std::cout<<"Initial QUERY to KB to propagate the format function for the locations"<<std::endl;
	COMP->
	COMP->kbQueryClient->query(request,answer);
	std::cout<<"Got KB Query Answer: "<<answer.getResponse()<<std::endl;

	message = "(defun format-robots (s obj colonmod at-sign) (declare (ignore colonmod)) (declare (ignore at-sign)) (format s \"~d\" (get-value obj 'name)))";
	request.setRequest(message);
	std::cout<<"Initial QUERY to KB to propagate the format function for the robots id"<<std::endl;
	COMP->kbQueryClient->query(request,answer);
	std::cout<<"Got KB Query Answer: "<<answer.getResponse()<<std::endl;

	message = "(defun format-stations (s obj colonmod at-sign) (declare (ignore colonmod)) (declare (ignore at-sign)) (format s \"~s ~3$ ~3$ ~d ~s ~d\" (get-value obj 'id) (first (get-value obj 'pose)) (second (get-value obj 'pose)) (third (get-value obj 'pose)) (get-value obj 'type) (get-value obj 'approach-location) ))";
	request.setRequest(message);
	std::cout<<"Initial QUERY to KB to propagate the format function for the stations"<<std::endl;
	COMP->kbQueryClient->query(request,answer);
	std::cout<<"Got KB Query Answer: "<<answer.getResponse()<<std::endl;

	message = "(defun format-station-types (s obj colonmod at-sign) (declare (ignore colonmod)) (declare (ignore at-sign)) (format s \"~s ~3$ ~3$ ~3$ ~3$ ~3$ ~3$ ~3$ ~3$ ~s ~s ~d ~3$ ~3$\" (get-value obj 'name)"
                                         "(get-value obj 'min-station-width) (get-value obj 'max-station-width)"
                                         "(get-value obj 'offset-between-center-of-belts) (get-value obj 'offset-left-reflector-to-1stBelt-center) "
                                         "(get-value obj 'ir-dock-stop-dist-l2-min) (get-value obj 'ir-dock-stop-dist-l2-max) (get-value obj 'ir-dock-stop-dist-l1) (get-value obj 'ir-dock-center-sensor-zero)"
                                         "(get-value obj 'docking-type) (get-value obj 'commincation-type) (get-value obj 'number-of-belts) (get-value obj 'max-reflector-dist) (get-value obj 'laser-dock-stop-dist) ))";
	request.setRequest(message);
	std::cout<<"Initial QUERY to KB to propagate the format function for the stations-types"<<std::endl;
	COMP->kbQueryClient->query(request,answer);
	std::cout<<"Got KB Query Answer: "<<answer.getResponse()<<std::endl;

	message = "(defun format-latest-jobs (s obj colonmod at-sign) (declare (ignore colonmod)) (declare (ignore at-sign)) (format s \"jobid:~d robotinoid:~d jobtype:~s state:~s\""
			                           "(get-value obj 'id) (get-value obj 'robotid) (get-value obj 'type) (get-value obj 'state)))";
	request.setRequest(message);
	std::cout<<"Initial QUERY to KB to propagate the format function for the latest-jobs"<<std::endl;
	COMP->kbQueryClient->query(request,answer);
	std::cout<<"Got KB Query Answer: "<<answer.getResponse()<<std::endl;


	return 0;
}

bool invalidChar (char c)
{
    if(std::isprint(c) == 0){
    	return true;
    }
    return false;
}

void ReadCommandTask::removeMessagesWithNonePrintChars(std::deque <std::string> &mydeque){

	std::deque<std::string>::iterator it2;
	for(it2=mydeque.begin(); it2!=mydeque.end();)
	{
		////remove /r and /n from the message (for windows new lines)
		//it2->erase(std::remove_if(it2->begin(),it2->end(), &IsNonNewLineChar),it2->end());

		std::string::iterator it = find_if(it2->begin(),it2->end(), invalidChar);
		if(it != it2->end()){
			std::cout<<"ERROR the message does contains control chars --> remove MSG!"<<std::endl;
			it2 = mydeque.erase(it2);
		} else {
			++it2;
		}
	}

}

int ReadCommandTask::on_execute()
{
	// this method is called from an outside loop,
	// hence, NEVER use an infinite loop (like "while(1)") here inside!!!
	// also do not use blocking calls which do not result from smartsoft kernel

	std::stringstream messageStream;
	std::string message;
	int retval = COMP->com.recv(message);

	if(retval == 0){
		messageStream << messageRest;
		std::cout<<"[ReadCommandTask]Got message from fleet manager: |"<<message<<"|"<<std::endl;
		messageStream << message;

		std::deque<std::string> mydeque, plan, query;
		//std::cout<<"MStream|"<<messageStream.str() <<"|"<<std::endl;
		messageRest = splitIntoLines(mydeque, messageStream);

		removeMessagesWithNonePrintChars(mydeque);

		int ret = separateQueryPlan(mydeque, plan, query);

		std::deque<std::string>::iterator it;
		for(it=query.begin(); it!=query.end();++it)
		{
			CommBasicObjects::CommKBRequest	request;
			CommBasicObjects::CommKBResponse answer;
			request.setRequest(*it);
			std::cout<<"Query for KB..."<<std::endl;
			Smart::StatusCode status = COMP->kbQueryClient->query(request,answer);
			std::cout<<"... got answer!"<<std::endl;
			if(status == Smart::SMART_OK){
				std::string answerString(answer.getResponse());

				std::cout<<"KB Answer: "<<answerString<<std::endl;
				try{
					if(answerString.compare("NIL") == 0)
					{
						std::cout<<"Got NIL as answer! --> send empty answer string!"<<std::endl;
						answerString = "";
					} else {
						answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
						ltrim(answerString); //remove leading blanks
						answerString.erase(0,1); //remove front \"
						answerString.erase(answerString.size()-1,1); //remove tail \"
					}
				} catch (const std::exception& ex) {
					std::cout<<"exception std::exception: "<<ex.what()<<std::endl;
					answerString = "";
				} catch (const std::string& ex) {
					std::cout<<"exception std::string: "<<ex<<std::endl;
					answerString = "";
				} catch (...) {
					std::cout<<"exception ... "<<std::endl;
					answerString = "";
				}

				COMP->writeComLock.acquire();
					COMP->com.send(answerString + "\n");
				COMP->writeComLock.release();
			} else {
				std::cout<<"ERROR - query KB: "<<Smart::StatusCodeConversion(status)<<std::endl;

				if(status == Smart::SMART_DISCONNECTED){
					//this should never had happened!
					status = COMP->kbQueryClient->connect(COMP->connections.kbQueryClient.serverName, COMP->connections.kbQueryClient.serviceName);
					std::cout<<"Reconnect of kbQuery: "<<Smart::StatusCodeConversion(status)<<std::endl;
				}
			}
		}

		for(it=plan.begin(); it!=plan.end();++it)
		{
			std::cout << *it << std::endl;
			CommBasicObjects::CommTaskEventState tclMessage;
			CommBasicObjects::CommTaskMessage msg;
			msg.setMsg(parseMsgToLisp(*it));
			tclMessage.setJob(msg);
			COMP->taskEventOut->put(tclMessage);
			//std::cout<<"Put Event "<<std::endl;

		}

	}else if( retval == -1){
		std::cout<<"ERROR from recv!"<<std::endl;
	} else if (retval == 1){
		//timeout --> ok
	}

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}

bool IsNonContentChar2_slash(char c)
{
	switch(c)
	{
	case '\\':
		return true;
	default:
		return false;

	}
}

// trim from start
static inline std::string &lefttrim(std::string &s) {

#if defined (__GNUC__) && defined(__unix__)
        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
#elif defined (WIN32) || defined (WIN64)
		s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(isspace))));
#endif
        return s;
}

int ReadCommandTask::separateQueryPlan(std::deque <std::string> &in, std::deque <std::string> &plan, std::deque <std::string> &query)
{
	std::string delimiter (" ");
	std::string queryString ("QUERY");
	std::size_t found;

	std::deque<std::string>::iterator it;
	for(it=in.begin(); it!=in.end();++it)
	{
		//std::cout<<"MESSAGE: "<<*it<<std::endl;
		found = it->find(delimiter);
		if(std::string::npos != found)
		{
			if(it->compare(0,found,queryString)==0){
				std::cout<<"FOUND QUERY"<<std::endl;
				query.push_back(it->substr(found+1));
				continue;
			}
			//			  else {
			//				  plan.push_back(*it);
			//			  }
		}

		//this is a special solution to keep the interface of the fleetcom backward compatible!
		if (it->compare("GetAllPosition")==0){
			std::cout<<"FOUND QUERY GetAllPosition"<<std::endl;
			query.push_back("(let ((obj-list     (kb-query-all :key '(is-a) :value '((is-a location)))))(format NIL \"AllPosition ~{~/format-locations/~^, ~}\" obj-list))");
		} else if (it->compare("GetAllStation")==0){
			std::cout<<"FOUND QUERY GetAllStation"<<std::endl;
			query.push_back("(let ((obj-list     (kb-query-all :key '(is-a) :value '((is-a station)))))(format NIL \"AllStation ~{~/format-stations/~^, ~}\" obj-list))");
		} else if (it->compare("GetAllStationTypes")==0){
			std::cout<<"FOUND QUERY GetAllStationTypes"<<std::endl;
			query.push_back("(let ((obj-list     (kb-query-all :key '(is-a) :value '((is-a station-type)))))(format NIL \"AllStationTypes ~{~/format-station-types/~^, ~}\" obj-list))");
		} else if (it->compare("GetMapStorageDirectory")==0) {
			std::cout<<"FOUND QUERY GetMapStorageDirectory"<<std::endl;
			query.push_back("(format Nil \"GetMapStorageDirectory ~s\" (concatenate 'string (sb-ext:posix-getenv \"SMART_ROOT_ACE\") \"/data/maps\"))");
		} else if (it->compare("GetAllRobotinoID")==0) {
			std::cout<<"FOUND QUERY GetAllRobotinoID"<<std::endl;
			query.push_back("(let ((obj-list (kb-query-all :key '(is-a) :value '((is-a robot)))))(format NIL \"AllRobotinoID ~{~/format-robots/~^, ~}\" obj-list))");
		} else if (it->find("GetRobotFleetType")!=std::string::npos) {
			std::cout<<"FOUND QUERY GetRobotFleetType"<<std::endl;
			std::size_t found = it->find("GetRobotFleetType");
			std::string robotid = it->substr(found+std::string("GetRobotFleetType").length()+1);
			std::cout<<"Robotid id: "<<robotid<<std::endl;
			std::stringstream statusMessage;
			statusMessage<<"RobotFleetType "<<robotid<<" ";
			getRobotFleetType(robotid,statusMessage);
			std::cout<<"StatusMessage: "<<statusMessage.str()<<std::endl;
			COMP->writeComLock.acquire();
			COMP->com.send(statusMessage.str() + "\n");
			COMP->writeComLock.release();
		} else if (it->find("GetRobotInfo")!=std::string::npos) {
			std::cout<<"FOUND QUERY GetRobotInfo"<<std::endl;
			std::size_t found = it->find("GetRobotInfo");
			if(it->length()>std::string("GetRobotInfo").length()+1){
				std::string robotid = it->substr(found+std::string("GetRobotInfo").length()+1);
				std::cout<<"Robotid id: "<<robotid<<std::endl;
				std::stringstream statusMessage;
				statusMessage<<"RobotInfo robotinoid:"<<robotid<<" ";
				getBaseState(robotid,statusMessage);
				getLaserState(robotid,statusMessage);
				getRobotBoxLoaded(robotid,statusMessage);
				getRobotState(robotid,statusMessage);

				std::cout<<"StatusMessage: "<<statusMessage.str()<<std::endl;
				COMP->writeComLock.acquire();
				COMP->com.send(statusMessage.str() + "\n");
				COMP->writeComLock.release();
			} else {
				std::cout<<"FOUND QUERY GetRobotInfo --> all robots"<<std::endl;
				COMP->statusSerialTask->on_execute();
			}

		} else if (it->find("GetJobInfo")!=std::string::npos) {
			std::cout<<"FOUND QUERY GetJobInfo"<<std::endl;
			std::size_t found = it->find("GetJobInfo");
			std::string jobid = it->substr(found+std::string("GetJobInfo").length()+1);
			std::cout<<"Jobid id: "<<jobid<<std::endl;
			query.push_back("(let ((job (kb-query :key '(is-a id) :value '((is-a job)(id "+jobid+"))))) (format nil \"JobInfo robotinoid:~d jobid:~d priority:~d fromstation:~d frombelt:~d tostation:~d tobelt:~d state:~d ~%\" (get-value job 'robotid) (get-value job 'id) (get-value job 'priority)  (get-value job 'start-station)  (get-value job 'start-belt) (get-value job 'end-station) (get-value job 'end-belt) (get-value job 'state) ))");

		} else if (it->find("GetXLatestJobs")!=std::string::npos) {
						std::cout<<"FOUND QUERY GetXLatestJobs"<<std::endl;
						std::size_t found = it->find("GetJobInfo");
						std::string number = it->substr(found+std::string("GetXLatestJobs").length()+1);
						std::cout<<"number of jobs: "<<number<<std::endl;


						query.push_back("(let* ((job-list (kb-query-all :key '(is-a) :value '((is-a job))))"
						       "(sorted-job-list (sort job-list #'(lambda (job-1 job-2) (> (get-value job-1 'push-time) (get-value job-2 'push-time)))))"
						       "(cut-sorted-job-list nil))"
						       "(setf cut-sorted-job-list (loop for i below (min "+number+" (length sorted-job-list)) collect (nth i sorted-job-list)))"
						       "(format nil \"LatestJobs ~{~/format-latest-jobs/~^, ~}\" cut-sorted-job-list)))");

		} else if (it->find("GetJobError")!=std::string::npos) {
			std::cout<<"FOUND QUERY GetJobError"<<std::endl;
			std::size_t found = it->find("GetJobError");
			std::string jobid = it->substr(found+std::string("GetJobError").length()+1);
			std::cout<<"Jobid id: "<<jobid<<std::endl;
			query.push_back("(let ((job (kb-query :key '(is-a id) :value '((is-a job)(id "+jobid+"))))) (format nil \"JobError robotinoid:~d jobid:~d error:~s ~%\" (get-value job 'robotid) (get-value job 'id)  (get-value job 'error-state) ))");
		} else if (it->compare("GetFleetState")==0){
			std::cout<<"FOUND QUERY GetFleetState"<<std::endl;
			if(!COMP->getGlobalState().getSettings().getPushCyclicSystemState())
			{
				//				COMP->statusSerialTask->on_execute();
				Smart::StatusCode status;

				std::stringstream statusMessage;
				statusMessage<<"FleetState ";
				//Do not use wait here! --> method is triggered from parameter handler,
				//if cyclic push of state is disabled in ini file
				{
					SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
					if(lock.locked()){


						std::map<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *>::iterator it;
						if(!COMP->basePorts.empty())
						{
							//			std::cout << "Get all base States:\n";
							for (it=COMP->basePorts.begin(); it!=COMP->basePorts.end(); ++it){

								CommBasicObjects::CommBaseState baseState;
								//				std::cout<<"Get base State for robot: "<<it->first<<std::endl;
								status = it->second->getUpdate(baseState);
								if (status != Smart::SMART_OK){
									std::cout<<"Error getting base State: "<<Smart::StatusCodeConversion(status)<<std::endl;

								} else {
									//						std::cout<<"Got BaseState: "<<baseState<<std::endl;

									std::string robotid = it->first;
									statusMessage<<"robotinoid:"<<robotid<<" ";

									//x y phi batteryvoltage current
									getBaseState(robotid,statusMessage);
									//laserwarning lasersafety
									getLaserState(robotid,statusMessage);
									//boxpresent
									getRobotBoxLoaded(robotid,statusMessage);
									//state ipaddress
									getRobotStateAndIP(robotid,statusMessage);

								}

							}
						}
						//		std::cout << "Get all base States----- DONE\n";
					}
					statusMessage<<"\n";
				}


				COMP->writeComLock.acquire();
				//std::cout<<"Send Status message!"<<std::endl;
				COMP->com.send(statusMessage.str());
				COMP->writeComLock.release();

			} else
			{
				std::cout<<"WARNING: Fleet state triggered once, while cyclic push of state is active!"<<std::endl;
			}
		} else {
			//no blank --> therefor no query
			plan.push_back(*it);
		}


	}

	return 0;
}

std::string  ReadCommandTask::splitIntoLines(std::deque <std::string> &result, std::stringstream &ss)
{
        std::string line;
        std::string rest = "";
        do{
                line = "";
                //ss >> line;
		std::getline(ss,line);
                //std::cout << "getline: line: "<<line<<" good: " << ss.good() << " eof: " << ss.eof() << " fail: " << ss.fail() << " bad: " << ss.bad() << std::endl;
                if(ss.good()){
                        result.push_back( line );
                }else
                {
                 rest = line;
                }

        }
        while (ss.good());

	//std::cout<<"Rest: "<<rest<<std::endl;
        return rest;
}




std::string ReadCommandTask::parseMsgToLisp(std::string message){
	//message = "DeliverFromTo 1 0 2 0";
	//message = "TeachPostion 1 0.54 23.5 45.0";
	/*int i=0;
	std::cout<<"Controll check: "<<std::endl;
	for(int i=0; i<message.length();++i)
	{
		std::cout<<(int)message[i]<<std::endl;
	}
	std::cout<<"ENDE"<<std::endl;*/
	std::string delimiter (" ");
	std::size_t found;

	std::string lispString("(");

	//remove all char \n
	message.erase(std::remove_if(message.begin(),message.end(), &IsNonNewLineChar),message.end());

	do
	{
		found = message.find(delimiter);
		if(std::string::npos != found)
		{
		std::string status = message.substr(0, found);
		lispString += status +" ";
		message = message.substr(found+1, message.length());
		} else {
			lispString += message+")";
		}
	}while(std::string::npos != found);

	std::cout<<"LispString: "<<lispString<<std::endl;
	return lispString;
}


void ReadCommandTask::getBaseState(std::string robotname, std::stringstream& statusMessage){

	//	CommBasicObjects::CommTCLMessage request,answer;
	//	std::string req_message;
	//	req_message = "(format NIL \"~d\" (get-value (kb-query :key '(is-a name) :value `((is-a robot)(name "+robotname+"))) 'base-component-name))";
	//	request.setLisp(req_message);
	//	COMP->kbQueryClient->query(request,answer);
	//	std::string answerString(answer.getLisp());
	//
	//	answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
	//	ltrim(answerString); //remove leading blanks
	//	answerString.erase(0,1); //remove front \"
	//	answerString.erase(answerString.size()-1,1); //remove tail \"

	//std::cout<<"Final answer String: "<<answerString<<std::endl;
	SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
	if(lock.locked()){


		CommBasicObjects::CommBaseState baseState;

		std::map<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *>::iterator it;
		it=COMP->basePorts.find(robotname);

		if(it != COMP->basePorts.end()){

			Smart::StatusCode status = it->second->getUpdate(baseState);
			if (status != Smart::SMART_OK){
				std::cout<<"Error getting base State: "<<Smart::StatusCodeConversion(status)<<std::endl;
				if(status == Smart::SMART_DISCONNECTED){
					std::cout<<"ERROR Component got disconnected --> reconnect!"<<std::endl;
					std::map<std::string, SmartFestoFleetCom::RobotConnetions>::iterator conIt = COMP->robotConnectionMap.find(it->first);
					if(conIt!= COMP->robotConnectionMap.end()){
						status = it->second->connect(conIt->second.baseComponentName,conIt->second.baseServiceName);
						if(status == Smart::SMART_OK){
							it->second->subscribe(COMP->getGlobalState().getSettings().getBasePortsSubcriptionInterval());
						} else {
							std::cout<<"Error on reconnect!"<<std::endl;
						}
					} else {
						std::cout<<"Error trying to reconnect an port that should have been deleted!"<<std::endl;
					}
				} else if (status == Smart::SMART_UNSUBSCRIBED){
					status = it->second->subscribe(COMP->getGlobalState().getSettings().getBasePortsSubcriptionInterval());
					std::cout << "baseclient was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << Smart::StatusCodeConversion(status) << std::endl;
					if(status != Smart::SMART_OK){
						//this is needed since the status of the client will not automatically change from unsubscribed to disconnected!
						it->second->disconnect();
					}
				}
			}
		} else {
			std::cout<<"Error finding base client in map!"<<std::endl;
		}
		statusMessage <<std::fixed << std::setprecision( 3 )<< "x:"<<baseState.get_base_position().get_x(1)<<" y:"<<baseState.get_base_position().get_y(1)<<" phi:"<<baseState.get_base_position().get_base_azimuth()*180/M_PI;
		statusMessage << " batteryvoltage:"<<baseState.get_battery_state().getPotential() << " current:"<<baseState.get_battery_state().getCurrent();

	}
}

void  ReadCommandTask::getAllBasePoses(std::stringstream& statusMessage) {

	SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
	if(lock.locked()){
		Smart::StatusCode status;

		std::map<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *>::iterator it;
		std::cout << "Get all base States:\n";
		for (it=COMP->basePorts.begin(); it!=COMP->basePorts.end(); ++it){

			CommBasicObjects::CommBaseState baseState;
			std::cout<<"Get base State for robot: "<<it->first<<std::endl;
			status = it->second->getUpdate(baseState);
			if (status != Smart::SMART_OK){
				std::cout<<"Error getting base State: "<<Smart::StatusCodeConversion(status)<<std::endl;
				if(status == Smart::SMART_DISCONNECTED){
					std::cout<<"ERROR Component got disconnected --> reconnect!"<<std::endl;
					std::map<std::string, SmartFestoFleetCom::RobotConnetions>::iterator conIt = COMP->robotConnectionMap.find(it->first);
					if(conIt!= COMP->robotConnectionMap.end()){
						status = it->second->connect(conIt->second.baseComponentName,conIt->second.baseServiceName);
						if(status == Smart::SMART_OK){
							it->second->subscribe(COMP->getGlobalState().getSettings().getBasePortsSubcriptionInterval());
						} else {
							std::cout<<"Error on reconnect!"<<std::endl;
						}
					} else {
						std::cout<<"Error trying to reconnect an port that should have been deleted!"<<std::endl;
					}
				} else if (status == Smart::SMART_UNSUBSCRIBED){
					status = it->second->subscribe(COMP->getGlobalState().getSettings().getBasePortsSubcriptionInterval());
					std::cout << "baseclient was unsubscribed (maybe due to rewiring) -> subscribe again returned with the " << Smart::StatusCodeConversion(status) << std::endl;
					if(status != Smart::SMART_OK){
						//this is needed since the status of the client will not automatically change from unsubscribed to disconnected!
						it->second->disconnect();
					}
				}
			} else {
				std::cout<<"Got basePose: "<<baseState.getBasePose().getPose3D().getPosition()<<std::endl;
				statusMessage <<"robotinoid: "<<it->first<<std::fixed << std::setprecision( 3 )<< " x:"<<baseState.get_base_position().get_x(1)<<" y:"<<baseState.get_base_position().get_y(1)<<" phi:"<<baseState.get_base_position().get_base_azimuth()*180/M_PI<<" ";
			}
		}
		std::cout << "Get all base States----- DONE\n";
	}
}

void ReadCommandTask::getRobotStateAndIP(std::string robotname, std::stringstream& statusMessage){

	CommBasicObjects::CommKBRequest	request;
	CommBasicObjects::CommKBResponse answer;
	std::string req_message;

	req_message =  "(let* ((robot (kb-query :key '(is-a name) :value `((is-a robot)(name "+robotname+"))))) (format NIL \" state:~d ipaddress:~a\" (get-value robot 'state) (get-value robot 'robotip)))";
	request.setRequest(req_message);
	COMP->kbQueryClient->query(request,answer);
	std::string answerString(answer.getResponse());

	answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
	ltrim(answerString); //remove leading blanks
	answerString.erase(0,1); //remove front \"
	answerString.erase(answerString.size()-1,1); //remove tail \"

	//std::cout<<"Final answer String: "<<answerString<<std::endl;

	statusMessage <<answerString;
}


void ReadCommandTask::getRobotState(std::string robotname, std::stringstream& statusMessage){

	CommBasicObjects::CommKBRequest	request;
	CommBasicObjects::CommKBResponse answer;
	std::string req_message;
	req_message = "(format NIL \"~d\" (get-value (kb-query :key '(is-a name) :value `((is-a robot)(name "+robotname+"))) 'state))";
	request.setRequest(req_message);
	COMP->kbQueryClient->query(request,answer);
	std::string answerString(answer.getResponse());

	answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
	ltrim(answerString); //remove leading blanks
	answerString.erase(0,1); //remove front \"
	answerString.erase(answerString.size()-1,1); //remove tail \"

	//std::cout<<"Final answer String: "<<answerString<<std::endl;

	statusMessage <<" state:"<<answerString;
}

void ReadCommandTask::getRobotFleetType(std::string robotname, std::stringstream& statusMessage){

	CommBasicObjects::CommKBRequest	request;
	CommBasicObjects::CommKBResponse answer;

	std::string req_message;
	req_message = "(format NIL \"~d\" (get-value (kb-query :key '(is-a name) :value `((is-a robot)(name "+robotname+"))) 'fleet-type))";
	request.setRequest(req_message);
	COMP->kbQueryClient->query(request,answer);
	std::string answerString(answer.getResponse());

	answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
	ltrim(answerString); //remove leading blanks
	answerString.erase(0,1); //remove front \"
	answerString.erase(answerString.size()-1,1); //remove tail \"

	//std::cout<<"Final answer String: "<<answerString<<std::endl;

	statusMessage <<answerString;
}

void ReadCommandTask::getLaserState(std::string robotname, std::stringstream& statusMessage){

	// THIS IMPL USES THE INFORMATION PROVIEDED BY THE S300 COMPONENT (MAY NOT WORK IN ALL CASES DEPENDEN ON S300 FIRMEWARE)
	//	CommBasicObjects::CommTCLMessage request,answer;
	//	std::string req_message;
	//	req_message = "(format NIL \"~d\" (get-value (kb-query :key '(is-a name) :value `((is-a robot)(name "+robotname+"))) 'laser-component-name))";
	//	request.setLisp(req_message);
	//	COMP->kbQueryClient->query(request,answer);
	//	std::string answerString(answer.getLisp());
	//
	//	answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
	//	ltrim(answerString); //remove leading blanks
	//	answerString.erase(0,1); //remove front \"
	//	answerString.erase(answerString.size()-1,1); //remove tail \"
	//
	//	int id = 0;
	//    CommBasicObjects::CommLaserSafetyEventParam p;
	//    CommBasicObjects::CommLaserSafetyField evnt;
	//    p.setProtectiveState(CommBasicObjects::SafetyFieldState::UNKNOWN);
	//    p.setWarningState(CommBasicObjects::SafetyFieldState::UNKNOWN);
	//    CHS::StatusCode status;
	//
	//    status = COMP->laserSafetyfieldEventClient->connect(answerString,"safetyfieldEventServer");
	//    if(status != CHS::SMART_OK){
	//    		std::cout<<"Error Connecting to :"<<answerString<<"|safetyfieldEventServer :"<<CHS::StatusCodeConversion(status)<<std::endl;
	//	}else {
	//		status = COMP->laserSafetyfieldEventClient->activate(CHS::continuous, p, id);
	//		if (status != CHS::SMART_OK) {
	//			std::cerr << "[LaserTask] WARNING: error on activating event (" << CHS::StatusCodeConversion(status)<< ")" << std::endl;
	//		}else {
	//			status = COMP->laserSafetyfieldEventClient->getEvent(id,evnt);
	//			COMP->laserSafetyfieldEventClient->deactivate(id);
	//			COMP->laserSafetyfieldEventClient->disconnect();
	//
	//			if(status != CHS::SMART_OK){
	//				std::cerr << "[LaserTask] WARNING: error on getting event (" << CHS::StatusCodeConversion(status)<< ")" << std::endl;
	//			} else {
	//				if(evnt.getWarningState() == CommBasicObjects::SafetyFieldState::BLOCKED){
	//					statusMessage<<" laserwarning:1";
	//				}else {
	//					statusMessage<<" laserwarning:0";
	//				}
	//				if(evnt.getProtectiveState() == CommBasicObjects::SafetyFieldState::BLOCKED){
	//					statusMessage<<" lasersafety:1";
	//				}else {
	//					statusMessage<<" lasersafety:0";
	//				}
	//			}
	//		}
	//	}

	// USE THE ROBOTINO IO TO GET THE LASER FIELDS VALUES (WILL ONLY WORK IF THE LASERS DIO ARE CONFIGURED AND CONNECTED TO THE BASE)
	SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
	if(lock.locked()){


		CommBasicObjects::CommIOValues ioValue;

		std::map<std::string,Smart::IQueryClientPattern<CommBasicObjects::CommIOValues,CommBasicObjects::CommIOValues> *>::iterator it;
		it=COMP->baseIOPorts.find(robotname);

		if(it != COMP->baseIOPorts.end()){

			Smart::StatusCode status = it->second->query(ioValue,ioValue);
			if (status != Smart::SMART_OK){
				std::cout<<"Error getting baseIO State: "<<Smart::StatusCodeConversion(status)<<" --> reconnect!"<<std::endl;
				std::map<std::string, SmartFestoFleetCom::RobotConnetions>::iterator conIt = COMP->robotConnectionMap.find(it->first);
				if(conIt!= COMP->robotConnectionMap.end()){
					status = it->second->connect(conIt->second.baseComponentName,conIt->second.baseriOQueryServerName);
					if(status == Smart::SMART_OK){
						std::cout<<"... connect success!"<<std::endl;
					} else {
						std::cout<<"Error on reconnect!"<<std::endl;
					}
				} else {
					std::cout<<"Error trying to reconnect an port that should have been deleted!"<<std::endl;
				}

				return;
//				if(status != CHS::SMART_DISCONNECTED){
//					std::cout<<"ERROR Component got disconnected, this should't have happened --> deleting client!"<<std::endl;
//					COMP->baseIOPorts.erase(it);
//					return;
//				}
			}
			if(COMP->getGlobalState().getRobotinoIO().getLaser_SafteyFieldDIn()<ioValue.getDigitalInputValuesSize() && COMP->getGlobalState().getRobotinoIO().getLaser_WarningFieldDIn()<ioValue.getDigitalInputValuesSize()){
				if(ioValue.getDigitalInputValuesElemAtPos(COMP->getGlobalState().getRobotinoIO().getLaser_WarningFieldDIn()) == false){
					statusMessage<<" laserwarning:1";
				}else {
					statusMessage<<" laserwarning:0";
				}

				if(ioValue.getDigitalInputValuesElemAtPos(COMP->getGlobalState().getRobotinoIO().getLaser_SafteyFieldDIn()) == false){
					statusMessage<<" lasersafety:1";
				}else {
					statusMessage<<" lasersafety:0";
				}
			} else {
				std::cout<<"Error in getting digital IO values from base!"<<std::endl;
			}
		} else {
			std::cout<<"Error finding baseIO client in map!"<<std::endl;
		}

	}
}

void ReadCommandTask::getRobotBoxLoaded(std::string robotname, std::stringstream& statusMessage){

//THIS IMPL USES THE INFORMATION PROVIEDED BY THE KB (KB IS ONLY UPDATED IF CHANGE IS EXPECTED)
//	CommBasicObjects::CommTCLMessage request,answer;
//	std::string req_message;
//	req_message = "(format NIL \"~d\" (get-value (kb-query :key '(is-a name) :value `((is-a robot)(name "+robotname+"))) 'box-loaded))";
//	request.setLisp(req_message);
//	COMP->kbQueryClient->query(request,answer);
//	std::string answerString(answer.getLisp());
//
//	answerString.erase(std::remove_if(answerString.begin(),answerString.end(), &IsNonContentChar2),answerString.end());
//	ltrim(answerString); //remove leading blanks
//	answerString.erase(0,1); //remove front \"
//	answerString.erase(answerString.size()-1,1); //remove tail \"
//
//	//std::cout<<"Final answer String: "<<answerString<<std::endl;
//
//	statusMessage <<" boxpresent:"<<answerString;

	// USE THE ROBOTINO IO TO GET THE BOX STATUS (WILL ONLY WORK IF THE BOX SENSOR IS CONNECTED TO THE BASE)
	SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
	if(lock.locked()){

		CommBasicObjects::CommIOValues ioValue;

		std::map<std::string,Smart::IQueryClientPattern<CommBasicObjects::CommIOValues,CommBasicObjects::CommIOValues> *>::iterator it;
		it=COMP->baseIOPorts.find(robotname);

		if(it != COMP->baseIOPorts.end()){

			Smart::StatusCode status = it->second->query(ioValue,ioValue);
			if (status != Smart::SMART_OK){
				std::cout<<"Error getting baseIO State: "<<Smart::StatusCodeConversion(status)<<std::endl;
				if(status != Smart::SMART_DISCONNECTED){
					std::cout<<"ERROR Component got disconnected, this should't have happened --> deleting client!"<<std::endl;
					COMP->baseIOPorts.erase(it);
					return;
				}
			}
			if(COMP->getGlobalState().getRobotinoIO().getConveyerBelt_BoxPresentDIn()<ioValue.getDigitalInputValuesSize()){
				if(ioValue.getDigitalInputValuesElemAtPos(COMP->getGlobalState().getRobotinoIO().getConveyerBelt_BoxPresentDIn()) == true){
					statusMessage<<" boxpresent:1";
				}else {
					statusMessage<<" boxpresent:0";
				}
			} else {
				std::cout<<"Error in getting digital IO values from base!"<<std::endl;
			}
		} else {
			std::cout<<"Error finding baseIO client in map!"<<std::endl;
		}
	}
}


int ReadCommandTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
