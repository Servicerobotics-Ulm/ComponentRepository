//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
#include "StatusSerialTask.hh"
#include "SmartFestoFleetCom.hh"

#include <iostream>

StatusSerialTask::StatusSerialTask(SmartACE::SmartComponent *comp) 
:	StatusSerialTaskCore(comp)
{
	std::cout << "constructor StatusSerialTask\n";
}
StatusSerialTask::~StatusSerialTask() 
{
	std::cout << "destructor StatusSerialTask\n";
}

int StatusSerialTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}

int StatusSerialTask::on_execute()
{
	Smart::StatusCode status;

	std::stringstream statusMessage;
	statusMessage<<"RobotInfo ";
	//Do not use wait here! --> method is triggered from parameter handler,
	//if cyclic push of state is disabled in ini file
	{
		SmartACE::SmartRecursiveGuard lock(COMP->portsLock);
		if(lock.locked()){


			std::map<std::string,Smart::IPushClientPattern<CommBasicObjects::CommBaseState> *>::iterator it;
			if(!COMP->basePorts.empty())
			{
				//			std::cout << "Get all base States:\n";
				for (it=COMP->basePorts.begin(); it!=COMP->basePorts.end(); ++it){

					CommBasicObjects::CommBaseState baseState;
					//				std::cout<<"Get base State for robot: "<<it->first<<std::endl;
					status = it->second->getUpdate(baseState);
					if (status != Smart::SMART_OK){
						std::cout<<"Error getting base State: "<<Smart::StatusCodeConversion(status)<<std::endl;

					} else {

						//						std::cout<<"Got BaseState: "<<baseState<<std::endl;
						std::string robotid = it->first;
						statusMessage<<"robotinoid:"<<robotid<<" ";
						statusMessage <<std::fixed << std::setprecision( 3 )<< "x:"<<baseState.get_base_position().get_x(1)<<" y:"<<baseState.get_base_position().get_y(1)<<" phi:"<<baseState.get_base_position().get_base_azimuth()*180/M_PI;
						statusMessage << " batteryvoltage:"<<baseState.get_battery_state().getPotential() << " current:"<<baseState.get_battery_state().getCurrent();
						COMP->readCommandTask->getLaserState(robotid,statusMessage);
						COMP->readCommandTask->getRobotBoxLoaded(robotid,statusMessage);
						COMP->readCommandTask->getRobotState(robotid,statusMessage);
						statusMessage<<" ";
					}

				}
			}
			//		std::cout << "Get all base States----- DONE\n";
		}
		statusMessage<<"\n";
	}


	COMP->writeComLock.acquire();
	//std::cout<<"Send Status message!"<<std::endl;
	COMP->com.send(statusMessage.str());
	COMP->writeComLock.release();

	// it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
	return 0;
}

int StatusSerialTask::on_exit()
{
	//TODO close the connection on component shutdown not on task shutdown!
	COMP->com.disconnect();
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
