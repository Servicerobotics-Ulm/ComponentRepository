//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2009 Andreas Steck, Matthias Lutz
//
//        steck@hs-ulm.de
//
//        ZAFH Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This program is free software; you can redistribute it and/or
//  modify it under the terms of the GNU General Public License
//  as published by the Free Software Foundation; either version 2.1
//  of the License, or (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  General Public License for more details.
//
//  You should have received a copy of the GNU General Public License along
//  with this library; if not, write to the Free Software Foundation, Inc.,
//  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
//--------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// CREDITS:
//
// The code for the communication with the pioneer robot was taken from the
// Playerstage Project, which is distributed under GPL, and you can find at
// http://playerstage.sourceforge.net/
//
// Player - One Hell of a Robot Server
// Copyright (C) 2000
//    Brian Gerkey, Kasper Stoy, Richard Vaughan, & Andrew Howard
//
//----------------------------------------------------------------------------
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
//----------------------------------------------------------------------------
#include "PlayerTask.hh"
#include "ComponentPlayerStageSimulator.hh"

#include <iostream>

PlayerTask::PlayerTask(SmartACE::SmartComponent *comp) 
:	PlayerTaskCore(comp)
{
	std::cout << "constructor PlayerTask\n";
}
PlayerTask::~PlayerTask() 
{
	std::cout << "destructor PlayerTask\n";
}



int PlayerTask::on_entry()
{
	// do initialization procedures here, which are called once, each time the task is started
	// it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
	return 0;
}
int PlayerTask::on_execute()
{
	  COMP->PlayerClientMutex.acquire();

		    COMP->robot->ReadIfWaiting();

		    base_position.set_x(COMP->position_2d_proxy->GetXPos(), 1.0);
		    base_position.set_y(COMP->position_2d_proxy->GetYPos(), 1.0);
		    base_position.set_z(0);
		    base_position.set_base_azimuth(COMP->position_2d_proxy->GetYaw());

		    double xSpeed;
		    double ySpeed;
		    xSpeed = COMP->position_2d_proxy->GetXSpeed();
		    ySpeed = COMP->position_2d_proxy->GetYSpeed();
		    base_velocity.set_vX(((xSpeed + ySpeed) / 2.0) * 1000.0);

		    double yawSpeed;
		    yawSpeed = COMP->position_2d_proxy->GetYawSpeed();
		    base_velocity.setWX(yawSpeed);

		    base_state.set_base_position(base_position);
		    base_state.set_base_velocity(base_velocity);

		    COMP->RobotPosLock.acquire();


		    double dx = base_position.get_x() - base_position_old.get_x();
		    double dy = base_position.get_y() - base_position_old.get_y();
		    double da = base_position.get_base_azimuth() - base_position_old.get_base_azimuth();

		    base_position_old = base_position;

		    COMP->robotPos.set_x( COMP->oldPos.get_x() + dx );
		    COMP->robotPos.set_y( COMP->oldPos.get_y() + dy );
		    //COMP->robotPos.set_base_alpha( COMP->oldPos.get_base_alpha() + da );
		    COMP->robotPos.set_base_azimuth( COMP->piToPiRad(COMP->oldPos.get_base_azimuth() + da ));

		    COMP->rawPos.set_x( COMP->rawPos.get_x() + dx );
		    COMP->rawPos.set_y( COMP->rawPos.get_y() + dy );
		    COMP->rawPos.set_base_azimuth( COMP->piToPiRad(COMP->rawPos.get_base_azimuth() + da ));

		    COMP->updateCovMatrix( COMP->oldPos, COMP->robotPos );
		    COMP->RobotPosLock.release();

		    COMP->oldPos = COMP->robotPos;
		    base_state.set_base_position(COMP->oldPos);
		    base_state.set_base_raw_position(COMP->rawPos);
		    base_state.set_base_velocity(base_velocity);

		    ///////////////////////////////////////////////////////////////////
		    // laser
		    CommBasicObjects::CommMobileLaserScan scan;

		    scan.set_base_state(base_state);

		    double _scanner_x = 0;
		    double _scanner_y = 0;
		    double _scanner_z = 0;
		    double _scanner_a = 0;
	//	    bool _scanner_on_turret = false;

		    // laser
		    scan.set_scan_update_count(scan_count);

		    // set timestamp
		    timeval _receive_time;
		    ::gettimeofday(&_receive_time, 0);
		    scan.set_scan_time_stamp(CommBasicObjects::CommTimeStamp(_receive_time));

		    //////////////////////////
		    // set scanner position
		    //
		    double base_x = 0;
		    double base_y = 0;
		    double base_z = 0;
		    double base_a = 0;

		    base_x = base_state.get_base_position().get_x();
		    base_y = base_state.get_base_position().get_y();
		    base_z = base_state.get_base_position().get_z();

	//	    if(_scanner_on_turret)
	//	    {
	//	      base_a = base_state.get_base_position().get_turret_azimuth();
	//	    }
	//	    else
	//	    {
		      base_a = base_state.get_base_position().get_base_azimuth();
	//	    }

		    const double sin_base_a = sin(base_a);
		    const double cos_base_a = cos(base_a);
		    scan.set_scanner_x(base_x + _scanner_x * cos_base_a - _scanner_y * sin_base_a);
		    scan.set_scanner_y(base_y + _scanner_x * sin_base_a + _scanner_y * cos_base_a);
		    scan.set_scanner_z(base_z + _scanner_z);
		    scan.set_scanner_azimuth(base_a + _scanner_a);

		    //////////////////////////
		    // set scan parameters
		    //
		    scan.set_scan_length_unit(1);
		    scan.set_scan_integer_field_of_view(-50*180, 50);
	//	    scan.set_scan_integer_field_of_view(-0.5*180, 50);

		    //////////////////////////
		    // get maximum non-overflow distance
		    //
		    const unsigned int max_dist = 7500;

		    //////////////////////////
		    // set scan points
		    //
		    const unsigned int num_points = COMP->laserProxy->GetCount();

		    if( num_points == 0)
		    {
		      scan.set_scan_valid(false);
		    }
		    else
		    {
		      unsigned int num_valid_points = 0;
		      for(unsigned int i=0; i<num_points; ++i)
		      {
		        if((unsigned int)((*(COMP->laserProxy))[i] * 1000.0) <= max_dist) ++num_valid_points;
		      }

		      scan.set_scan_size(num_valid_points);
		      unsigned int valid_point_index = 0;
		      for(unsigned int i=0; i<num_points; ++i)
		      {
		        const unsigned int dist = (unsigned int)((*(COMP->laserProxy))[i]*1000.0);
		        if(dist <= max_dist)
		        {
		          scan.set_scan_index(valid_point_index, i);
		          scan.set_scan_integer_distance(valid_point_index, dist);
		          valid_point_index++;
		        }
		      }

		      scan.set_scan_valid(true);
		    }


		    COMP->PlayerClientMutex.release();


		    baseStateServiceOutPut(base_state);
		    laserServiceOutPut(scan);

		    ++scan_count;
		    scan.set_scan_valid(false);
}
int PlayerTask::on_exit()
{
	// use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
	return 0;
}
