//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2010;2013 Manuel Wopfner; Matthias Lutz
//                2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------
#include "PtuTask.hh"
#include "ComponentWebotsPTUServer.hh"

#include <EulerTransformationMatrices.hh>
#include <iostream>

#include "ParameterStateStruct.hh"

PtuTask::PtuTask(SmartACE::SmartComponent *comp) :
    PtuTaskCore(comp) {
    std::cout << "constructor PtuTask\n";
}
PtuTask::~PtuTask() {
    std::cout << "destructor PtuTask\n";
    SmartACE::SmartGuard guard(COMP->ptuMutex);
    guard.release();
}

int PtuTask::on_entry() {
    // do initialization procedures here, which are called once, each time the task is started
    // it is possible to return != 0 (e.g. when initialization fails) then the task is not executed further
    return 0;
}
int PtuTask::on_execute() {
    // this method is called from an outside loop,
    // hence, NEVER use an infinite loop (like "while(1)") here inside!!!
    // also do not use blocking calls which do not result from smartsoft kernel

//    std::cout << "waiting on CV" << std::endl;
    this->newGoalCV.wait();
    this->newGoalCV.reset();

    //wait until a new Goal is set
//    std::cout << "moving to goal" << std::endl;

    DomainPTU::PTUGoalEventState eventState;
    DomainPTU::CommPTUMoveResponse answer;
    DomainPTU::CommPTUMoveRequest request;

    SmartACE::SmartGuard guard(this->goalBufferMutex);
    request = this->oneElementGoalBuffer;
    guard.release();

    this->move(request, answer);
    std::cout << "PtuTask.cc" << __LINE__ << ":" << answer.get_status() << std::endl;

    COMP->newPtuPos.release();

    std::cout << "eventState: " << eventState << std::endl;

    if (Smart::SMART_OK == COMP->stateSlave->tryAcquire("move")) {
    	std::cout << "answer.get_status" << __LINE__ << ":" << answer.get_status() << std::endl;
        eventState.set_state(answer.get_status());
        std::cout << "PtuTask.cc" << __LINE__ << ":" << eventState << std::endl;
        std::cout << "eventState.get_state(): " << __LINE__ << ":" << eventState.get_state() << std::endl;
        std::cout << "eventState.getNewState(): " << __LINE__ << ":" << eventState.getNewState() << std::endl;
        COMP->goalEventServer->put(eventState);

        COMP->stateSlave->release("move");
    }

    // it is possible to return != 0 (e.g. when the task detects errors), then the outer loop breaks and the task stops
    return 0;
}
int PtuTask::on_exit() {
    // use this method to clean-up resources which are initialized in on_entry() and needs to be freed before the on_execute() can be called again
    return 0;
}

bool PtuTask::init(const std::string &device) {

    // calculate transformation matrix for robot offset
    ParameterStateStruct::DomainPTUType::PTUParameterType::SENSOR_OFFSETType offset =
    COMP->getGlobalState().getDomainPTU().getPTUParameter().getSENSOR_OFFSET();

    EulerTransformationMatrices::create_zyx_matrix(offset.getX(), offset.getY(), offset.getZ(), offset.getAzimuth(),
        offset.getElevation(), offset.getRoll(), ptuRobotOffset);

    default_base_position.set_x(COMP->getGlobalState().getBase().getX());
    default_base_position.set_y(COMP->getGlobalState().getBase().getY());
    default_base_position.set_z(COMP->getGlobalState().getBase().getZ());
    default_base_position.set_base_azimuth(COMP->getGlobalState().getBase().getBase_a());
    default_base_position.set_base_elevation(COMP->getGlobalState().getBase().getSteer_a());
    default_base_position.set_base_roll(COMP->getGlobalState().getBase().getTurret_a());

    zero_velocity.set_vX(0);
    zero_velocity.set_vY(0);
    zero_velocity.set_vZ(0);
    zero_velocity.setWX(0);
    zero_velocity.setWY(0);
    zero_velocity.setWZ(0);

    startPTU();
    posChanged = true;
    return true;
}

void PtuTask::setGoal(const DomainPTU::CommPTUMoveRequest &request) {
    SmartACE::SmartGuard guard(goalBufferMutex);

//    std::cout << "<<<<<<<<<<<<<Added new Goal" << std::endl;
    this->oneElementGoalBuffer = request;
    this->newGoalCV.signal();

    guard.release();
}

/*-----------------------------------------------------------------
 move
 ----------------------------------------------------------------*/
void PtuTask::move(const DomainPTU::CommPTUMoveRequest &request, DomainPTU::CommPTUMoveResponse &answer) {
    PTUStatus status = PTUStatus::GOAL_REACHED;

    if (ptuActive) {
        switch (request.get_move_mode()) {

        case DomainPTU::PTUMoveFlag::PAN_ABSOLUTE:
            status = movePanAbs(request.get_pan());
            break;

        case DomainPTU::PTUMoveFlag::PAN_RELATIVE:
            status = movePanOff(request.get_pan());
            break;

        case DomainPTU::PTUMoveFlag::TILT_ABSOLUTE:
            status = moveTiltAbs(request.get_tilt());
            break;

        case DomainPTU::PTUMoveFlag::TILT_RELATIVE:
            status = moveTiltOff(request.get_tilt());
            break;

        case DomainPTU::PTUMoveFlag::PAN_TILT_ABSOLUTE:
            status = moveToAbsPos(request.get_pan(), request.get_tilt());
            break;

        case DomainPTU::PTUMoveFlag::PAN_TILT_RELATIVE:
            status = moveToOffPos(request.get_pan(), request.get_tilt());
            break;

        case DomainPTU::PTUMoveFlag::POSITION_ROBOT:
            status = lookPointRobot(request);
            break;

        case DomainPTU::PTUMoveFlag::POSITION_WORLD:
            status = lookPointWorld(request);
            break;

        }
        answer.set_status(status);
    } else {
        answer.set_status(DomainPTU::PTUMoveStatus::FAILURE);
    }

    std::cout << "PtuTask.cc" << __LINE__ << ":" << answer.get_status() << std::endl;
    posChanged = true;
}

PtuTask::PTUStatus PtuTask::lookPointRobot(const DomainPTU::CommPTUMoveRequest &request) {
    arma::mat offset;
    arma::vec point(4);
    point[3] = 1;

    offset = COMP->sensorOffset.getHomogeneousMatrix();
    request.get_position(point[0], point[1], point[2]);
    point = inv(ptuRobotOffset) * inv(offset) * point;

    double radius = sqrt(pow(point[0], 2) + pow(point[1], 2) + pow(point[2], 2));
    double pan = atan2(point[1], point[0]);
    double tilt = -1 * (acos(point[2] / radius) - M_PI_2);

    return moveToAbsPos(pan, tilt);
}

PtuTask::PTUStatus PtuTask::lookPointWorld(const DomainPTU::CommPTUMoveRequest &request) {
    CommBasicObjects::CommVoid voidRequest;
    CommBasicObjects::CommBaseState baseState;

    Smart::StatusCode statusCode;
    arma::mat offset;
    arma::mat robotPose;
    arma::vec point(4);
    point[3] = 1;

    if (COMP->getGlobalState().getBase().getOn_base()) {
        statusCode = COMP->baseStateQueryClient->query(voidRequest, baseState);
        if (statusCode != Smart::SMART_OK) {
            std::cerr << "ERROR during base get update state: " << Smart::StatusCodeConversion(statusCode) << "\n";
            return DomainPTU::PTUMoveStatus::FAILURE;
        }
        robotPose = baseState.get_base_position().get_base_pose3d().getHomogeneousMatrix();
    } else {
        robotPose = default_base_position.get_base_pose3d().getHomogeneousMatrix();
    }

//    std::cout << "robot Pose: " << robotPose << std::endl;

    offset = COMP->sensorOffset.getHomogeneousMatrix();
    request.get_position(point[0], point[1], point[2]);
    point = inv(robotPose) * inv(ptuRobotOffset) * inv(offset) * point;

    double radius = sqrt(pow(point[0], 2) + pow(point[1], 2) + pow(point[2], 2));
    double pan = atan2(point[1], point[0]);
    double tilt = -1 * (acos(point[2] / radius) - M_PI_2);

    return moveToAbsPos(pan, tilt);
}

void PtuTask::getPos(double &pan, double &tilt) {
    if (posChanged) {
        COMP->webotsTask->getPos(currentPan, currentTilt);
        posChanged = false;
    }

    pan = currentPan;
    tilt = currentTilt;
}

void PtuTask::startPTU() {
    ptuActive = true;
}

void PtuTask::stopPTU() {
    ptuActive = false;
    if (COMP->getGlobalState().getPTU().getVerbose()) {
        std::cout << ">> PTU halted\n";
    }
}

PtuTask::PTUStatus PtuTask::movePanAbs(double pan) {
//    std::cout << "[absolute] pan: " << pan << "\n";
    return COMP->webotsTask->movePanAbs(pan);
}

PtuTask::PTUStatus PtuTask::movePanOff(double pan) {
//    std::cout << "[relative] pan: " << pan << "\n";
    return COMP->webotsTask->movePanOff(pan);
}

PtuTask::PTUStatus PtuTask::moveTiltAbs(double tilt) {
//    std::cout << "[absolute] tilt: " << tilt << "\n";
    return COMP->webotsTask->moveTiltAbs(tilt);
}

PtuTask::PTUStatus PtuTask::moveTiltOff(double tilt) {
//    std::cout << "[relative] tilt: " << tilt << "\n";
    return COMP->webotsTask->moveTiltOff(tilt);
}

PtuTask::PTUStatus PtuTask::moveToAbsPos(double pan, double tilt) {
//    std::cout << "[absolute] pan: " << pan << ", tilt: " << tilt << "\n";
    return COMP->webotsTask->movePanTilt(pan, tilt);
}

PtuTask::PTUStatus PtuTask::moveToOffPos(double pan, double tilt) {
//    std::cout << "[relative] pan: " << pan << ", tilt: " << tilt << "\n";
    PTUStatus status = COMP->webotsTask->moveTiltOff(tilt);
    if (status != PTUStatus::GOAL_REACHED)
        return status;
    return COMP->webotsTask->movePanOff(pan);
}
