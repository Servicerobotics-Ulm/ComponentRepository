//--------------------------------------------------------------------------
// Code generated by the SmartSoft MDSD Toolchain
// The SmartSoft Toolchain has been developed by:
//  
// Service Robotics Research Center
// University of Applied Sciences Ulm
// Prittwitzstr. 10
// 89075 Ulm (Germany)
//
// Information about the SmartSoft MDSD Toolchain is available at:
// www.servicerobotik-ulm.de
//
// This file is generated once. Modify this file to your needs. 
// If you want the toolchain to re-generate this file, please 
// delete it before running the code generator.
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
//
//  Copyright (C) 2021 Thomas Feldmeier
//
//        schlegel@hs-ulm.de
//
//        Servicerobotic Ulm
//        University of Applied Sciences
//        Prittwitzstr. 10
//        89075 Ulm
//        Germany
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 2.1 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//--------------------------------------------------------------------------

#include "WebotsTask.hh"
#include "ComponentWebotsPTUServer.hh"

#include <iostream>

#include <webots/Supervisor.hpp>
#include <webots/Motor.hpp>
#include <webots/PositionSensor.hpp>
#include <webots/Keyboard.hpp>

using namespace webots;

// from https://stackoverflow.com/questions/154536/encode-decode-urls-in-c
std::string url_encode(const std::string &value) {
    std::ostringstream escaped;
    escaped.fill('0');
    escaped << std::hex;
    for (std::string::const_iterator i = value.begin(), n = value.end(); i != n; ++i) {
        std::string::value_type c = (*i);
        // Keep alphanumeric and other accepted characters intact
        if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
            escaped << c;
            continue;
        }
        // Any other characters are percent-encoded
        escaped << std::uppercase;
        escaped << '%' << std::setw(2) << int((unsigned char) c);
        escaped << std::nouppercase;
    }
    return escaped.str();
}

WebotsTask::WebotsTask(SmartACE::SmartComponent *comp) :
    WebotsTaskCore(comp) {
    std::unique_lock<std::mutex> lock(posReachedMutex);
    panTargetPosition = 0.0;
    tiltTargetPosition = 0.0;
    std::cout << "constructor WebotsTask" << std::endl;
}
WebotsTask::~WebotsTask() {
}

int WebotsTask::on_entry() {
    return 0;
}

void WebotsTask::handleEnterState(const std::string &substate) {
    if (substate == "move")
        newProgram = prMove;
    else if (substate == "servo")
        newProgram = prServo;
    else if (substate == "neutral")
        newProgram = prNeutral;
}

void WebotsTask::getPos(double &pan, double &tilt) {
    std::unique_lock<std::mutex> lck(posReachedMutex);

    pan = panPosition;
    tilt = tiltPosition;
}

WebotsTask::PTUStatus WebotsTask::movePanAbs(double pan) {
    return movePanTilt(pan, tiltPosition);
}
WebotsTask::PTUStatus WebotsTask::moveTiltAbs(double tilt) {
    return movePanTilt(panPosition, tilt);
}
WebotsTask::PTUStatus WebotsTask::movePanOff(double pan) {
    return movePanTilt(panPosition + pan, tiltPosition);
}
WebotsTask::PTUStatus WebotsTask::moveTiltOff(double tilt) {
    return movePanTilt(panPosition, tiltPosition + tilt);
}
WebotsTask::PTUStatus WebotsTask::movePanTilt(double pan, double tilt) {
    std::cout << "move to pan " << pan << " tilt " << tilt << std::endl;
    PTUStatus status;
    if (newProgram == prNeutral)
        status == PTUStatus::HALTED;
    else if (pan < panMinStop || pan > panMaxStop)
        status = PTUStatus::PAN_OUT_OF_RANGE;
    else if (tilt < tiltMinStop || tilt > tiltMaxStop)
        status = PTUStatus::TILT_OUT_OF_RANGE;
    else {
        std::unique_lock<std::mutex> lock(posReachedMutex);
        posReached = false;
        panTargetPosition = pan;
        tiltTargetPosition = tilt;
        if (newProgram == prMove) {
            std::cout << "start wait to reach goal position" << std::endl;
            waitTillPosReached.wait(lock, [this] {
                return posReached;
            });
            std::cout << "end wait to reach goal position" << std::endl;
            status = PTUStatus::GOAL_REACHED;
            std::cout << "GOAL_REACHED" << std::endl;
        } else
            status = PTUStatus::GOAL_NOT_REACHED;
    }
    if (status != PTUStatus::GOAL_REACHED /* && COMP->getGlobalState().getPTU().getVerbose() */)
        std::cout << ">> PTU Error: " << status << "\n";
    return status;
}

int WebotsTask::on_execute() {
    ParameterStateStruct params = COMP->getParameters();

// ********** robot ***********
    std::string name = params.getWebots().getRobotName();
    char environment[256] = "WEBOTS_CONTROLLER_URL=";
    putenv(strcat(environment, url_encode(name).c_str()));
    std::cout << "\033[0;32mConnect to webots robot with name '" << name << "' ...\033[0m" << std::endl;
    Supervisor *robot = new Supervisor();
    if (!robot) {
        std::cerr << "Webots Robot '" << name << "' not found" << std::endl;
        return -1;
    }
    Node *node = robot->getSelf();
    Field *panRotation = node->getField("panRotation");
    Field *tiltRotation = node->getField("tiltRotation");
    if(!panRotation || !tiltRotation) {
        std::cerr << "field panRotation or tiltRotation not found (is it PanTiltUnit.proto ?)" << std::endl;
        return -1;
    }
    std::cout << "\033[0;32mConnected\033[0m" << std::endl;

    panMinStop = -2.77;
    panMaxStop = 2.77;
    tiltMinStop = -0.820305;
    tiltMaxStop = 0.541052;

    Keyboard *webotsKeyboard = robot->getKeyboard();
    webotsKeyboard->enable(robot->getBasicTimeStep());

    /*
// *********** pan *************
    Motor *panMotor = robot->getMotor("PanMotor");
    PositionSensor *panSensor = robot->getPositionSensor("PanSensor");
    Node *node = robot->getSelf()->getFromProtoDef("PanJointParameters");
    if (!panMotor || !panSensor || !node) {
        std::cerr
            << "Webots RotationalMotor 'PanMotor' or PositionSensor 'PanSensor' or DEF PanJointParameters jointParameters not found"
            << std::endl;
        return -1;
    }
    panSensor->enable(robot->getBasicTimeStep());
    panMinStop = node->getField("minStop")->getSFFloat();
    panMaxStop = node->getField("maxStop")->getSFFloat();

// *********** tilt *************
    Motor *tiltMotor = robot->getMotor("TiltMotor");
    PositionSensor *tiltSensor = robot->getPositionSensor("TiltSensor");
    node = robot->getSelf()->getFromProtoDef("TiltJointParameters");
    if (!tiltMotor || !tiltSensor || !node) {
        std::cerr
            << "Webots RotationalMotor 'TiltMotor' or PositionSensor 'TiltSensor' or DEF TiltJointParameters jointParameters not found"
            << std::endl;
        return -1;
    }
    tiltSensor->enable(robot->getBasicTimeStep());
    tiltMinStop = node->getField("minStop")->getSFFloat();
    tiltMaxStop = node->getField("maxStop")->getSFFloat();
    // remove this?
    // panMotor->setVelocity(1.0);
    // tiltMotor->setVelocity(1.0);
*/
    while (robot->step(robot->getBasicTimeStep()) != -1) {
        Program program = newProgram;
        std::cout << "program=" << program << " pan=" << panPosition << " tilt=" << tiltPosition << std::endl;
//        if (program == prNeutral)
//            continue;
        int key = webotsKeyboard->getKey();
        {
            std::unique_lock<std::mutex> lock(posReachedMutex);

/*            panMotor -> setPosition(panTargetPosition);
            tiltMotor -> setPosition(tiltTargetPosition);
            panPosition = panSensor->getValue();
            tiltPosition = tiltSensor->getValue();
*/
            double speed = 2.0; // max speed of pan/tilt rotation [radians/s]
            double maxDiff = speed * robot->getBasicTimeStep() / 1000.0;
            if(key=='J')
                panTargetPosition += maxDiff;
            if(key=='L')
                panTargetPosition -= maxDiff;
            if(key=='I')
                tiltTargetPosition += maxDiff;
            if(key=='K')
                tiltTargetPosition -= maxDiff;
            double diff = panTargetPosition - panPosition;
            if(std::abs(diff) > maxDiff)
                diff = diff > 0 ? maxDiff : -maxDiff;
            panPosition = panPosition + diff;
            diff = tiltTargetPosition - tiltPosition;
            if(std::abs(diff) > maxDiff)
                diff = diff > 0 ? maxDiff : -maxDiff;
            tiltPosition = tiltPosition + diff;
            posReached = abs(panPosition - panTargetPosition) < 0.002 && abs(tiltPosition - tiltTargetPosition) < 0.002;

            const double* oldPanRotation = panRotation -> getSFRotation();
            const double newPanRotation[4] = {oldPanRotation[0], oldPanRotation[1], oldPanRotation[2], panPosition};
            panRotation->setSFRotation(newPanRotation);

            const double* oldTiltRotation = tiltRotation -> getSFRotation();
            const double newTiltRotation[4] = {oldTiltRotation[0], oldTiltRotation[1], oldTiltRotation[2], tiltPosition};
            tiltRotation->setSFRotation(newTiltRotation);
        }
        if (posReached)
            waitTillPosReached.notify_all();
    }
    delete robot;
    return 1; // webots world has ended, stop thread
}

int WebotsTask::on_exit() {
    return 0;
}

